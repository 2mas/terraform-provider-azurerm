package machinelearningservices

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"github.com/gofrs/uuid"
	"io"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "generated"

// ACIServiceCreateRequest ...
type ACIServiceCreateRequest struct {
	// ContainerResourceRequirements - The container resource requirements.
	ContainerResourceRequirements *ContainerResourceRequirements `json:"containerResourceRequirements,omitempty"`
	// AuthEnabled - Whether or not authentication is enabled on the service.
	AuthEnabled *bool `json:"authEnabled,omitempty"`
	// SslEnabled - Whether or not SSL is enabled.
	SslEnabled *bool `json:"sslEnabled,omitempty"`
	// AppInsightsEnabled - Whether or not Application Insights is enabled.
	AppInsightsEnabled *bool `json:"appInsightsEnabled,omitempty"`
	// DataCollection - Details of the data collection options specified.
	DataCollection *ModelDataCollection `json:"dataCollection,omitempty"`
	// SslCertificate - The SSL certificate to use if SSL is enabled.
	SslCertificate *string `json:"sslCertificate,omitempty"`
	// SslKey - The SSL key for the certificate.
	SslKey *string `json:"sslKey,omitempty"`
	// Cname - The CName for the service.
	Cname *string `json:"cname,omitempty"`
	// DNSNameLabel - The Dns label for the service.
	DNSNameLabel *string `json:"dnsNameLabel,omitempty"`
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The description of the service.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service properties dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// Keys - The authentication keys.
	Keys *AuthKeys `json:"keys,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ImageID - The Image Id.
	ImageID *string `json:"imageId,omitempty"`
	// EnvironmentImageRequest - The Environment, models and assets needed for inferencing.
	EnvironmentImageRequest *EnvironmentImageRequest `json:"environmentImageRequest,omitempty"`
	// Location - The location of the service.
	Location *string `json:"location,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeBasicCreateServiceRequestComputeTypeCreateServiceRequest', 'ComputeTypeBasicCreateServiceRequestComputeTypeACI', 'ComputeTypeBasicCreateServiceRequestComputeTypeAKS', 'ComputeTypeBasicCreateServiceRequestComputeTypeAKSENDPOINT', 'ComputeTypeBasicCreateServiceRequestComputeTypeCreateEndpointVariantRequest', 'ComputeTypeBasicCreateServiceRequestComputeTypeIOT'
	ComputeType ComputeTypeBasicCreateServiceRequest `json:"computeType,omitempty"`
}

// MarshalJSON is the custom marshaler for ACIServiceCreateRequest.
func (ascr ACIServiceCreateRequest) MarshalJSON() ([]byte, error) {
	ascr.ComputeType = ComputeTypeBasicCreateServiceRequestComputeTypeACI
	objectMap := make(map[string]interface{})
	if ascr.ContainerResourceRequirements != nil {
		objectMap["containerResourceRequirements"] = ascr.ContainerResourceRequirements
	}
	if ascr.AuthEnabled != nil {
		objectMap["authEnabled"] = ascr.AuthEnabled
	}
	if ascr.SslEnabled != nil {
		objectMap["sslEnabled"] = ascr.SslEnabled
	}
	if ascr.AppInsightsEnabled != nil {
		objectMap["appInsightsEnabled"] = ascr.AppInsightsEnabled
	}
	if ascr.DataCollection != nil {
		objectMap["dataCollection"] = ascr.DataCollection
	}
	if ascr.SslCertificate != nil {
		objectMap["sslCertificate"] = ascr.SslCertificate
	}
	if ascr.SslKey != nil {
		objectMap["sslKey"] = ascr.SslKey
	}
	if ascr.Cname != nil {
		objectMap["cname"] = ascr.Cname
	}
	if ascr.DNSNameLabel != nil {
		objectMap["dnsNameLabel"] = ascr.DNSNameLabel
	}
	if ascr.Name != nil {
		objectMap["name"] = ascr.Name
	}
	if ascr.Description != nil {
		objectMap["description"] = ascr.Description
	}
	if ascr.KvTags != nil {
		objectMap["kvTags"] = ascr.KvTags
	}
	if ascr.Properties != nil {
		objectMap["properties"] = ascr.Properties
	}
	if ascr.Keys != nil {
		objectMap["keys"] = ascr.Keys
	}
	if ascr.DeploymentType != "" {
		objectMap["deploymentType"] = ascr.DeploymentType
	}
	if ascr.ImageID != nil {
		objectMap["imageId"] = ascr.ImageID
	}
	if ascr.EnvironmentImageRequest != nil {
		objectMap["environmentImageRequest"] = ascr.EnvironmentImageRequest
	}
	if ascr.Location != nil {
		objectMap["location"] = ascr.Location
	}
	if ascr.ComputeType != "" {
		objectMap["computeType"] = ascr.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceCreateRequest is the BasicCreateServiceRequest implementation for ACIServiceCreateRequest.
func (ascr ACIServiceCreateRequest) AsACIServiceCreateRequest() (*ACIServiceCreateRequest, bool) {
	return &ascr, true
}

// AsAKSServiceCreateRequest is the BasicCreateServiceRequest implementation for ACIServiceCreateRequest.
func (ascr ACIServiceCreateRequest) AsAKSServiceCreateRequest() (*AKSServiceCreateRequest, bool) {
	return nil, false
}

// AsCreateEndpointRequest is the BasicCreateServiceRequest implementation for ACIServiceCreateRequest.
func (ascr ACIServiceCreateRequest) AsCreateEndpointRequest() (*CreateEndpointRequest, bool) {
	return nil, false
}

// AsCreateEndpointVariantRequest is the BasicCreateServiceRequest implementation for ACIServiceCreateRequest.
func (ascr ACIServiceCreateRequest) AsCreateEndpointVariantRequest() (*CreateEndpointVariantRequest, bool) {
	return nil, false
}

// AsBasicCreateEndpointVariantRequest is the BasicCreateServiceRequest implementation for ACIServiceCreateRequest.
func (ascr ACIServiceCreateRequest) AsBasicCreateEndpointVariantRequest() (BasicCreateEndpointVariantRequest, bool) {
	return nil, false
}

// AsCreateIotServiceRequest is the BasicCreateServiceRequest implementation for ACIServiceCreateRequest.
func (ascr ACIServiceCreateRequest) AsCreateIotServiceRequest() (*CreateIotServiceRequest, bool) {
	return nil, false
}

// AsCreateServiceRequest is the BasicCreateServiceRequest implementation for ACIServiceCreateRequest.
func (ascr ACIServiceCreateRequest) AsCreateServiceRequest() (*CreateServiceRequest, bool) {
	return nil, false
}

// AsBasicCreateServiceRequest is the BasicCreateServiceRequest implementation for ACIServiceCreateRequest.
func (ascr ACIServiceCreateRequest) AsBasicCreateServiceRequest() (BasicCreateServiceRequest, bool) {
	return &ascr, true
}

// ACIServiceResponse the response for an ACI service.
type ACIServiceResponse struct {
	// ContainerResourceRequirements - The container resource requirements.
	ContainerResourceRequirements *ContainerResourceRequirements `json:"containerResourceRequirements,omitempty"`
	// ImageID - The Id of the Image.
	ImageID *string `json:"imageId,omitempty"`
	// ImageDetails - The Image details.
	ImageDetails *DockerImageResponse `json:"imageDetails,omitempty"`
	// ScoringURI - The Uri for sending scoring requests.
	ScoringURI *string `json:"scoringUri,omitempty"`
	// Location - The location of the service.
	Location *string `json:"location,omitempty"`
	// AuthEnabled - Whether or not authentication is enabled on the service.
	AuthEnabled *bool `json:"authEnabled,omitempty"`
	// SslEnabled - Whether or not SSL is enabled.
	SslEnabled *bool `json:"sslEnabled,omitempty"`
	// AppInsightsEnabled - Whether or not Application Insights is enabled.
	AppInsightsEnabled *bool `json:"appInsightsEnabled,omitempty"`
	// DataCollection - Details of the data collection options specified.
	DataCollection *ModelDataCollection `json:"dataCollection,omitempty"`
	// SslCertificate - The SSL certificate to use if SSL is enabled.
	SslCertificate *string `json:"sslCertificate,omitempty"`
	// SslKey - The SSL key for the certificate.
	SslKey *string `json:"sslKey,omitempty"`
	// Cname - The CName for the service.
	Cname *string `json:"cname,omitempty"`
	// PublicIP - The public IP address for the service.
	PublicIP *string `json:"publicIp,omitempty"`
	// PublicFqdn - The public Fqdn for the service.
	PublicFqdn *string `json:"publicFqdn,omitempty"`
	// SwaggerURI - The Uri for sending swagger requests.
	SwaggerURI *string `json:"swaggerUri,omitempty"`
	// ModelConfigMap - Details on the models and configurations.
	ModelConfigMap map[string]interface{} `json:"modelConfigMap"`
	// Environment - Details on the Environment.
	Environment *ModelEnvironmentDefinition `json:"environment,omitempty"`
	// ModelsProperty - The list of models.
	ModelsProperty *[]Model `json:"models,omitempty"`
	// ID - The service Id.
	ID *string `json:"id,omitempty"`
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The service description.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service property dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// OperationID - The ID of the latest asynchronous operation for this service.
	OperationID *string `json:"operationId,omitempty"`
	// State - The current state of the service. Possible values include: 'WebServiceStateTransitioning', 'WebServiceStateHealthy', 'WebServiceStateUnhealthy', 'WebServiceStateFailed'
	State WebServiceState `json:"state,omitempty"`
	// CreatedTime - The time the service was created.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// UpdatedTime - The time the service was updated.
	UpdatedTime *date.Time `json:"updatedTime,omitempty"`
	// Error - The error details.
	Error *ModelErrorResponse `json:"error,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeServiceResponseBase', 'ComputeTypeACI', 'ComputeTypeAKS', 'ComputeTypeAKSENDPOINT', 'ComputeTypeAKSVariantResponse', 'ComputeTypeAMLCOMPUTE', 'ComputeTypeIOT', 'ComputeTypeUNKNOWON'
	ComputeType ComputeType `json:"computeType,omitempty"`
}

// MarshalJSON is the custom marshaler for ACIServiceResponse.
func (asr ACIServiceResponse) MarshalJSON() ([]byte, error) {
	asr.ComputeType = ComputeTypeACI
	objectMap := make(map[string]interface{})
	if asr.ContainerResourceRequirements != nil {
		objectMap["containerResourceRequirements"] = asr.ContainerResourceRequirements
	}
	if asr.ImageID != nil {
		objectMap["imageId"] = asr.ImageID
	}
	if asr.ImageDetails != nil {
		objectMap["imageDetails"] = asr.ImageDetails
	}
	if asr.ScoringURI != nil {
		objectMap["scoringUri"] = asr.ScoringURI
	}
	if asr.Location != nil {
		objectMap["location"] = asr.Location
	}
	if asr.AuthEnabled != nil {
		objectMap["authEnabled"] = asr.AuthEnabled
	}
	if asr.SslEnabled != nil {
		objectMap["sslEnabled"] = asr.SslEnabled
	}
	if asr.AppInsightsEnabled != nil {
		objectMap["appInsightsEnabled"] = asr.AppInsightsEnabled
	}
	if asr.DataCollection != nil {
		objectMap["dataCollection"] = asr.DataCollection
	}
	if asr.SslCertificate != nil {
		objectMap["sslCertificate"] = asr.SslCertificate
	}
	if asr.SslKey != nil {
		objectMap["sslKey"] = asr.SslKey
	}
	if asr.Cname != nil {
		objectMap["cname"] = asr.Cname
	}
	if asr.PublicIP != nil {
		objectMap["publicIp"] = asr.PublicIP
	}
	if asr.PublicFqdn != nil {
		objectMap["publicFqdn"] = asr.PublicFqdn
	}
	if asr.SwaggerURI != nil {
		objectMap["swaggerUri"] = asr.SwaggerURI
	}
	if asr.ModelConfigMap != nil {
		objectMap["modelConfigMap"] = asr.ModelConfigMap
	}
	if asr.Environment != nil {
		objectMap["environment"] = asr.Environment
	}
	if asr.ModelsProperty != nil {
		objectMap["models"] = asr.ModelsProperty
	}
	if asr.ID != nil {
		objectMap["id"] = asr.ID
	}
	if asr.Name != nil {
		objectMap["name"] = asr.Name
	}
	if asr.Description != nil {
		objectMap["description"] = asr.Description
	}
	if asr.KvTags != nil {
		objectMap["kvTags"] = asr.KvTags
	}
	if asr.Properties != nil {
		objectMap["properties"] = asr.Properties
	}
	if asr.OperationID != nil {
		objectMap["operationId"] = asr.OperationID
	}
	if asr.State != "" {
		objectMap["state"] = asr.State
	}
	if asr.CreatedTime != nil {
		objectMap["createdTime"] = asr.CreatedTime
	}
	if asr.UpdatedTime != nil {
		objectMap["updatedTime"] = asr.UpdatedTime
	}
	if asr.Error != nil {
		objectMap["error"] = asr.Error
	}
	if asr.DeploymentType != "" {
		objectMap["deploymentType"] = asr.DeploymentType
	}
	if asr.ComputeType != "" {
		objectMap["computeType"] = asr.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceResponse is the BasicServiceResponseBase implementation for ACIServiceResponse.
func (asr ACIServiceResponse) AsACIServiceResponse() (*ACIServiceResponse, bool) {
	return &asr, true
}

// AsAKSServiceResponse is the BasicServiceResponseBase implementation for ACIServiceResponse.
func (asr ACIServiceResponse) AsAKSServiceResponse() (*AKSServiceResponse, bool) {
	return nil, false
}

// AsAKSEndpointResponse is the BasicServiceResponseBase implementation for ACIServiceResponse.
func (asr ACIServiceResponse) AsAKSEndpointResponse() (*AKSEndpointResponse, bool) {
	return nil, false
}

// AsAKSVariantResponse is the BasicServiceResponseBase implementation for ACIServiceResponse.
func (asr ACIServiceResponse) AsAKSVariantResponse() (*AKSVariantResponse, bool) {
	return nil, false
}

// AsBasicAKSVariantResponse is the BasicServiceResponseBase implementation for ACIServiceResponse.
func (asr ACIServiceResponse) AsBasicAKSVariantResponse() (BasicAKSVariantResponse, bool) {
	return nil, false
}

// AsBatchServiceResponse is the BasicServiceResponseBase implementation for ACIServiceResponse.
func (asr ACIServiceResponse) AsBatchServiceResponse() (*BatchServiceResponse, bool) {
	return nil, false
}

// AsIotServiceResponse is the BasicServiceResponseBase implementation for ACIServiceResponse.
func (asr ACIServiceResponse) AsIotServiceResponse() (*IotServiceResponse, bool) {
	return nil, false
}

// AsUnknownServiceResponse is the BasicServiceResponseBase implementation for ACIServiceResponse.
func (asr ACIServiceResponse) AsUnknownServiceResponse() (*UnknownServiceResponse, bool) {
	return nil, false
}

// AsServiceResponseBase is the BasicServiceResponseBase implementation for ACIServiceResponse.
func (asr ACIServiceResponse) AsServiceResponseBase() (*ServiceResponseBase, bool) {
	return nil, false
}

// AsBasicServiceResponseBase is the BasicServiceResponseBase implementation for ACIServiceResponse.
func (asr ACIServiceResponse) AsBasicServiceResponseBase() (BasicServiceResponseBase, bool) {
	return &asr, true
}

// AKSEndpointResponse the response for an AKS Endpoint.
type AKSEndpointResponse struct {
	// ComputeName - The name of the compute resource.
	ComputeName *string `json:"computeName,omitempty"`
	// Namespace - The Kubernetes namespace of the deployment.
	Namespace *string `json:"namespace,omitempty"`
	// AppInsightsEnabled - Whether or not Application Insights is enabled.
	AppInsightsEnabled *bool `json:"appInsightsEnabled,omitempty"`
	// AuthEnabled - Whether or not authentication is enabled.
	AuthEnabled *bool `json:"authEnabled,omitempty"`
	// AadAuthEnabled - Whether or not AAD authentication is enabled.
	AadAuthEnabled *bool `json:"aadAuthEnabled,omitempty"`
	// SwaggerURI - The Uri for sending swagger requests.
	SwaggerURI *string `json:"swaggerUri,omitempty"`
	// ScoringURI - The Uri for sending scoring requests.
	ScoringURI *string `json:"scoringUri,omitempty"`
	// Variants - All the variants that belongs to this endpoint.
	Variants *[]AKSServiceResponse `json:"variants,omitempty"`
	// ID - The service Id.
	ID *string `json:"id,omitempty"`
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The service description.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service property dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// OperationID - The ID of the latest asynchronous operation for this service.
	OperationID *string `json:"operationId,omitempty"`
	// State - The current state of the service. Possible values include: 'WebServiceStateTransitioning', 'WebServiceStateHealthy', 'WebServiceStateUnhealthy', 'WebServiceStateFailed'
	State WebServiceState `json:"state,omitempty"`
	// CreatedTime - The time the service was created.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// UpdatedTime - The time the service was updated.
	UpdatedTime *date.Time `json:"updatedTime,omitempty"`
	// Error - The error details.
	Error *ModelErrorResponse `json:"error,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeServiceResponseBase', 'ComputeTypeACI', 'ComputeTypeAKS', 'ComputeTypeAKSENDPOINT', 'ComputeTypeAKSVariantResponse', 'ComputeTypeAMLCOMPUTE', 'ComputeTypeIOT', 'ComputeTypeUNKNOWON'
	ComputeType ComputeType `json:"computeType,omitempty"`
}

// MarshalJSON is the custom marshaler for AKSEndpointResponse.
func (aer AKSEndpointResponse) MarshalJSON() ([]byte, error) {
	aer.ComputeType = ComputeTypeAKSENDPOINT
	objectMap := make(map[string]interface{})
	if aer.ComputeName != nil {
		objectMap["computeName"] = aer.ComputeName
	}
	if aer.Namespace != nil {
		objectMap["namespace"] = aer.Namespace
	}
	if aer.AppInsightsEnabled != nil {
		objectMap["appInsightsEnabled"] = aer.AppInsightsEnabled
	}
	if aer.AuthEnabled != nil {
		objectMap["authEnabled"] = aer.AuthEnabled
	}
	if aer.AadAuthEnabled != nil {
		objectMap["aadAuthEnabled"] = aer.AadAuthEnabled
	}
	if aer.SwaggerURI != nil {
		objectMap["swaggerUri"] = aer.SwaggerURI
	}
	if aer.ScoringURI != nil {
		objectMap["scoringUri"] = aer.ScoringURI
	}
	if aer.Variants != nil {
		objectMap["variants"] = aer.Variants
	}
	if aer.ID != nil {
		objectMap["id"] = aer.ID
	}
	if aer.Name != nil {
		objectMap["name"] = aer.Name
	}
	if aer.Description != nil {
		objectMap["description"] = aer.Description
	}
	if aer.KvTags != nil {
		objectMap["kvTags"] = aer.KvTags
	}
	if aer.Properties != nil {
		objectMap["properties"] = aer.Properties
	}
	if aer.OperationID != nil {
		objectMap["operationId"] = aer.OperationID
	}
	if aer.State != "" {
		objectMap["state"] = aer.State
	}
	if aer.CreatedTime != nil {
		objectMap["createdTime"] = aer.CreatedTime
	}
	if aer.UpdatedTime != nil {
		objectMap["updatedTime"] = aer.UpdatedTime
	}
	if aer.Error != nil {
		objectMap["error"] = aer.Error
	}
	if aer.DeploymentType != "" {
		objectMap["deploymentType"] = aer.DeploymentType
	}
	if aer.ComputeType != "" {
		objectMap["computeType"] = aer.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceResponse is the BasicServiceResponseBase implementation for AKSEndpointResponse.
func (aer AKSEndpointResponse) AsACIServiceResponse() (*ACIServiceResponse, bool) {
	return nil, false
}

// AsAKSServiceResponse is the BasicServiceResponseBase implementation for AKSEndpointResponse.
func (aer AKSEndpointResponse) AsAKSServiceResponse() (*AKSServiceResponse, bool) {
	return nil, false
}

// AsAKSEndpointResponse is the BasicServiceResponseBase implementation for AKSEndpointResponse.
func (aer AKSEndpointResponse) AsAKSEndpointResponse() (*AKSEndpointResponse, bool) {
	return &aer, true
}

// AsAKSVariantResponse is the BasicServiceResponseBase implementation for AKSEndpointResponse.
func (aer AKSEndpointResponse) AsAKSVariantResponse() (*AKSVariantResponse, bool) {
	return nil, false
}

// AsBasicAKSVariantResponse is the BasicServiceResponseBase implementation for AKSEndpointResponse.
func (aer AKSEndpointResponse) AsBasicAKSVariantResponse() (BasicAKSVariantResponse, bool) {
	return nil, false
}

// AsBatchServiceResponse is the BasicServiceResponseBase implementation for AKSEndpointResponse.
func (aer AKSEndpointResponse) AsBatchServiceResponse() (*BatchServiceResponse, bool) {
	return nil, false
}

// AsIotServiceResponse is the BasicServiceResponseBase implementation for AKSEndpointResponse.
func (aer AKSEndpointResponse) AsIotServiceResponse() (*IotServiceResponse, bool) {
	return nil, false
}

// AsUnknownServiceResponse is the BasicServiceResponseBase implementation for AKSEndpointResponse.
func (aer AKSEndpointResponse) AsUnknownServiceResponse() (*UnknownServiceResponse, bool) {
	return nil, false
}

// AsServiceResponseBase is the BasicServiceResponseBase implementation for AKSEndpointResponse.
func (aer AKSEndpointResponse) AsServiceResponseBase() (*ServiceResponseBase, bool) {
	return nil, false
}

// AsBasicServiceResponseBase is the BasicServiceResponseBase implementation for AKSEndpointResponse.
func (aer AKSEndpointResponse) AsBasicServiceResponseBase() (BasicServiceResponseBase, bool) {
	return &aer, true
}

// AKSReplicaStatus ...
type AKSReplicaStatus struct {
	// DesiredReplicas - The desired number of replicas.
	DesiredReplicas *int32 `json:"desiredReplicas,omitempty"`
	// UpdatedReplicas - The number of updated replicas.
	UpdatedReplicas *int32 `json:"updatedReplicas,omitempty"`
	// AvailableReplicas - The number of available replicas.
	AvailableReplicas *int32 `json:"availableReplicas,omitempty"`
	// Error - The error details.
	Error *ModelErrorResponse `json:"error,omitempty"`
}

// AKSServiceCreateRequest the request to create an AKS service.
type AKSServiceCreateRequest struct {
	// NumReplicas - The number of replicas on the cluster.
	NumReplicas *int32 `json:"numReplicas,omitempty"`
	// DataCollection - Details of the data collection options specified.
	DataCollection *ModelDataCollection `json:"dataCollection,omitempty"`
	// ComputeName - The name of the compute resource.
	ComputeName *string `json:"computeName,omitempty"`
	// AppInsightsEnabled - Whether or not Application Insights is enabled.
	AppInsightsEnabled *bool `json:"appInsightsEnabled,omitempty"`
	// AutoScaler - The auto scaler properties.
	AutoScaler *AutoScaler `json:"autoScaler,omitempty"`
	// ContainerResourceRequirements - The container resource requirements.
	ContainerResourceRequirements *ContainerResourceRequirements `json:"containerResourceRequirements,omitempty"`
	// MaxConcurrentRequestsPerContainer - The maximum number of concurrent requests per container.
	MaxConcurrentRequestsPerContainer *int32 `json:"maxConcurrentRequestsPerContainer,omitempty"`
	// MaxQueueWaitMs - Maximum time a request will wait in the queue (in milliseconds). After this time, the service will return 503 (Service Unavailable)
	MaxQueueWaitMs *int32 `json:"maxQueueWaitMs,omitempty"`
	// Namespace - Kubernetes namespace for the service.
	Namespace *string `json:"namespace,omitempty"`
	// ScoringTimeoutMs - The scoring timeout in milliseconds.
	ScoringTimeoutMs *int32 `json:"scoringTimeoutMs,omitempty"`
	// AuthEnabled - Whether or not authentication is enabled.
	AuthEnabled *bool `json:"authEnabled,omitempty"`
	// LivenessProbeRequirements - The liveness probe requirements.
	LivenessProbeRequirements *LivenessProbeRequirements `json:"livenessProbeRequirements,omitempty"`
	// AadAuthEnabled - Whether or not AAD authentication is enabled.
	AadAuthEnabled *bool `json:"aadAuthEnabled,omitempty"`
	// IsDefault - Is this the default variant.
	IsDefault *bool `json:"isDefault,omitempty"`
	// TrafficPercentile - The amount of traffic variant receives.
	TrafficPercentile *float64 `json:"trafficPercentile,omitempty"`
	// Type - The type of the variant. Possible values include: 'Control', 'Treatment'
	Type VariantType `json:"type,omitempty"`
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The description of the service.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service properties dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// Keys - The authentication keys.
	Keys *AuthKeys `json:"keys,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ImageID - The Image Id.
	ImageID *string `json:"imageId,omitempty"`
	// EnvironmentImageRequest - The Environment, models and assets needed for inferencing.
	EnvironmentImageRequest *EnvironmentImageRequest `json:"environmentImageRequest,omitempty"`
	// Location - The location of the service.
	Location *string `json:"location,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeBasicCreateServiceRequestComputeTypeCreateServiceRequest', 'ComputeTypeBasicCreateServiceRequestComputeTypeACI', 'ComputeTypeBasicCreateServiceRequestComputeTypeAKS', 'ComputeTypeBasicCreateServiceRequestComputeTypeAKSENDPOINT', 'ComputeTypeBasicCreateServiceRequestComputeTypeCreateEndpointVariantRequest', 'ComputeTypeBasicCreateServiceRequestComputeTypeIOT'
	ComputeType ComputeTypeBasicCreateServiceRequest `json:"computeType,omitempty"`
}

// MarshalJSON is the custom marshaler for AKSServiceCreateRequest.
func (ascr AKSServiceCreateRequest) MarshalJSON() ([]byte, error) {
	ascr.ComputeType = ComputeTypeBasicCreateServiceRequestComputeTypeAKS
	objectMap := make(map[string]interface{})
	if ascr.NumReplicas != nil {
		objectMap["numReplicas"] = ascr.NumReplicas
	}
	if ascr.DataCollection != nil {
		objectMap["dataCollection"] = ascr.DataCollection
	}
	if ascr.ComputeName != nil {
		objectMap["computeName"] = ascr.ComputeName
	}
	if ascr.AppInsightsEnabled != nil {
		objectMap["appInsightsEnabled"] = ascr.AppInsightsEnabled
	}
	if ascr.AutoScaler != nil {
		objectMap["autoScaler"] = ascr.AutoScaler
	}
	if ascr.ContainerResourceRequirements != nil {
		objectMap["containerResourceRequirements"] = ascr.ContainerResourceRequirements
	}
	if ascr.MaxConcurrentRequestsPerContainer != nil {
		objectMap["maxConcurrentRequestsPerContainer"] = ascr.MaxConcurrentRequestsPerContainer
	}
	if ascr.MaxQueueWaitMs != nil {
		objectMap["maxQueueWaitMs"] = ascr.MaxQueueWaitMs
	}
	if ascr.Namespace != nil {
		objectMap["namespace"] = ascr.Namespace
	}
	if ascr.ScoringTimeoutMs != nil {
		objectMap["scoringTimeoutMs"] = ascr.ScoringTimeoutMs
	}
	if ascr.AuthEnabled != nil {
		objectMap["authEnabled"] = ascr.AuthEnabled
	}
	if ascr.LivenessProbeRequirements != nil {
		objectMap["livenessProbeRequirements"] = ascr.LivenessProbeRequirements
	}
	if ascr.AadAuthEnabled != nil {
		objectMap["aadAuthEnabled"] = ascr.AadAuthEnabled
	}
	if ascr.IsDefault != nil {
		objectMap["isDefault"] = ascr.IsDefault
	}
	if ascr.TrafficPercentile != nil {
		objectMap["trafficPercentile"] = ascr.TrafficPercentile
	}
	if ascr.Type != "" {
		objectMap["type"] = ascr.Type
	}
	if ascr.Name != nil {
		objectMap["name"] = ascr.Name
	}
	if ascr.Description != nil {
		objectMap["description"] = ascr.Description
	}
	if ascr.KvTags != nil {
		objectMap["kvTags"] = ascr.KvTags
	}
	if ascr.Properties != nil {
		objectMap["properties"] = ascr.Properties
	}
	if ascr.Keys != nil {
		objectMap["keys"] = ascr.Keys
	}
	if ascr.DeploymentType != "" {
		objectMap["deploymentType"] = ascr.DeploymentType
	}
	if ascr.ImageID != nil {
		objectMap["imageId"] = ascr.ImageID
	}
	if ascr.EnvironmentImageRequest != nil {
		objectMap["environmentImageRequest"] = ascr.EnvironmentImageRequest
	}
	if ascr.Location != nil {
		objectMap["location"] = ascr.Location
	}
	if ascr.ComputeType != "" {
		objectMap["computeType"] = ascr.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceCreateRequest is the BasicCreateServiceRequest implementation for AKSServiceCreateRequest.
func (ascr AKSServiceCreateRequest) AsACIServiceCreateRequest() (*ACIServiceCreateRequest, bool) {
	return nil, false
}

// AsAKSServiceCreateRequest is the BasicCreateServiceRequest implementation for AKSServiceCreateRequest.
func (ascr AKSServiceCreateRequest) AsAKSServiceCreateRequest() (*AKSServiceCreateRequest, bool) {
	return &ascr, true
}

// AsCreateEndpointRequest is the BasicCreateServiceRequest implementation for AKSServiceCreateRequest.
func (ascr AKSServiceCreateRequest) AsCreateEndpointRequest() (*CreateEndpointRequest, bool) {
	return nil, false
}

// AsCreateEndpointVariantRequest is the BasicCreateServiceRequest implementation for AKSServiceCreateRequest.
func (ascr AKSServiceCreateRequest) AsCreateEndpointVariantRequest() (*CreateEndpointVariantRequest, bool) {
	return nil, false
}

// AsBasicCreateEndpointVariantRequest is the BasicCreateServiceRequest implementation for AKSServiceCreateRequest.
func (ascr AKSServiceCreateRequest) AsBasicCreateEndpointVariantRequest() (BasicCreateEndpointVariantRequest, bool) {
	return &ascr, true
}

// AsCreateIotServiceRequest is the BasicCreateServiceRequest implementation for AKSServiceCreateRequest.
func (ascr AKSServiceCreateRequest) AsCreateIotServiceRequest() (*CreateIotServiceRequest, bool) {
	return nil, false
}

// AsCreateServiceRequest is the BasicCreateServiceRequest implementation for AKSServiceCreateRequest.
func (ascr AKSServiceCreateRequest) AsCreateServiceRequest() (*CreateServiceRequest, bool) {
	return nil, false
}

// AsBasicCreateServiceRequest is the BasicCreateServiceRequest implementation for AKSServiceCreateRequest.
func (ascr AKSServiceCreateRequest) AsBasicCreateServiceRequest() (BasicCreateServiceRequest, bool) {
	return &ascr, true
}

// AKSServiceResponse the response for an AKS service.
type AKSServiceResponse struct {
	// ImageDetails - The Docker Image details.
	ImageDetails BasicImageResponseBase `json:"imageDetails,omitempty"`
	// ImageID - The Id of the Image.
	ImageID *string `json:"imageId,omitempty"`
	// ModelsProperty - The list of models.
	ModelsProperty *[]Model `json:"models,omitempty"`
	// ContainerResourceRequirements - The container resource requirements.
	ContainerResourceRequirements *ContainerResourceRequirements `json:"containerResourceRequirements,omitempty"`
	// MaxConcurrentRequestsPerContainer - The maximum number of concurrent requests per container.
	MaxConcurrentRequestsPerContainer *int32 `json:"maxConcurrentRequestsPerContainer,omitempty"`
	// MaxQueueWaitMs - Maximum time a request will wait in the queue (in milliseconds). After this time, the service will return 503 (Service Unavailable)
	MaxQueueWaitMs *int32 `json:"maxQueueWaitMs,omitempty"`
	// ComputeName - The name of the compute resource.
	ComputeName *string `json:"computeName,omitempty"`
	// Namespace - The Kubernetes namespace of the deployment.
	Namespace *string `json:"namespace,omitempty"`
	// NumReplicas - The number of replicas on the cluster.
	NumReplicas *int32 `json:"numReplicas,omitempty"`
	// DataCollection - Details of the data collection options specified.
	DataCollection *ModelDataCollection `json:"dataCollection,omitempty"`
	// AppInsightsEnabled - Whether or not Application Insights is enabled.
	AppInsightsEnabled *bool `json:"appInsightsEnabled,omitempty"`
	// AutoScaler - The auto scaler properties.
	AutoScaler *AutoScaler `json:"autoScaler,omitempty"`
	// ScoringURI - The Uri for sending scoring requests.
	ScoringURI *string `json:"scoringUri,omitempty"`
	// DeploymentStatus - The deployment status.
	DeploymentStatus *AKSReplicaStatus `json:"deploymentStatus,omitempty"`
	// ScoringTimeoutMs - The scoring timeout in milliseconds.
	ScoringTimeoutMs *int32 `json:"scoringTimeoutMs,omitempty"`
	// LivenessProbeRequirements - The liveness probe requirements.
	LivenessProbeRequirements *LivenessProbeRequirements `json:"livenessProbeRequirements,omitempty"`
	// AuthEnabled - Whether or not authentication is enabled.
	AuthEnabled *bool `json:"authEnabled,omitempty"`
	// AadAuthEnabled - Whether or not AAD authentication is enabled.
	AadAuthEnabled *bool `json:"aadAuthEnabled,omitempty"`
	// SwaggerURI - The Uri for sending swagger requests.
	SwaggerURI *string `json:"swaggerUri,omitempty"`
	// ModelConfigMap - Details on the models and configurations.
	ModelConfigMap map[string]interface{} `json:"modelConfigMap"`
	// Environment - Details on the Environment.
	Environment *ModelEnvironmentDefinition `json:"environment,omitempty"`
	// IsDefault - Is this the default variant.
	IsDefault *bool `json:"isDefault,omitempty"`
	// TrafficPercentile - The amount of traffic variant receives.
	TrafficPercentile *float64 `json:"trafficPercentile,omitempty"`
	// Type - The type of the variant. Possible values include: 'Control', 'Treatment'
	Type VariantType `json:"type,omitempty"`
	// ID - The service Id.
	ID *string `json:"id,omitempty"`
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The service description.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service property dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// OperationID - The ID of the latest asynchronous operation for this service.
	OperationID *string `json:"operationId,omitempty"`
	// State - The current state of the service. Possible values include: 'WebServiceStateTransitioning', 'WebServiceStateHealthy', 'WebServiceStateUnhealthy', 'WebServiceStateFailed'
	State WebServiceState `json:"state,omitempty"`
	// CreatedTime - The time the service was created.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// UpdatedTime - The time the service was updated.
	UpdatedTime *date.Time `json:"updatedTime,omitempty"`
	// Error - The error details.
	Error *ModelErrorResponse `json:"error,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeServiceResponseBase', 'ComputeTypeACI', 'ComputeTypeAKS', 'ComputeTypeAKSENDPOINT', 'ComputeTypeAKSVariantResponse', 'ComputeTypeAMLCOMPUTE', 'ComputeTypeIOT', 'ComputeTypeUNKNOWON'
	ComputeType ComputeType `json:"computeType,omitempty"`
}

// MarshalJSON is the custom marshaler for AKSServiceResponse.
func (asr AKSServiceResponse) MarshalJSON() ([]byte, error) {
	asr.ComputeType = ComputeTypeAKS
	objectMap := make(map[string]interface{})
	objectMap["imageDetails"] = asr.ImageDetails
	if asr.ImageID != nil {
		objectMap["imageId"] = asr.ImageID
	}
	if asr.ModelsProperty != nil {
		objectMap["models"] = asr.ModelsProperty
	}
	if asr.ContainerResourceRequirements != nil {
		objectMap["containerResourceRequirements"] = asr.ContainerResourceRequirements
	}
	if asr.MaxConcurrentRequestsPerContainer != nil {
		objectMap["maxConcurrentRequestsPerContainer"] = asr.MaxConcurrentRequestsPerContainer
	}
	if asr.MaxQueueWaitMs != nil {
		objectMap["maxQueueWaitMs"] = asr.MaxQueueWaitMs
	}
	if asr.ComputeName != nil {
		objectMap["computeName"] = asr.ComputeName
	}
	if asr.Namespace != nil {
		objectMap["namespace"] = asr.Namespace
	}
	if asr.NumReplicas != nil {
		objectMap["numReplicas"] = asr.NumReplicas
	}
	if asr.DataCollection != nil {
		objectMap["dataCollection"] = asr.DataCollection
	}
	if asr.AppInsightsEnabled != nil {
		objectMap["appInsightsEnabled"] = asr.AppInsightsEnabled
	}
	if asr.AutoScaler != nil {
		objectMap["autoScaler"] = asr.AutoScaler
	}
	if asr.ScoringURI != nil {
		objectMap["scoringUri"] = asr.ScoringURI
	}
	if asr.DeploymentStatus != nil {
		objectMap["deploymentStatus"] = asr.DeploymentStatus
	}
	if asr.ScoringTimeoutMs != nil {
		objectMap["scoringTimeoutMs"] = asr.ScoringTimeoutMs
	}
	if asr.LivenessProbeRequirements != nil {
		objectMap["livenessProbeRequirements"] = asr.LivenessProbeRequirements
	}
	if asr.AuthEnabled != nil {
		objectMap["authEnabled"] = asr.AuthEnabled
	}
	if asr.AadAuthEnabled != nil {
		objectMap["aadAuthEnabled"] = asr.AadAuthEnabled
	}
	if asr.SwaggerURI != nil {
		objectMap["swaggerUri"] = asr.SwaggerURI
	}
	if asr.ModelConfigMap != nil {
		objectMap["modelConfigMap"] = asr.ModelConfigMap
	}
	if asr.Environment != nil {
		objectMap["environment"] = asr.Environment
	}
	if asr.IsDefault != nil {
		objectMap["isDefault"] = asr.IsDefault
	}
	if asr.TrafficPercentile != nil {
		objectMap["trafficPercentile"] = asr.TrafficPercentile
	}
	if asr.Type != "" {
		objectMap["type"] = asr.Type
	}
	if asr.ID != nil {
		objectMap["id"] = asr.ID
	}
	if asr.Name != nil {
		objectMap["name"] = asr.Name
	}
	if asr.Description != nil {
		objectMap["description"] = asr.Description
	}
	if asr.KvTags != nil {
		objectMap["kvTags"] = asr.KvTags
	}
	if asr.Properties != nil {
		objectMap["properties"] = asr.Properties
	}
	if asr.OperationID != nil {
		objectMap["operationId"] = asr.OperationID
	}
	if asr.State != "" {
		objectMap["state"] = asr.State
	}
	if asr.CreatedTime != nil {
		objectMap["createdTime"] = asr.CreatedTime
	}
	if asr.UpdatedTime != nil {
		objectMap["updatedTime"] = asr.UpdatedTime
	}
	if asr.Error != nil {
		objectMap["error"] = asr.Error
	}
	if asr.DeploymentType != "" {
		objectMap["deploymentType"] = asr.DeploymentType
	}
	if asr.ComputeType != "" {
		objectMap["computeType"] = asr.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceResponse is the BasicServiceResponseBase implementation for AKSServiceResponse.
func (asr AKSServiceResponse) AsACIServiceResponse() (*ACIServiceResponse, bool) {
	return nil, false
}

// AsAKSServiceResponse is the BasicServiceResponseBase implementation for AKSServiceResponse.
func (asr AKSServiceResponse) AsAKSServiceResponse() (*AKSServiceResponse, bool) {
	return &asr, true
}

// AsAKSEndpointResponse is the BasicServiceResponseBase implementation for AKSServiceResponse.
func (asr AKSServiceResponse) AsAKSEndpointResponse() (*AKSEndpointResponse, bool) {
	return nil, false
}

// AsAKSVariantResponse is the BasicServiceResponseBase implementation for AKSServiceResponse.
func (asr AKSServiceResponse) AsAKSVariantResponse() (*AKSVariantResponse, bool) {
	return nil, false
}

// AsBasicAKSVariantResponse is the BasicServiceResponseBase implementation for AKSServiceResponse.
func (asr AKSServiceResponse) AsBasicAKSVariantResponse() (BasicAKSVariantResponse, bool) {
	return &asr, true
}

// AsBatchServiceResponse is the BasicServiceResponseBase implementation for AKSServiceResponse.
func (asr AKSServiceResponse) AsBatchServiceResponse() (*BatchServiceResponse, bool) {
	return nil, false
}

// AsIotServiceResponse is the BasicServiceResponseBase implementation for AKSServiceResponse.
func (asr AKSServiceResponse) AsIotServiceResponse() (*IotServiceResponse, bool) {
	return nil, false
}

// AsUnknownServiceResponse is the BasicServiceResponseBase implementation for AKSServiceResponse.
func (asr AKSServiceResponse) AsUnknownServiceResponse() (*UnknownServiceResponse, bool) {
	return nil, false
}

// AsServiceResponseBase is the BasicServiceResponseBase implementation for AKSServiceResponse.
func (asr AKSServiceResponse) AsServiceResponseBase() (*ServiceResponseBase, bool) {
	return nil, false
}

// AsBasicServiceResponseBase is the BasicServiceResponseBase implementation for AKSServiceResponse.
func (asr AKSServiceResponse) AsBasicServiceResponseBase() (BasicServiceResponseBase, bool) {
	return &asr, true
}

// UnmarshalJSON is the custom unmarshaler for AKSServiceResponse struct.
func (asr *AKSServiceResponse) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "imageDetails":
			if v != nil {
				imageDetails, err := unmarshalBasicImageResponseBase(*v)
				if err != nil {
					return err
				}
				asr.ImageDetails = imageDetails
			}
		case "imageId":
			if v != nil {
				var imageID string
				err = json.Unmarshal(*v, &imageID)
				if err != nil {
					return err
				}
				asr.ImageID = &imageID
			}
		case "models":
			if v != nil {
				var modelsProperty []Model
				err = json.Unmarshal(*v, &modelsProperty)
				if err != nil {
					return err
				}
				asr.ModelsProperty = &modelsProperty
			}
		case "containerResourceRequirements":
			if v != nil {
				var containerResourceRequirements ContainerResourceRequirements
				err = json.Unmarshal(*v, &containerResourceRequirements)
				if err != nil {
					return err
				}
				asr.ContainerResourceRequirements = &containerResourceRequirements
			}
		case "maxConcurrentRequestsPerContainer":
			if v != nil {
				var maxConcurrentRequestsPerContainer int32
				err = json.Unmarshal(*v, &maxConcurrentRequestsPerContainer)
				if err != nil {
					return err
				}
				asr.MaxConcurrentRequestsPerContainer = &maxConcurrentRequestsPerContainer
			}
		case "maxQueueWaitMs":
			if v != nil {
				var maxQueueWaitMs int32
				err = json.Unmarshal(*v, &maxQueueWaitMs)
				if err != nil {
					return err
				}
				asr.MaxQueueWaitMs = &maxQueueWaitMs
			}
		case "computeName":
			if v != nil {
				var computeName string
				err = json.Unmarshal(*v, &computeName)
				if err != nil {
					return err
				}
				asr.ComputeName = &computeName
			}
		case "namespace":
			if v != nil {
				var namespace string
				err = json.Unmarshal(*v, &namespace)
				if err != nil {
					return err
				}
				asr.Namespace = &namespace
			}
		case "numReplicas":
			if v != nil {
				var numReplicas int32
				err = json.Unmarshal(*v, &numReplicas)
				if err != nil {
					return err
				}
				asr.NumReplicas = &numReplicas
			}
		case "dataCollection":
			if v != nil {
				var dataCollection ModelDataCollection
				err = json.Unmarshal(*v, &dataCollection)
				if err != nil {
					return err
				}
				asr.DataCollection = &dataCollection
			}
		case "appInsightsEnabled":
			if v != nil {
				var appInsightsEnabled bool
				err = json.Unmarshal(*v, &appInsightsEnabled)
				if err != nil {
					return err
				}
				asr.AppInsightsEnabled = &appInsightsEnabled
			}
		case "autoScaler":
			if v != nil {
				var autoScaler AutoScaler
				err = json.Unmarshal(*v, &autoScaler)
				if err != nil {
					return err
				}
				asr.AutoScaler = &autoScaler
			}
		case "scoringUri":
			if v != nil {
				var scoringURI string
				err = json.Unmarshal(*v, &scoringURI)
				if err != nil {
					return err
				}
				asr.ScoringURI = &scoringURI
			}
		case "deploymentStatus":
			if v != nil {
				var deploymentStatus AKSReplicaStatus
				err = json.Unmarshal(*v, &deploymentStatus)
				if err != nil {
					return err
				}
				asr.DeploymentStatus = &deploymentStatus
			}
		case "scoringTimeoutMs":
			if v != nil {
				var scoringTimeoutMs int32
				err = json.Unmarshal(*v, &scoringTimeoutMs)
				if err != nil {
					return err
				}
				asr.ScoringTimeoutMs = &scoringTimeoutMs
			}
		case "livenessProbeRequirements":
			if v != nil {
				var livenessProbeRequirements LivenessProbeRequirements
				err = json.Unmarshal(*v, &livenessProbeRequirements)
				if err != nil {
					return err
				}
				asr.LivenessProbeRequirements = &livenessProbeRequirements
			}
		case "authEnabled":
			if v != nil {
				var authEnabled bool
				err = json.Unmarshal(*v, &authEnabled)
				if err != nil {
					return err
				}
				asr.AuthEnabled = &authEnabled
			}
		case "aadAuthEnabled":
			if v != nil {
				var aadAuthEnabled bool
				err = json.Unmarshal(*v, &aadAuthEnabled)
				if err != nil {
					return err
				}
				asr.AadAuthEnabled = &aadAuthEnabled
			}
		case "swaggerUri":
			if v != nil {
				var swaggerURI string
				err = json.Unmarshal(*v, &swaggerURI)
				if err != nil {
					return err
				}
				asr.SwaggerURI = &swaggerURI
			}
		case "modelConfigMap":
			if v != nil {
				var modelConfigMap map[string]interface{}
				err = json.Unmarshal(*v, &modelConfigMap)
				if err != nil {
					return err
				}
				asr.ModelConfigMap = modelConfigMap
			}
		case "environment":
			if v != nil {
				var environment ModelEnvironmentDefinition
				err = json.Unmarshal(*v, &environment)
				if err != nil {
					return err
				}
				asr.Environment = &environment
			}
		case "isDefault":
			if v != nil {
				var isDefault bool
				err = json.Unmarshal(*v, &isDefault)
				if err != nil {
					return err
				}
				asr.IsDefault = &isDefault
			}
		case "trafficPercentile":
			if v != nil {
				var trafficPercentile float64
				err = json.Unmarshal(*v, &trafficPercentile)
				if err != nil {
					return err
				}
				asr.TrafficPercentile = &trafficPercentile
			}
		case "type":
			if v != nil {
				var typeVar VariantType
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				asr.Type = typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				asr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				asr.Name = &name
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				asr.Description = &description
			}
		case "kvTags":
			if v != nil {
				var kvTags map[string]*string
				err = json.Unmarshal(*v, &kvTags)
				if err != nil {
					return err
				}
				asr.KvTags = kvTags
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				asr.Properties = properties
			}
		case "operationId":
			if v != nil {
				var operationID string
				err = json.Unmarshal(*v, &operationID)
				if err != nil {
					return err
				}
				asr.OperationID = &operationID
			}
		case "state":
			if v != nil {
				var state WebServiceState
				err = json.Unmarshal(*v, &state)
				if err != nil {
					return err
				}
				asr.State = state
			}
		case "createdTime":
			if v != nil {
				var createdTime date.Time
				err = json.Unmarshal(*v, &createdTime)
				if err != nil {
					return err
				}
				asr.CreatedTime = &createdTime
			}
		case "updatedTime":
			if v != nil {
				var updatedTime date.Time
				err = json.Unmarshal(*v, &updatedTime)
				if err != nil {
					return err
				}
				asr.UpdatedTime = &updatedTime
			}
		case "error":
			if v != nil {
				var errorVar ModelErrorResponse
				err = json.Unmarshal(*v, &errorVar)
				if err != nil {
					return err
				}
				asr.Error = &errorVar
			}
		case "deploymentType":
			if v != nil {
				var deploymentType DeploymentType
				err = json.Unmarshal(*v, &deploymentType)
				if err != nil {
					return err
				}
				asr.DeploymentType = deploymentType
			}
		case "computeType":
			if v != nil {
				var computeType ComputeType
				err = json.Unmarshal(*v, &computeType)
				if err != nil {
					return err
				}
				asr.ComputeType = computeType
			}
		}
	}

	return nil
}

// BasicAKSVariantResponse the response for an AKS variant.
type BasicAKSVariantResponse interface {
	AsAKSServiceResponse() (*AKSServiceResponse, bool)
	AsAKSVariantResponse() (*AKSVariantResponse, bool)
}

// AKSVariantResponse the response for an AKS variant.
type AKSVariantResponse struct {
	// IsDefault - Is this the default variant.
	IsDefault *bool `json:"isDefault,omitempty"`
	// TrafficPercentile - The amount of traffic variant receives.
	TrafficPercentile *float64 `json:"trafficPercentile,omitempty"`
	// Type - The type of the variant. Possible values include: 'Control', 'Treatment'
	Type VariantType `json:"type,omitempty"`
	// ID - The service Id.
	ID *string `json:"id,omitempty"`
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The service description.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service property dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// OperationID - The ID of the latest asynchronous operation for this service.
	OperationID *string `json:"operationId,omitempty"`
	// State - The current state of the service. Possible values include: 'WebServiceStateTransitioning', 'WebServiceStateHealthy', 'WebServiceStateUnhealthy', 'WebServiceStateFailed'
	State WebServiceState `json:"state,omitempty"`
	// CreatedTime - The time the service was created.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// UpdatedTime - The time the service was updated.
	UpdatedTime *date.Time `json:"updatedTime,omitempty"`
	// Error - The error details.
	Error *ModelErrorResponse `json:"error,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeServiceResponseBase', 'ComputeTypeACI', 'ComputeTypeAKS', 'ComputeTypeAKSENDPOINT', 'ComputeTypeAKSVariantResponse', 'ComputeTypeAMLCOMPUTE', 'ComputeTypeIOT', 'ComputeTypeUNKNOWON'
	ComputeType ComputeType `json:"computeType,omitempty"`
}

func unmarshalBasicAKSVariantResponse(body []byte) (BasicAKSVariantResponse, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["computeType"] {
	case string(ComputeTypeAKS):
		var asr AKSServiceResponse
		err := json.Unmarshal(body, &asr)
		return asr, err
	default:
		var avr AKSVariantResponse
		err := json.Unmarshal(body, &avr)
		return avr, err
	}
}
func unmarshalBasicAKSVariantResponseArray(body []byte) ([]BasicAKSVariantResponse, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	avrArray := make([]BasicAKSVariantResponse, len(rawMessages))

	for index, rawMessage := range rawMessages {
		avr, err := unmarshalBasicAKSVariantResponse(*rawMessage)
		if err != nil {
			return nil, err
		}
		avrArray[index] = avr
	}
	return avrArray, nil
}

// MarshalJSON is the custom marshaler for AKSVariantResponse.
func (avr AKSVariantResponse) MarshalJSON() ([]byte, error) {
	avr.ComputeType = ComputeTypeAKSVariantResponse
	objectMap := make(map[string]interface{})
	if avr.IsDefault != nil {
		objectMap["isDefault"] = avr.IsDefault
	}
	if avr.TrafficPercentile != nil {
		objectMap["trafficPercentile"] = avr.TrafficPercentile
	}
	if avr.Type != "" {
		objectMap["type"] = avr.Type
	}
	if avr.ID != nil {
		objectMap["id"] = avr.ID
	}
	if avr.Name != nil {
		objectMap["name"] = avr.Name
	}
	if avr.Description != nil {
		objectMap["description"] = avr.Description
	}
	if avr.KvTags != nil {
		objectMap["kvTags"] = avr.KvTags
	}
	if avr.Properties != nil {
		objectMap["properties"] = avr.Properties
	}
	if avr.OperationID != nil {
		objectMap["operationId"] = avr.OperationID
	}
	if avr.State != "" {
		objectMap["state"] = avr.State
	}
	if avr.CreatedTime != nil {
		objectMap["createdTime"] = avr.CreatedTime
	}
	if avr.UpdatedTime != nil {
		objectMap["updatedTime"] = avr.UpdatedTime
	}
	if avr.Error != nil {
		objectMap["error"] = avr.Error
	}
	if avr.DeploymentType != "" {
		objectMap["deploymentType"] = avr.DeploymentType
	}
	if avr.ComputeType != "" {
		objectMap["computeType"] = avr.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceResponse is the BasicServiceResponseBase implementation for AKSVariantResponse.
func (avr AKSVariantResponse) AsACIServiceResponse() (*ACIServiceResponse, bool) {
	return nil, false
}

// AsAKSServiceResponse is the BasicServiceResponseBase implementation for AKSVariantResponse.
func (avr AKSVariantResponse) AsAKSServiceResponse() (*AKSServiceResponse, bool) {
	return nil, false
}

// AsAKSEndpointResponse is the BasicServiceResponseBase implementation for AKSVariantResponse.
func (avr AKSVariantResponse) AsAKSEndpointResponse() (*AKSEndpointResponse, bool) {
	return nil, false
}

// AsAKSVariantResponse is the BasicServiceResponseBase implementation for AKSVariantResponse.
func (avr AKSVariantResponse) AsAKSVariantResponse() (*AKSVariantResponse, bool) {
	return &avr, true
}

// AsBasicAKSVariantResponse is the BasicServiceResponseBase implementation for AKSVariantResponse.
func (avr AKSVariantResponse) AsBasicAKSVariantResponse() (BasicAKSVariantResponse, bool) {
	return &avr, true
}

// AsBatchServiceResponse is the BasicServiceResponseBase implementation for AKSVariantResponse.
func (avr AKSVariantResponse) AsBatchServiceResponse() (*BatchServiceResponse, bool) {
	return nil, false
}

// AsIotServiceResponse is the BasicServiceResponseBase implementation for AKSVariantResponse.
func (avr AKSVariantResponse) AsIotServiceResponse() (*IotServiceResponse, bool) {
	return nil, false
}

// AsUnknownServiceResponse is the BasicServiceResponseBase implementation for AKSVariantResponse.
func (avr AKSVariantResponse) AsUnknownServiceResponse() (*UnknownServiceResponse, bool) {
	return nil, false
}

// AsServiceResponseBase is the BasicServiceResponseBase implementation for AKSVariantResponse.
func (avr AKSVariantResponse) AsServiceResponseBase() (*ServiceResponseBase, bool) {
	return nil, false
}

// AsBasicServiceResponseBase is the BasicServiceResponseBase implementation for AKSVariantResponse.
func (avr AKSVariantResponse) AsBasicServiceResponseBase() (BasicServiceResponseBase, bool) {
	return &avr, true
}

// Artifact details of an Artifact.
type Artifact struct {
	autorest.Response `json:"-"`
	// ArtifactID - The identifier of an Artifact. Format of ArtifactId - {Origin}/{Container}/{Path}.
	ArtifactID *string `json:"artifactId,omitempty"`
	// Origin - The origin of the Artifact creation request. Available origins are 'ExperimentRun', 'LocalUpload', 'WebUpload', 'Dataset' and 'Unknown'.
	Origin *string `json:"origin,omitempty"`
	// Container - The name of container. Artifacts can be grouped by container.
	Container *string `json:"container,omitempty"`
	// Path - The path to the Artifact in a container.
	Path *string `json:"path,omitempty"`
	// Etag - READ-ONLY; The Etag of the Artifact.
	Etag *string `json:"etag,omitempty"`
	// CreatedTime - READ-ONLY; The Date and Time at which the Artifact is created. The DateTime is in UTC.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	DataPath    *DataPath  `json:"dataPath,omitempty"`
}

// MarshalJSON is the custom marshaler for Artifact.
func (a Artifact) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.ArtifactID != nil {
		objectMap["artifactId"] = a.ArtifactID
	}
	if a.Origin != nil {
		objectMap["origin"] = a.Origin
	}
	if a.Container != nil {
		objectMap["container"] = a.Container
	}
	if a.Path != nil {
		objectMap["path"] = a.Path
	}
	if a.DataPath != nil {
		objectMap["dataPath"] = a.DataPath
	}
	return json.Marshal(objectMap)
}

// ArtifactContainerSas details of the Artifact Container's shared access signature.
type ArtifactContainerSas struct {
	// ContainerSas - The shared access signature of the Container.
	ContainerSas *string `json:"containerSas,omitempty"`
	// ContainerURI - The URI of the Container.
	ContainerURI *string `json:"containerUri,omitempty"`
	// Prefix - The Prefix to the Blobs in the Container.
	Prefix *string `json:"prefix,omitempty"`
	// ArtifactPrefix - The Prefix to the Artifact in the Blob.
	ArtifactPrefix *string `json:"artifactPrefix,omitempty"`
}

// ArtifactContentInformation details of an Artifact Content Information.
type ArtifactContentInformation struct {
	autorest.Response `json:"-"`
	// ContentURI - The URI of the content.
	ContentURI *string `json:"contentUri,omitempty"`
	// Origin - The origin of the Artifact creation request. Available origins are 'ExperimentRun', 'LocalUpload', 'WebUpload', 'Dataset', 'ComputeRecord', 'Metric', and 'Unknown'.
	Origin *string `json:"origin,omitempty"`
	// Container - The name of container. Artifacts can be grouped by container.
	Container *string `json:"container,omitempty"`
	// Path - The path to the Artifact in a container.
	Path *string `json:"path,omitempty"`
}

// ArtifactDetails ...
type ArtifactDetails struct {
	ID     *string `json:"id,omitempty"`
	Prefix *string `json:"prefix,omitempty"`
}

// ArtifactIDList contains list of Artifact Ids.
type ArtifactIDList struct {
	// ArtifactIds - List of Artifacts Ids.
	ArtifactIds *[]string `json:"artifactIds,omitempty"`
}

// ArtifactPath details of an Artifact Path.
type ArtifactPath struct {
	// Path - The path to the Artifact in a container.
	Path *string `json:"path,omitempty"`
}

// ArtifactPathList contains list of Artifact Paths.
type ArtifactPathList struct {
	// Paths - List of Artifact Paths.
	Paths *[]ArtifactPath `json:"paths,omitempty"`
}

// Asset the Asset definition.
type Asset struct {
	autorest.Response `json:"-"`
	// ID - The Asset Id.
	ID *string `json:"id,omitempty"`
	// Name - The name of the Asset.
	Name *string `json:"name,omitempty"`
	// Description - The Asset description.
	Description *string `json:"description,omitempty"`
	// Artifacts - A list of child artifacts.
	Artifacts *[]ArtifactDetails `json:"artifacts,omitempty"`
	// KvTags - The Asset tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The Asset property dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// Runid - The RunId associated with this Asset.
	Runid *string `json:"runid,omitempty"`
	// Meta - A dictionary containing metadata about the Asset.
	Meta map[string]*string `json:"meta"`
	// CreatedTime - READ-ONLY; The time the Asset was created in UTC.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
}

// MarshalJSON is the custom marshaler for Asset.
func (a Asset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.ID != nil {
		objectMap["id"] = a.ID
	}
	if a.Name != nil {
		objectMap["name"] = a.Name
	}
	if a.Description != nil {
		objectMap["description"] = a.Description
	}
	if a.Artifacts != nil {
		objectMap["artifacts"] = a.Artifacts
	}
	if a.KvTags != nil {
		objectMap["kvTags"] = a.KvTags
	}
	if a.Properties != nil {
		objectMap["properties"] = a.Properties
	}
	if a.Runid != nil {
		objectMap["runid"] = a.Runid
	}
	if a.Meta != nil {
		objectMap["meta"] = a.Meta
	}
	return json.Marshal(objectMap)
}

// AsyncOperationDetails the async operation details.
type AsyncOperationDetails struct {
	// SubOperationType - The suboperation type.
	SubOperationType *string `json:"subOperationType,omitempty"`
	// SubOperationState - The suboperation state.
	SubOperationState *string `json:"subOperationState,omitempty"`
}

// AsyncOperationStatus the async operation status.
type AsyncOperationStatus struct {
	autorest.Response `json:"-"`
	// ID - The async operation id.
	ID *string `json:"id,omitempty"`
	// OperationType - The async operation type.
	OperationType *string `json:"operationType,omitempty"`
	// State - The async operation state. Possible values include: 'NotStarted', 'Running', 'Cancelled', 'Succeeded', 'Failed', 'TimedOut'
	State AsyncOperationState `json:"state,omitempty"`
	// CreatedTime - The async operation creation time (UTC).
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// EndTime - The async operation end time (UTC)l
	EndTime *date.Time `json:"endTime,omitempty"`
	// Error - The error details.
	Error *ModelErrorResponse `json:"error,omitempty"`
	// ResourceLocation - The resource created/updated by the async operation.
	ResourceLocation *string `json:"resourceLocation,omitempty"`
	// OperationLog - The async operation log.
	OperationLog *string `json:"operationLog,omitempty"`
	// OperationDetails - The async operation details.
	OperationDetails *AsyncOperationDetails `json:"operationDetails,omitempty"`
	// ParentRequestID - The request id that created this operation
	ParentRequestID *string `json:"parentRequestId,omitempty"`
}

// AuthKeys ...
type AuthKeys struct {
	autorest.Response `json:"-"`
	// PrimaryKey - The primary key.
	PrimaryKey *string `json:"primaryKey,omitempty"`
	// SecondaryKey - The secondary key.
	SecondaryKey *string `json:"secondaryKey,omitempty"`
}

// AuthToken service Token
type AuthToken struct {
	autorest.Response `json:"-"`
	// AccessToken - Access token.
	AccessToken *string `json:"accessToken,omitempty"`
	// TokenType - Access token type.
	TokenType *string `json:"tokenType,omitempty"`
	// ExpiryOn - Access token expiry time (UTC).
	ExpiryOn *int64 `json:"expiryOn,omitempty"`
	// RefreshAfter - Refresh access token after time (UTC).
	RefreshAfter *int64 `json:"refreshAfter,omitempty"`
}

// AutoScaler the Auto Scaler properties.
type AutoScaler struct {
	// AutoscaleEnabled - Option to enable/disable auto scaling.
	AutoscaleEnabled *bool `json:"autoscaleEnabled,omitempty"`
	// MinReplicas - The minimum number of replicas to scale down to.
	MinReplicas *int32 `json:"minReplicas,omitempty"`
	// MaxReplicas - The maximum number of replicas in the cluster.
	MaxReplicas *int32 `json:"maxReplicas,omitempty"`
	// TargetUtilization - The target utilization percentage to use for determining whether to scale the cluster.
	TargetUtilization *int32 `json:"targetUtilization,omitempty"`
	// RefreshPeriodInSeconds - The amount of seconds to wait between auto scale updates.
	RefreshPeriodInSeconds *int32 `json:"refreshPeriodInSeconds,omitempty"`
}

// AzureDataLake ...
type AzureDataLake struct {
	// StoreName - The Azure Data Lake store name
	StoreName *string `json:"storeName,omitempty"`
	// ClientID - The Client ID/Application ID
	ClientID *uuid.UUID `json:"clientId,omitempty"`
	// TenantID - The ID of the tenant the service principal/app belongs to
	TenantID *uuid.UUID `json:"tenantId,omitempty"`
	// IsCertAuth - Is it using certificate to authenticate. If false then use client secret
	IsCertAuth *bool `json:"isCertAuth,omitempty"`
	// Certificate - The content of the certificate used for authentication
	Certificate *string `json:"certificate,omitempty"`
	// Thumbprint - The thumbprint of the certificate above
	Thumbprint *string `json:"thumbprint,omitempty"`
	// ClientSecret - The client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// AuthorityURL - The authority URL used for authentication
	AuthorityURL *string `json:"authorityUrl,omitempty"`
	// ResourceURI - The resource the service principal/app has access to
	ResourceURI *string `json:"resourceUri,omitempty"`
	// SubscriptionID - Subscription Id
	SubscriptionID *uuid.UUID `json:"subscriptionId,omitempty"`
	// ResourceGroup - Resource Group Name
	ResourceGroup *string `json:"resourceGroup,omitempty"`
}

// AzurePostgreSQL ...
type AzurePostgreSQL struct {
	// ServerName - The Azure PostgreSQL server name
	ServerName *string `json:"serverName,omitempty"`
	// DatabaseName - The Azure PostgreSQL database name
	DatabaseName *string `json:"databaseName,omitempty"`
	// UserID - The Azure PostgreSQL user id
	UserID *string `json:"userId,omitempty"`
	// UserPassword - The Azure PostgreSQL user password
	UserPassword *string `json:"userPassword,omitempty"`
	// PortNumber - The Azure PostgreSQL port number
	PortNumber *string `json:"portNumber,omitempty"`
	// Endpoint - The Azure PostgreSQL server host endpoint
	Endpoint *string `json:"endpoint,omitempty"`
	// SubscriptionID - Subscription Id
	SubscriptionID *uuid.UUID `json:"subscriptionId,omitempty"`
	// ResourceGroup - Resource Group Name
	ResourceGroup *string `json:"resourceGroup,omitempty"`
}

// AzureSQLDatabase ...
type AzureSQLDatabase struct {
	// ServerName - The Azure SQL server name
	ServerName *string `json:"serverName,omitempty"`
	// DatabaseName - The Azure SQL database name
	DatabaseName *string `json:"databaseName,omitempty"`
	// Endpoint - The server host endpoint
	Endpoint *string `json:"endpoint,omitempty"`
	// ClientID - The Client ID/Application ID
	ClientID *uuid.UUID `json:"clientId,omitempty"`
	// TenantID - The ID of the tenant the service principal/app belongs to
	TenantID *uuid.UUID `json:"tenantId,omitempty"`
	// IsCertAuth - Is it using certificate to authenticate. If false then use client secret
	IsCertAuth *bool `json:"isCertAuth,omitempty"`
	// Certificate - The content of the certificate used for authentication
	Certificate *string `json:"certificate,omitempty"`
	// Thumbprint - The thumbprint of the certificate above
	Thumbprint *string `json:"thumbprint,omitempty"`
	// ClientSecret - The client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// AuthorityURL - The authority URL used for authentication
	AuthorityURL *string `json:"authorityUrl,omitempty"`
	// ResourceURI - The resource the service principal/app has access to
	ResourceURI *string `json:"resourceUri,omitempty"`
	// SubscriptionID - Subscription Id
	SubscriptionID *uuid.UUID `json:"subscriptionId,omitempty"`
	// ResourceGroup - Resource Group Name
	ResourceGroup *string `json:"resourceGroup,omitempty"`
}

// AzureStorage ...
type AzureStorage struct {
	// AccountName - Storage Account Name
	AccountName *string `json:"accountName,omitempty"`
	// ContainerName - The storage container name
	ContainerName *string `json:"containerName,omitempty"`
	// Endpoint - The host of the container
	Endpoint *string `json:"endpoint,omitempty"`
	// Protocol - The protocol to use. Defaults to https
	Protocol *string `json:"protocol,omitempty"`
	// CredentialType - The credential type. Possible values include: 'AzureStorageCredentialTypesNone', 'AzureStorageCredentialTypesSas', 'AzureStorageCredentialTypesAccountKey', 'AzureStorageCredentialTypesClientCredentials'
	CredentialType AzureStorageCredentialTypes `json:"credentialType,omitempty"`
	// Credential - The credential
	Credential *string `json:"credential,omitempty"`
	// ClientCredentials - Service principal credential when credential type is Microsoft.MachineLearning.DataStore.Contracts.AzureStorageCredentialTypes.ClientCredentials
	ClientCredentials *ClientCredentials `json:"clientCredentials,omitempty"`
	// BlobCacheTimeout - If this is an Microsoft.MachineLearning.DataStore.Contracts.DataStoreType.AzureBlob, the length of time (in seconds) to cache files locally after they are accessed (downloaded).
	BlobCacheTimeout *int32 `json:"blobCacheTimeout,omitempty"`
	// IsSas - Indicate if we are using SAS token or Account Key (Deprecated)
	IsSas *bool `json:"isSas,omitempty"`
	// AccountKey - Storage Account Key (Deprecated)
	AccountKey *string `json:"accountKey,omitempty"`
	// SasToken - SAS Token for the container (Deprecated)
	SasToken *string `json:"sasToken,omitempty"`
	// AreWorkspaceManagedIdentitiesAllowed - Indicate if we are using Workspace ManagedIdentities/MSI token
	AreWorkspaceManagedIdentitiesAllowed *bool `json:"areWorkspaceManagedIdentitiesAllowed,omitempty"`
	// SubscriptionID - Subscription Id
	SubscriptionID *uuid.UUID `json:"subscriptionId,omitempty"`
	// ResourceGroup - Resource Group Name
	ResourceGroup *string `json:"resourceGroup,omitempty"`
}

// BaseEvent base event is the envelope used to post event data to the Event controller
type BaseEvent struct {
	Timestamp *date.Time  `json:"timestamp,omitempty"`
	Name      *string     `json:"name,omitempty"`
	Data      interface{} `json:"data,omitempty"`
}

// BatchAddOrModifyRunRequest ...
type BatchAddOrModifyRunRequest struct {
	Runs *[]CreateRun `json:"runs,omitempty"`
}

// BatchAddOrModifyRunResult ...
type BatchAddOrModifyRunResult struct {
	autorest.Response `json:"-"`
	Runs              map[string]*Run           `json:"runs"`
	Errors            map[string]*ErrorResponse `json:"errors"`
}

// MarshalJSON is the custom marshaler for BatchAddOrModifyRunResult.
func (baomrr BatchAddOrModifyRunResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if baomrr.Runs != nil {
		objectMap["runs"] = baomrr.Runs
	}
	if baomrr.Errors != nil {
		objectMap["errors"] = baomrr.Errors
	}
	return json.Marshal(objectMap)
}

// BatchArtifactContentInformationResult results of the Batch Artifact Content Information request.
type BatchArtifactContentInformationResult struct {
	autorest.Response `json:"-"`
	// Artifacts - Artifact details of the Artifact Ids requested.
	Artifacts map[string]*Artifact `json:"artifacts"`
	// ArtifactContentInformation - Artifact Content Information details of the Artifact Ids requested.
	ArtifactContentInformation map[string]*ArtifactContentInformation `json:"artifactContentInformation"`
	// Errors - Errors occurred while fetching the requested Artifact Ids.
	Errors map[string]*ErrorResponse `json:"errors"`
}

// MarshalJSON is the custom marshaler for BatchArtifactContentInformationResult.
func (bacir BatchArtifactContentInformationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bacir.Artifacts != nil {
		objectMap["artifacts"] = bacir.Artifacts
	}
	if bacir.ArtifactContentInformation != nil {
		objectMap["artifactContentInformation"] = bacir.ArtifactContentInformation
	}
	if bacir.Errors != nil {
		objectMap["errors"] = bacir.Errors
	}
	return json.Marshal(objectMap)
}

// BatchEventCommand ...
type BatchEventCommand struct {
	Events *[]BaseEvent `json:"events,omitempty"`
}

// BatchEventCommandResult ...
type BatchEventCommandResult struct {
	autorest.Response `json:"-"`
	Errors            *[]KeyValuePairBaseEventErrorResponse `json:"errors,omitempty"`
}

// BatchMetric ...
type BatchMetric struct {
	Values *[]Metric `json:"values,omitempty"`
}

// BatchServiceResponse ...
type BatchServiceResponse struct {
	ModelIds            *[]string            `json:"modelIds,omitempty"`
	ComputeName         *string              `json:"computeName,omitempty"`
	EnvironmentName     *string              `json:"environmentName,omitempty"`
	EnvironmentVersion  *string              `json:"environmentVersion,omitempty"`
	ScoringURI          *string              `json:"scoringUri,omitempty"`
	AppInsightsEnabled  *bool                `json:"appInsightsEnabled,omitempty"`
	ModelDataCollection *ModelDataCollection `json:"modelDataCollection,omitempty"`
	EntryScript         *string              `json:"entryScript,omitempty"`
	InputFormat         *string              `json:"inputFormat,omitempty"`
	OutputAction        *string              `json:"outputAction,omitempty"`
	MiniBatchSize       *int32               `json:"miniBatchSize,omitempty"`
	ErrorThreshold      *float64             `json:"errorThreshold,omitempty"`
	NodeCount           *int32               `json:"nodeCount,omitempty"`
	ProcessCountPerNode *int32               `json:"processCountPerNode,omitempty"`
	// ID - The service Id.
	ID *string `json:"id,omitempty"`
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The service description.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service property dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// OperationID - The ID of the latest asynchronous operation for this service.
	OperationID *string `json:"operationId,omitempty"`
	// State - The current state of the service. Possible values include: 'WebServiceStateTransitioning', 'WebServiceStateHealthy', 'WebServiceStateUnhealthy', 'WebServiceStateFailed'
	State WebServiceState `json:"state,omitempty"`
	// CreatedTime - The time the service was created.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// UpdatedTime - The time the service was updated.
	UpdatedTime *date.Time `json:"updatedTime,omitempty"`
	// Error - The error details.
	Error *ModelErrorResponse `json:"error,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeServiceResponseBase', 'ComputeTypeACI', 'ComputeTypeAKS', 'ComputeTypeAKSENDPOINT', 'ComputeTypeAKSVariantResponse', 'ComputeTypeAMLCOMPUTE', 'ComputeTypeIOT', 'ComputeTypeUNKNOWON'
	ComputeType ComputeType `json:"computeType,omitempty"`
}

// MarshalJSON is the custom marshaler for BatchServiceResponse.
func (bsr BatchServiceResponse) MarshalJSON() ([]byte, error) {
	bsr.ComputeType = ComputeTypeAMLCOMPUTE
	objectMap := make(map[string]interface{})
	if bsr.ModelIds != nil {
		objectMap["modelIds"] = bsr.ModelIds
	}
	if bsr.ComputeName != nil {
		objectMap["computeName"] = bsr.ComputeName
	}
	if bsr.EnvironmentName != nil {
		objectMap["environmentName"] = bsr.EnvironmentName
	}
	if bsr.EnvironmentVersion != nil {
		objectMap["environmentVersion"] = bsr.EnvironmentVersion
	}
	if bsr.ScoringURI != nil {
		objectMap["scoringUri"] = bsr.ScoringURI
	}
	if bsr.AppInsightsEnabled != nil {
		objectMap["appInsightsEnabled"] = bsr.AppInsightsEnabled
	}
	if bsr.ModelDataCollection != nil {
		objectMap["modelDataCollection"] = bsr.ModelDataCollection
	}
	if bsr.EntryScript != nil {
		objectMap["entryScript"] = bsr.EntryScript
	}
	if bsr.InputFormat != nil {
		objectMap["inputFormat"] = bsr.InputFormat
	}
	if bsr.OutputAction != nil {
		objectMap["outputAction"] = bsr.OutputAction
	}
	if bsr.MiniBatchSize != nil {
		objectMap["miniBatchSize"] = bsr.MiniBatchSize
	}
	if bsr.ErrorThreshold != nil {
		objectMap["errorThreshold"] = bsr.ErrorThreshold
	}
	if bsr.NodeCount != nil {
		objectMap["nodeCount"] = bsr.NodeCount
	}
	if bsr.ProcessCountPerNode != nil {
		objectMap["processCountPerNode"] = bsr.ProcessCountPerNode
	}
	if bsr.ID != nil {
		objectMap["id"] = bsr.ID
	}
	if bsr.Name != nil {
		objectMap["name"] = bsr.Name
	}
	if bsr.Description != nil {
		objectMap["description"] = bsr.Description
	}
	if bsr.KvTags != nil {
		objectMap["kvTags"] = bsr.KvTags
	}
	if bsr.Properties != nil {
		objectMap["properties"] = bsr.Properties
	}
	if bsr.OperationID != nil {
		objectMap["operationId"] = bsr.OperationID
	}
	if bsr.State != "" {
		objectMap["state"] = bsr.State
	}
	if bsr.CreatedTime != nil {
		objectMap["createdTime"] = bsr.CreatedTime
	}
	if bsr.UpdatedTime != nil {
		objectMap["updatedTime"] = bsr.UpdatedTime
	}
	if bsr.Error != nil {
		objectMap["error"] = bsr.Error
	}
	if bsr.DeploymentType != "" {
		objectMap["deploymentType"] = bsr.DeploymentType
	}
	if bsr.ComputeType != "" {
		objectMap["computeType"] = bsr.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceResponse is the BasicServiceResponseBase implementation for BatchServiceResponse.
func (bsr BatchServiceResponse) AsACIServiceResponse() (*ACIServiceResponse, bool) {
	return nil, false
}

// AsAKSServiceResponse is the BasicServiceResponseBase implementation for BatchServiceResponse.
func (bsr BatchServiceResponse) AsAKSServiceResponse() (*AKSServiceResponse, bool) {
	return nil, false
}

// AsAKSEndpointResponse is the BasicServiceResponseBase implementation for BatchServiceResponse.
func (bsr BatchServiceResponse) AsAKSEndpointResponse() (*AKSEndpointResponse, bool) {
	return nil, false
}

// AsAKSVariantResponse is the BasicServiceResponseBase implementation for BatchServiceResponse.
func (bsr BatchServiceResponse) AsAKSVariantResponse() (*AKSVariantResponse, bool) {
	return nil, false
}

// AsBasicAKSVariantResponse is the BasicServiceResponseBase implementation for BatchServiceResponse.
func (bsr BatchServiceResponse) AsBasicAKSVariantResponse() (BasicAKSVariantResponse, bool) {
	return nil, false
}

// AsBatchServiceResponse is the BasicServiceResponseBase implementation for BatchServiceResponse.
func (bsr BatchServiceResponse) AsBatchServiceResponse() (*BatchServiceResponse, bool) {
	return &bsr, true
}

// AsIotServiceResponse is the BasicServiceResponseBase implementation for BatchServiceResponse.
func (bsr BatchServiceResponse) AsIotServiceResponse() (*IotServiceResponse, bool) {
	return nil, false
}

// AsUnknownServiceResponse is the BasicServiceResponseBase implementation for BatchServiceResponse.
func (bsr BatchServiceResponse) AsUnknownServiceResponse() (*UnknownServiceResponse, bool) {
	return nil, false
}

// AsServiceResponseBase is the BasicServiceResponseBase implementation for BatchServiceResponse.
func (bsr BatchServiceResponse) AsServiceResponseBase() (*ServiceResponseBase, bool) {
	return nil, false
}

// AsBasicServiceResponseBase is the BasicServiceResponseBase implementation for BatchServiceResponse.
func (bsr BatchServiceResponse) AsBasicServiceResponseBase() (BasicServiceResponseBase, bool) {
	return &bsr, true
}

// ClientCredentials ...
type ClientCredentials struct {
	// ClientID - The Client ID/Application ID
	ClientID *uuid.UUID `json:"clientId,omitempty"`
	// TenantID - The ID of the tenant the service principal/app belongs to
	TenantID *uuid.UUID `json:"tenantId,omitempty"`
	// IsCertAuth - Is it using certificate to authenticate. If false then use client secret
	IsCertAuth *bool `json:"isCertAuth,omitempty"`
	// Certificate - The content of the certificate used for authentication
	Certificate *string `json:"certificate,omitempty"`
	// Thumbprint - The thumbprint of the certificate above
	Thumbprint *string `json:"thumbprint,omitempty"`
	// ClientSecret - The client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// AuthorityURL - The authority URL used for authentication
	AuthorityURL *string `json:"authorityUrl,omitempty"`
	// ResourceURI - The resource the service principal/app has access to
	ResourceURI *string `json:"resourceUri,omitempty"`
	// SubscriptionID - Subscription Id
	SubscriptionID *uuid.UUID `json:"subscriptionId,omitempty"`
	// ResourceGroup - Resource Group Name
	ResourceGroup *string `json:"resourceGroup,omitempty"`
}

// ContainerRegistry ...
type ContainerRegistry struct {
	Address  *string `json:"address,omitempty"`
	Username *string `json:"username,omitempty"`
	Password *string `json:"password,omitempty"`
}

// ContainerResourceRequirements the resource requirements for the container (cpu and memory).
type ContainerResourceRequirements struct {
	// CPU - The number of CPU cores on the container.
	CPU *float64 `json:"cpu,omitempty"`
	// MemoryInGB - The amount of memory on the container in GB.
	MemoryInGB *float64 `json:"memoryInGB,omitempty"`
	// Gpu - The number of GPU cores in the container.
	Gpu *int32 `json:"gpu,omitempty"`
	// Fpga - The number of FPGA PCIE devices exposed to the container. Must be multiple of 2.
	Fpga *int32 `json:"fpga,omitempty"`
}

// CreatedBy ...
type CreatedBy struct {
	// UserObjectID - A user or service principal's object ID.
	// This is PII and should never be logged.
	UserObjectID *string `json:"userObjectId,omitempty"`
	// UserTenantID - A user or service principal's tenant ID.
	UserTenantID *string `json:"userTenantId,omitempty"`
	// UserName - A user's full name or a service principal's app ID.
	// This is PII and should never be logged.
	UserName *string `json:"userName,omitempty"`
}

// CreatedFrom ...
type CreatedFrom struct {
	// Type - Possible values include: 'Notebook'
	Type CreatedFromType `json:"type,omitempty"`
	// LocationType - Possible values include: 'ArtifactID'
	LocationType CreatedFromLocationType `json:"locationType,omitempty"`
	Location     *string                 `json:"location,omitempty"`
}

// CreateEndpointRequest the request to create an Endpoint in the AKS.
type CreateEndpointRequest struct {
	// ComputeName - The name of the compute resource.
	ComputeName *string `json:"computeName,omitempty"`
	// AppInsightsEnabled - Whether or not Application Insights is enabled.
	AppInsightsEnabled *bool `json:"appInsightsEnabled,omitempty"`
	// AuthEnabled - Whether or not authentication is enabled.
	AuthEnabled *bool `json:"authEnabled,omitempty"`
	// AadAuthEnabled - Whether or not AAD authentication is enabled.
	AadAuthEnabled *bool `json:"aadAuthEnabled,omitempty"`
	// Namespace - Kubernetes namespace for the service.
	Namespace *string `json:"namespace,omitempty"`
	// Variants - The service tag list.
	Variants *[]AKSServiceCreateRequest `json:"variants,omitempty"`
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The description of the service.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service properties dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// Keys - The authentication keys.
	Keys *AuthKeys `json:"keys,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ImageID - The Image Id.
	ImageID *string `json:"imageId,omitempty"`
	// EnvironmentImageRequest - The Environment, models and assets needed for inferencing.
	EnvironmentImageRequest *EnvironmentImageRequest `json:"environmentImageRequest,omitempty"`
	// Location - The location of the service.
	Location *string `json:"location,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeBasicCreateServiceRequestComputeTypeCreateServiceRequest', 'ComputeTypeBasicCreateServiceRequestComputeTypeACI', 'ComputeTypeBasicCreateServiceRequestComputeTypeAKS', 'ComputeTypeBasicCreateServiceRequestComputeTypeAKSENDPOINT', 'ComputeTypeBasicCreateServiceRequestComputeTypeCreateEndpointVariantRequest', 'ComputeTypeBasicCreateServiceRequestComputeTypeIOT'
	ComputeType ComputeTypeBasicCreateServiceRequest `json:"computeType,omitempty"`
}

// MarshalJSON is the custom marshaler for CreateEndpointRequest.
func (cer CreateEndpointRequest) MarshalJSON() ([]byte, error) {
	cer.ComputeType = ComputeTypeBasicCreateServiceRequestComputeTypeAKSENDPOINT
	objectMap := make(map[string]interface{})
	if cer.ComputeName != nil {
		objectMap["computeName"] = cer.ComputeName
	}
	if cer.AppInsightsEnabled != nil {
		objectMap["appInsightsEnabled"] = cer.AppInsightsEnabled
	}
	if cer.AuthEnabled != nil {
		objectMap["authEnabled"] = cer.AuthEnabled
	}
	if cer.AadAuthEnabled != nil {
		objectMap["aadAuthEnabled"] = cer.AadAuthEnabled
	}
	if cer.Namespace != nil {
		objectMap["namespace"] = cer.Namespace
	}
	if cer.Variants != nil {
		objectMap["variants"] = cer.Variants
	}
	if cer.Name != nil {
		objectMap["name"] = cer.Name
	}
	if cer.Description != nil {
		objectMap["description"] = cer.Description
	}
	if cer.KvTags != nil {
		objectMap["kvTags"] = cer.KvTags
	}
	if cer.Properties != nil {
		objectMap["properties"] = cer.Properties
	}
	if cer.Keys != nil {
		objectMap["keys"] = cer.Keys
	}
	if cer.DeploymentType != "" {
		objectMap["deploymentType"] = cer.DeploymentType
	}
	if cer.ImageID != nil {
		objectMap["imageId"] = cer.ImageID
	}
	if cer.EnvironmentImageRequest != nil {
		objectMap["environmentImageRequest"] = cer.EnvironmentImageRequest
	}
	if cer.Location != nil {
		objectMap["location"] = cer.Location
	}
	if cer.ComputeType != "" {
		objectMap["computeType"] = cer.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceCreateRequest is the BasicCreateServiceRequest implementation for CreateEndpointRequest.
func (cer CreateEndpointRequest) AsACIServiceCreateRequest() (*ACIServiceCreateRequest, bool) {
	return nil, false
}

// AsAKSServiceCreateRequest is the BasicCreateServiceRequest implementation for CreateEndpointRequest.
func (cer CreateEndpointRequest) AsAKSServiceCreateRequest() (*AKSServiceCreateRequest, bool) {
	return nil, false
}

// AsCreateEndpointRequest is the BasicCreateServiceRequest implementation for CreateEndpointRequest.
func (cer CreateEndpointRequest) AsCreateEndpointRequest() (*CreateEndpointRequest, bool) {
	return &cer, true
}

// AsCreateEndpointVariantRequest is the BasicCreateServiceRequest implementation for CreateEndpointRequest.
func (cer CreateEndpointRequest) AsCreateEndpointVariantRequest() (*CreateEndpointVariantRequest, bool) {
	return nil, false
}

// AsBasicCreateEndpointVariantRequest is the BasicCreateServiceRequest implementation for CreateEndpointRequest.
func (cer CreateEndpointRequest) AsBasicCreateEndpointVariantRequest() (BasicCreateEndpointVariantRequest, bool) {
	return nil, false
}

// AsCreateIotServiceRequest is the BasicCreateServiceRequest implementation for CreateEndpointRequest.
func (cer CreateEndpointRequest) AsCreateIotServiceRequest() (*CreateIotServiceRequest, bool) {
	return nil, false
}

// AsCreateServiceRequest is the BasicCreateServiceRequest implementation for CreateEndpointRequest.
func (cer CreateEndpointRequest) AsCreateServiceRequest() (*CreateServiceRequest, bool) {
	return nil, false
}

// AsBasicCreateServiceRequest is the BasicCreateServiceRequest implementation for CreateEndpointRequest.
func (cer CreateEndpointRequest) AsBasicCreateServiceRequest() (BasicCreateServiceRequest, bool) {
	return &cer, true
}

// BasicCreateEndpointVariantRequest the Variant properties.
type BasicCreateEndpointVariantRequest interface {
	AsAKSServiceCreateRequest() (*AKSServiceCreateRequest, bool)
	AsCreateEndpointVariantRequest() (*CreateEndpointVariantRequest, bool)
}

// CreateEndpointVariantRequest the Variant properties.
type CreateEndpointVariantRequest struct {
	// IsDefault - Is this the default variant.
	IsDefault *bool `json:"isDefault,omitempty"`
	// TrafficPercentile - The amount of traffic variant receives.
	TrafficPercentile *float64 `json:"trafficPercentile,omitempty"`
	// Type - The type of the variant. Possible values include: 'Control', 'Treatment'
	Type VariantType `json:"type,omitempty"`
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The description of the service.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service properties dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// Keys - The authentication keys.
	Keys *AuthKeys `json:"keys,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ImageID - The Image Id.
	ImageID *string `json:"imageId,omitempty"`
	// EnvironmentImageRequest - The Environment, models and assets needed for inferencing.
	EnvironmentImageRequest *EnvironmentImageRequest `json:"environmentImageRequest,omitempty"`
	// Location - The location of the service.
	Location *string `json:"location,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeBasicCreateServiceRequestComputeTypeCreateServiceRequest', 'ComputeTypeBasicCreateServiceRequestComputeTypeACI', 'ComputeTypeBasicCreateServiceRequestComputeTypeAKS', 'ComputeTypeBasicCreateServiceRequestComputeTypeAKSENDPOINT', 'ComputeTypeBasicCreateServiceRequestComputeTypeCreateEndpointVariantRequest', 'ComputeTypeBasicCreateServiceRequestComputeTypeIOT'
	ComputeType ComputeTypeBasicCreateServiceRequest `json:"computeType,omitempty"`
}

func unmarshalBasicCreateEndpointVariantRequest(body []byte) (BasicCreateEndpointVariantRequest, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["computeType"] {
	case string(ComputeTypeBasicCreateServiceRequestComputeTypeAKS):
		var ascr AKSServiceCreateRequest
		err := json.Unmarshal(body, &ascr)
		return ascr, err
	default:
		var cevr CreateEndpointVariantRequest
		err := json.Unmarshal(body, &cevr)
		return cevr, err
	}
}
func unmarshalBasicCreateEndpointVariantRequestArray(body []byte) ([]BasicCreateEndpointVariantRequest, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	cevrArray := make([]BasicCreateEndpointVariantRequest, len(rawMessages))

	for index, rawMessage := range rawMessages {
		cevr, err := unmarshalBasicCreateEndpointVariantRequest(*rawMessage)
		if err != nil {
			return nil, err
		}
		cevrArray[index] = cevr
	}
	return cevrArray, nil
}

// MarshalJSON is the custom marshaler for CreateEndpointVariantRequest.
func (cevr CreateEndpointVariantRequest) MarshalJSON() ([]byte, error) {
	cevr.ComputeType = ComputeTypeBasicCreateServiceRequestComputeTypeCreateEndpointVariantRequest
	objectMap := make(map[string]interface{})
	if cevr.IsDefault != nil {
		objectMap["isDefault"] = cevr.IsDefault
	}
	if cevr.TrafficPercentile != nil {
		objectMap["trafficPercentile"] = cevr.TrafficPercentile
	}
	if cevr.Type != "" {
		objectMap["type"] = cevr.Type
	}
	if cevr.Name != nil {
		objectMap["name"] = cevr.Name
	}
	if cevr.Description != nil {
		objectMap["description"] = cevr.Description
	}
	if cevr.KvTags != nil {
		objectMap["kvTags"] = cevr.KvTags
	}
	if cevr.Properties != nil {
		objectMap["properties"] = cevr.Properties
	}
	if cevr.Keys != nil {
		objectMap["keys"] = cevr.Keys
	}
	if cevr.DeploymentType != "" {
		objectMap["deploymentType"] = cevr.DeploymentType
	}
	if cevr.ImageID != nil {
		objectMap["imageId"] = cevr.ImageID
	}
	if cevr.EnvironmentImageRequest != nil {
		objectMap["environmentImageRequest"] = cevr.EnvironmentImageRequest
	}
	if cevr.Location != nil {
		objectMap["location"] = cevr.Location
	}
	if cevr.ComputeType != "" {
		objectMap["computeType"] = cevr.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceCreateRequest is the BasicCreateServiceRequest implementation for CreateEndpointVariantRequest.
func (cevr CreateEndpointVariantRequest) AsACIServiceCreateRequest() (*ACIServiceCreateRequest, bool) {
	return nil, false
}

// AsAKSServiceCreateRequest is the BasicCreateServiceRequest implementation for CreateEndpointVariantRequest.
func (cevr CreateEndpointVariantRequest) AsAKSServiceCreateRequest() (*AKSServiceCreateRequest, bool) {
	return nil, false
}

// AsCreateEndpointRequest is the BasicCreateServiceRequest implementation for CreateEndpointVariantRequest.
func (cevr CreateEndpointVariantRequest) AsCreateEndpointRequest() (*CreateEndpointRequest, bool) {
	return nil, false
}

// AsCreateEndpointVariantRequest is the BasicCreateServiceRequest implementation for CreateEndpointVariantRequest.
func (cevr CreateEndpointVariantRequest) AsCreateEndpointVariantRequest() (*CreateEndpointVariantRequest, bool) {
	return &cevr, true
}

// AsBasicCreateEndpointVariantRequest is the BasicCreateServiceRequest implementation for CreateEndpointVariantRequest.
func (cevr CreateEndpointVariantRequest) AsBasicCreateEndpointVariantRequest() (BasicCreateEndpointVariantRequest, bool) {
	return &cevr, true
}

// AsCreateIotServiceRequest is the BasicCreateServiceRequest implementation for CreateEndpointVariantRequest.
func (cevr CreateEndpointVariantRequest) AsCreateIotServiceRequest() (*CreateIotServiceRequest, bool) {
	return nil, false
}

// AsCreateServiceRequest is the BasicCreateServiceRequest implementation for CreateEndpointVariantRequest.
func (cevr CreateEndpointVariantRequest) AsCreateServiceRequest() (*CreateServiceRequest, bool) {
	return nil, false
}

// AsBasicCreateServiceRequest is the BasicCreateServiceRequest implementation for CreateEndpointVariantRequest.
func (cevr CreateEndpointVariantRequest) AsBasicCreateServiceRequest() (BasicCreateServiceRequest, bool) {
	return &cevr, true
}

// CreateIotServiceRequest ...
type CreateIotServiceRequest struct {
	IotDeviceID       *string                `json:"iotDeviceId,omitempty"`
	Routes            map[string]*string     `json:"routes"`
	IotEdgeUserModule *[]IotModuleSettings   `json:"iotEdgeUserModule,omitempty"`
	IotEdgeModule     *IotBaseModuleSettings `json:"iotEdgeModule,omitempty"`
	ComputeName       *string                `json:"computeName,omitempty"`
	AcrCredentials    *[]RegistryInfo        `json:"acrCredentials,omitempty"`
	AuthEnabled       *bool                  `json:"authEnabled,omitempty"`
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The description of the service.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service properties dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// Keys - The authentication keys.
	Keys *AuthKeys `json:"keys,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ImageID - The Image Id.
	ImageID *string `json:"imageId,omitempty"`
	// EnvironmentImageRequest - The Environment, models and assets needed for inferencing.
	EnvironmentImageRequest *EnvironmentImageRequest `json:"environmentImageRequest,omitempty"`
	// Location - The location of the service.
	Location *string `json:"location,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeBasicCreateServiceRequestComputeTypeCreateServiceRequest', 'ComputeTypeBasicCreateServiceRequestComputeTypeACI', 'ComputeTypeBasicCreateServiceRequestComputeTypeAKS', 'ComputeTypeBasicCreateServiceRequestComputeTypeAKSENDPOINT', 'ComputeTypeBasicCreateServiceRequestComputeTypeCreateEndpointVariantRequest', 'ComputeTypeBasicCreateServiceRequestComputeTypeIOT'
	ComputeType ComputeTypeBasicCreateServiceRequest `json:"computeType,omitempty"`
}

// MarshalJSON is the custom marshaler for CreateIotServiceRequest.
func (cisr CreateIotServiceRequest) MarshalJSON() ([]byte, error) {
	cisr.ComputeType = ComputeTypeBasicCreateServiceRequestComputeTypeIOT
	objectMap := make(map[string]interface{})
	if cisr.IotDeviceID != nil {
		objectMap["iotDeviceId"] = cisr.IotDeviceID
	}
	if cisr.Routes != nil {
		objectMap["routes"] = cisr.Routes
	}
	if cisr.IotEdgeUserModule != nil {
		objectMap["iotEdgeUserModule"] = cisr.IotEdgeUserModule
	}
	if cisr.IotEdgeModule != nil {
		objectMap["iotEdgeModule"] = cisr.IotEdgeModule
	}
	if cisr.ComputeName != nil {
		objectMap["computeName"] = cisr.ComputeName
	}
	if cisr.AcrCredentials != nil {
		objectMap["acrCredentials"] = cisr.AcrCredentials
	}
	if cisr.AuthEnabled != nil {
		objectMap["authEnabled"] = cisr.AuthEnabled
	}
	if cisr.Name != nil {
		objectMap["name"] = cisr.Name
	}
	if cisr.Description != nil {
		objectMap["description"] = cisr.Description
	}
	if cisr.KvTags != nil {
		objectMap["kvTags"] = cisr.KvTags
	}
	if cisr.Properties != nil {
		objectMap["properties"] = cisr.Properties
	}
	if cisr.Keys != nil {
		objectMap["keys"] = cisr.Keys
	}
	if cisr.DeploymentType != "" {
		objectMap["deploymentType"] = cisr.DeploymentType
	}
	if cisr.ImageID != nil {
		objectMap["imageId"] = cisr.ImageID
	}
	if cisr.EnvironmentImageRequest != nil {
		objectMap["environmentImageRequest"] = cisr.EnvironmentImageRequest
	}
	if cisr.Location != nil {
		objectMap["location"] = cisr.Location
	}
	if cisr.ComputeType != "" {
		objectMap["computeType"] = cisr.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceCreateRequest is the BasicCreateServiceRequest implementation for CreateIotServiceRequest.
func (cisr CreateIotServiceRequest) AsACIServiceCreateRequest() (*ACIServiceCreateRequest, bool) {
	return nil, false
}

// AsAKSServiceCreateRequest is the BasicCreateServiceRequest implementation for CreateIotServiceRequest.
func (cisr CreateIotServiceRequest) AsAKSServiceCreateRequest() (*AKSServiceCreateRequest, bool) {
	return nil, false
}

// AsCreateEndpointRequest is the BasicCreateServiceRequest implementation for CreateIotServiceRequest.
func (cisr CreateIotServiceRequest) AsCreateEndpointRequest() (*CreateEndpointRequest, bool) {
	return nil, false
}

// AsCreateEndpointVariantRequest is the BasicCreateServiceRequest implementation for CreateIotServiceRequest.
func (cisr CreateIotServiceRequest) AsCreateEndpointVariantRequest() (*CreateEndpointVariantRequest, bool) {
	return nil, false
}

// AsBasicCreateEndpointVariantRequest is the BasicCreateServiceRequest implementation for CreateIotServiceRequest.
func (cisr CreateIotServiceRequest) AsBasicCreateEndpointVariantRequest() (BasicCreateEndpointVariantRequest, bool) {
	return nil, false
}

// AsCreateIotServiceRequest is the BasicCreateServiceRequest implementation for CreateIotServiceRequest.
func (cisr CreateIotServiceRequest) AsCreateIotServiceRequest() (*CreateIotServiceRequest, bool) {
	return &cisr, true
}

// AsCreateServiceRequest is the BasicCreateServiceRequest implementation for CreateIotServiceRequest.
func (cisr CreateIotServiceRequest) AsCreateServiceRequest() (*CreateServiceRequest, bool) {
	return nil, false
}

// AsBasicCreateServiceRequest is the BasicCreateServiceRequest implementation for CreateIotServiceRequest.
func (cisr CreateIotServiceRequest) AsBasicCreateServiceRequest() (BasicCreateServiceRequest, bool) {
	return &cisr, true
}

// CreateRun ...
type CreateRun struct {
	// RunID - The identifier for the run. Run IDs must be less than 256 characters and contain only alphanumeric characters with dashes and underscores.
	RunID *string `json:"runId,omitempty"`
	// ParentRunID - The parent of the run if the run is hierarchical; otherwise, Null.
	ParentRunID *string `json:"parentRunId,omitempty"`
	// Status - The status of the run. The Status string value maps to the RunStatus Enum.
	Status *string `json:"status,omitempty"`
	// StartTimeUtc - The start time of the run in UTC.
	StartTimeUtc *date.Time `json:"startTimeUtc,omitempty"`
	// EndTimeUtc - The end time of the run in UTC.
	EndTimeUtc       *date.Time         `json:"endTimeUtc,omitempty"`
	HeartbeatEnabled *bool              `json:"heartbeatEnabled,omitempty"`
	Options          *RunOptions        `json:"options,omitempty"`
	Name             *string            `json:"name,omitempty"`
	DataContainerID  *string            `json:"dataContainerId,omitempty"`
	Description      *string            `json:"description,omitempty"`
	Hidden           *bool              `json:"hidden,omitempty"`
	RunType          *string            `json:"runType,omitempty"`
	Properties       map[string]*string `json:"properties"`
	ScriptName       *string            `json:"scriptName,omitempty"`
	Target           *string            `json:"target,omitempty"`
	Tags             map[string]*string `json:"tags"`
	RunDefinition    interface{}        `json:"runDefinition,omitempty"`
	CreatedFrom      *CreatedFrom       `json:"createdFrom,omitempty"`
	CancelURI        *string            `json:"cancelUri,omitempty"`
	DiagnosticsURI   *string            `json:"diagnosticsUri,omitempty"`
}

// MarshalJSON is the custom marshaler for CreateRun.
func (cr CreateRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cr.RunID != nil {
		objectMap["runId"] = cr.RunID
	}
	if cr.ParentRunID != nil {
		objectMap["parentRunId"] = cr.ParentRunID
	}
	if cr.Status != nil {
		objectMap["status"] = cr.Status
	}
	if cr.StartTimeUtc != nil {
		objectMap["startTimeUtc"] = cr.StartTimeUtc
	}
	if cr.EndTimeUtc != nil {
		objectMap["endTimeUtc"] = cr.EndTimeUtc
	}
	if cr.HeartbeatEnabled != nil {
		objectMap["heartbeatEnabled"] = cr.HeartbeatEnabled
	}
	if cr.Options != nil {
		objectMap["options"] = cr.Options
	}
	if cr.Name != nil {
		objectMap["name"] = cr.Name
	}
	if cr.DataContainerID != nil {
		objectMap["dataContainerId"] = cr.DataContainerID
	}
	if cr.Description != nil {
		objectMap["description"] = cr.Description
	}
	if cr.Hidden != nil {
		objectMap["hidden"] = cr.Hidden
	}
	if cr.RunType != nil {
		objectMap["runType"] = cr.RunType
	}
	if cr.Properties != nil {
		objectMap["properties"] = cr.Properties
	}
	if cr.ScriptName != nil {
		objectMap["scriptName"] = cr.ScriptName
	}
	if cr.Target != nil {
		objectMap["target"] = cr.Target
	}
	if cr.Tags != nil {
		objectMap["tags"] = cr.Tags
	}
	if cr.RunDefinition != nil {
		objectMap["runDefinition"] = cr.RunDefinition
	}
	if cr.CreatedFrom != nil {
		objectMap["createdFrom"] = cr.CreatedFrom
	}
	if cr.CancelURI != nil {
		objectMap["cancelUri"] = cr.CancelURI
	}
	if cr.DiagnosticsURI != nil {
		objectMap["diagnosticsUri"] = cr.DiagnosticsURI
	}
	return json.Marshal(objectMap)
}

// BasicCreateServiceRequest the base class for creating a service.
type BasicCreateServiceRequest interface {
	AsACIServiceCreateRequest() (*ACIServiceCreateRequest, bool)
	AsAKSServiceCreateRequest() (*AKSServiceCreateRequest, bool)
	AsCreateEndpointRequest() (*CreateEndpointRequest, bool)
	AsCreateEndpointVariantRequest() (*CreateEndpointVariantRequest, bool)
	AsBasicCreateEndpointVariantRequest() (BasicCreateEndpointVariantRequest, bool)
	AsCreateIotServiceRequest() (*CreateIotServiceRequest, bool)
	AsCreateServiceRequest() (*CreateServiceRequest, bool)
}

// CreateServiceRequest the base class for creating a service.
type CreateServiceRequest struct {
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The description of the service.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service properties dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// Keys - The authentication keys.
	Keys *AuthKeys `json:"keys,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ImageID - The Image Id.
	ImageID *string `json:"imageId,omitempty"`
	// EnvironmentImageRequest - The Environment, models and assets needed for inferencing.
	EnvironmentImageRequest *EnvironmentImageRequest `json:"environmentImageRequest,omitempty"`
	// Location - The location of the service.
	Location *string `json:"location,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeBasicCreateServiceRequestComputeTypeCreateServiceRequest', 'ComputeTypeBasicCreateServiceRequestComputeTypeACI', 'ComputeTypeBasicCreateServiceRequestComputeTypeAKS', 'ComputeTypeBasicCreateServiceRequestComputeTypeAKSENDPOINT', 'ComputeTypeBasicCreateServiceRequestComputeTypeCreateEndpointVariantRequest', 'ComputeTypeBasicCreateServiceRequestComputeTypeIOT'
	ComputeType ComputeTypeBasicCreateServiceRequest `json:"computeType,omitempty"`
}

func unmarshalBasicCreateServiceRequest(body []byte) (BasicCreateServiceRequest, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["computeType"] {
	case string(ComputeTypeBasicCreateServiceRequestComputeTypeACI):
		var ascr ACIServiceCreateRequest
		err := json.Unmarshal(body, &ascr)
		return ascr, err
	case string(ComputeTypeBasicCreateServiceRequestComputeTypeAKS):
		var ascr AKSServiceCreateRequest
		err := json.Unmarshal(body, &ascr)
		return ascr, err
	case string(ComputeTypeBasicCreateServiceRequestComputeTypeAKSENDPOINT):
		var cer CreateEndpointRequest
		err := json.Unmarshal(body, &cer)
		return cer, err
	case string(ComputeTypeBasicCreateServiceRequestComputeTypeCreateEndpointVariantRequest):
		var cevr CreateEndpointVariantRequest
		err := json.Unmarshal(body, &cevr)
		return cevr, err
	case string(ComputeTypeBasicCreateServiceRequestComputeTypeIOT):
		var cisr CreateIotServiceRequest
		err := json.Unmarshal(body, &cisr)
		return cisr, err
	default:
		var csr CreateServiceRequest
		err := json.Unmarshal(body, &csr)
		return csr, err
	}
}
func unmarshalBasicCreateServiceRequestArray(body []byte) ([]BasicCreateServiceRequest, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	csrArray := make([]BasicCreateServiceRequest, len(rawMessages))

	for index, rawMessage := range rawMessages {
		csr, err := unmarshalBasicCreateServiceRequest(*rawMessage)
		if err != nil {
			return nil, err
		}
		csrArray[index] = csr
	}
	return csrArray, nil
}

// MarshalJSON is the custom marshaler for CreateServiceRequest.
func (csr CreateServiceRequest) MarshalJSON() ([]byte, error) {
	csr.ComputeType = ComputeTypeBasicCreateServiceRequestComputeTypeCreateServiceRequest
	objectMap := make(map[string]interface{})
	if csr.Name != nil {
		objectMap["name"] = csr.Name
	}
	if csr.Description != nil {
		objectMap["description"] = csr.Description
	}
	if csr.KvTags != nil {
		objectMap["kvTags"] = csr.KvTags
	}
	if csr.Properties != nil {
		objectMap["properties"] = csr.Properties
	}
	if csr.Keys != nil {
		objectMap["keys"] = csr.Keys
	}
	if csr.DeploymentType != "" {
		objectMap["deploymentType"] = csr.DeploymentType
	}
	if csr.ImageID != nil {
		objectMap["imageId"] = csr.ImageID
	}
	if csr.EnvironmentImageRequest != nil {
		objectMap["environmentImageRequest"] = csr.EnvironmentImageRequest
	}
	if csr.Location != nil {
		objectMap["location"] = csr.Location
	}
	if csr.ComputeType != "" {
		objectMap["computeType"] = csr.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceCreateRequest is the BasicCreateServiceRequest implementation for CreateServiceRequest.
func (csr CreateServiceRequest) AsACIServiceCreateRequest() (*ACIServiceCreateRequest, bool) {
	return nil, false
}

// AsAKSServiceCreateRequest is the BasicCreateServiceRequest implementation for CreateServiceRequest.
func (csr CreateServiceRequest) AsAKSServiceCreateRequest() (*AKSServiceCreateRequest, bool) {
	return nil, false
}

// AsCreateEndpointRequest is the BasicCreateServiceRequest implementation for CreateServiceRequest.
func (csr CreateServiceRequest) AsCreateEndpointRequest() (*CreateEndpointRequest, bool) {
	return nil, false
}

// AsCreateEndpointVariantRequest is the BasicCreateServiceRequest implementation for CreateServiceRequest.
func (csr CreateServiceRequest) AsCreateEndpointVariantRequest() (*CreateEndpointVariantRequest, bool) {
	return nil, false
}

// AsBasicCreateEndpointVariantRequest is the BasicCreateServiceRequest implementation for CreateServiceRequest.
func (csr CreateServiceRequest) AsBasicCreateEndpointVariantRequest() (BasicCreateEndpointVariantRequest, bool) {
	return nil, false
}

// AsCreateIotServiceRequest is the BasicCreateServiceRequest implementation for CreateServiceRequest.
func (csr CreateServiceRequest) AsCreateIotServiceRequest() (*CreateIotServiceRequest, bool) {
	return nil, false
}

// AsCreateServiceRequest is the BasicCreateServiceRequest implementation for CreateServiceRequest.
func (csr CreateServiceRequest) AsCreateServiceRequest() (*CreateServiceRequest, bool) {
	return &csr, true
}

// AsBasicCreateServiceRequest is the BasicCreateServiceRequest implementation for CreateServiceRequest.
func (csr CreateServiceRequest) AsBasicCreateServiceRequest() (BasicCreateServiceRequest, bool) {
	return &csr, true
}

// DataPath ...
type DataPath struct {
	DataStoreName *string      `json:"dataStoreName,omitempty"`
	RelativePath  *string      `json:"relativePath,omitempty"`
	SQLDataPath   *SQLDataPath `json:"sqlDataPath,omitempty"`
}

// DataReferenceConfiguration a class for managing DataReferenceConfiguration.
type DataReferenceConfiguration struct {
	// DataStoreName - The name of the data store.
	DataStoreName *string `json:"dataStoreName,omitempty"`
	// Mode - Operation on the datastore, mount, download, upload. Possible values include: 'Mount', 'Download', 'Upload'
	Mode DataStoreMode `json:"mode,omitempty"`
	// PathOnDataStore - Relative path on the datastore.
	PathOnDataStore *string `json:"pathOnDataStore,omitempty"`
	// PathOnCompute - The path on the compute target.
	PathOnCompute *string `json:"pathOnCompute,omitempty"`
	// Overwrite - Whether to overwrite the data if existing.
	Overwrite *bool `json:"overwrite,omitempty"`
}

// DatasetReference the dataset reference object.
type DatasetReference struct {
	// Name - The name of the dataset reference.
	Name *string `json:"name,omitempty"`
	// ID - The id of the dataset reference.
	ID *string `json:"id,omitempty"`
}

// DataStore ...
type DataStore struct {
	autorest.Response `json:"-"`
	// Name - Name of the datastore
	Name *string `json:"name,omitempty"`
	// DataStoreType - The Azure storage service this datastore points to. Possible values include: 'DataStoreTypeAzureBlob', 'DataStoreTypeAzureFile', 'DataStoreTypeAzureDataLake', 'DataStoreTypeAzureSQLDatabase', 'DataStoreTypeAzurePostgreSQL', 'DataStoreTypeDBFS', 'DataStoreTypeAzureDataLakeGen2', 'DataStoreTypeGlusterFs'
	DataStoreType DataStoreType `json:"dataStoreType,omitempty"`
	// HasBeenValidated - A read only property that denotes whether the service datastore has been validated with credentials.
	HasBeenValidated *bool `json:"hasBeenValidated,omitempty"`
	// Tags - Tags to datastore
	Tags map[string]*string `json:"tags"`
	// AzureStorageSection - Data specific to azure storage
	AzureStorageSection *AzureStorage `json:"azureStorageSection,omitempty"`
	// AzureDataLakeSection - Data Specific to azure data lake
	AzureDataLakeSection *AzureDataLake `json:"azureDataLakeSection,omitempty"`
	// AzureSQLDatabaseSection - Data specific to azure SQL database
	AzureSQLDatabaseSection *AzureSQLDatabase `json:"azureSqlDatabaseSection,omitempty"`
	// AzurePostgreSQLSection - Data specific to azure PostgreSQL
	AzurePostgreSQLSection *AzurePostgreSQL `json:"azurePostgreSqlSection,omitempty"`
	// GlusterFsSection - Data specific to GlusterFS
	GlusterFsSection *GlusterFs `json:"glusterFsSection,omitempty"`
}

// MarshalJSON is the custom marshaler for DataStore.
func (ds DataStore) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ds.Name != nil {
		objectMap["name"] = ds.Name
	}
	if ds.DataStoreType != "" {
		objectMap["dataStoreType"] = ds.DataStoreType
	}
	if ds.HasBeenValidated != nil {
		objectMap["hasBeenValidated"] = ds.HasBeenValidated
	}
	if ds.Tags != nil {
		objectMap["tags"] = ds.Tags
	}
	if ds.AzureStorageSection != nil {
		objectMap["azureStorageSection"] = ds.AzureStorageSection
	}
	if ds.AzureDataLakeSection != nil {
		objectMap["azureDataLakeSection"] = ds.AzureDataLakeSection
	}
	if ds.AzureSQLDatabaseSection != nil {
		objectMap["azureSqlDatabaseSection"] = ds.AzureSQLDatabaseSection
	}
	if ds.AzurePostgreSQLSection != nil {
		objectMap["azurePostgreSqlSection"] = ds.AzurePostgreSQLSection
	}
	if ds.GlusterFsSection != nil {
		objectMap["glusterFsSection"] = ds.GlusterFsSection
	}
	return json.Marshal(objectMap)
}

// DeleteTagsCommand ...
type DeleteTagsCommand struct {
	Tags *[]string `json:"tags,omitempty"`
}

// DeploymentSummary the deployment summary.
type DeploymentSummary struct {
	// SuccessfulDeployments - The number of successful deployments.
	SuccessfulDeployments *int32 `json:"successfulDeployments,omitempty"`
	// UnsuccessfulDeployments - The number of unsuccessful deployments.
	UnsuccessfulDeployments *int32 `json:"unsuccessfulDeployments,omitempty"`
}

// DockerImageResponse ...
type DockerImageResponse struct {
	// DriverProgram - The name of the driver file.
	DriverProgram *string `json:"driverProgram,omitempty"`
	// Assets - The list of assets.
	Assets *[]EnvironmentImageAsset `json:"assets,omitempty"`
	// TargetRuntime - The target runtime.
	TargetRuntime *TargetRuntime `json:"targetRuntime,omitempty"`
	// DockerFileURI - The Uri to the docker file.
	DockerFileURI *string `json:"dockerFileUri,omitempty"`
	// GeneratedDockerFileURI - The Uri to the generated docker file.
	GeneratedDockerFileURI *string `json:"generatedDockerFileUri,omitempty"`
	// ID - The image Id.
	ID *string `json:"id,omitempty"`
	// Name - The image name.
	Name *string `json:"name,omitempty"`
	// Version - The image version.
	Version *int64 `json:"version,omitempty"`
	// Description - The image description.
	Description *string `json:"description,omitempty"`
	// KvTags - The image tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The image properties dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// CreatedTime - The time the image was created.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// ModifiedTime - The time the image was last modified.
	ModifiedTime *date.Time `json:"modifiedTime,omitempty"`
	// AutoDelete - Whether the image will be automatically deleted with the last service using it.
	AutoDelete *bool `json:"autoDelete,omitempty"`
	// ImageType - The type of the image. Possible values include: 'Docker'
	ImageType ImageType `json:"imageType,omitempty"`
	// CreationState - The state of the operation. Possible values include: 'NotStarted', 'Running', 'Cancelled', 'Succeeded', 'Failed', 'TimedOut'
	CreationState AsyncOperationState `json:"creationState,omitempty"`
	// Error - The error response.
	Error *ModelErrorResponse `json:"error,omitempty"`
	// ModelIds - The list of model Ids.
	ModelIds *[]string `json:"modelIds,omitempty"`
	// ModelDetails - The list of models.
	ModelDetails *[]Model `json:"modelDetails,omitempty"`
	// ImageLocation - The Image location string.
	ImageLocation *string `json:"imageLocation,omitempty"`
	// ImageBuildLogURI - The Uri to the image build logs.
	ImageBuildLogURI *string `json:"imageBuildLogUri,omitempty"`
	// OperationID - The ID of the asynchronous operation for this image.
	OperationID *string `json:"operationId,omitempty"`
	// ImageFlavor - Possible values include: 'ImageFlavorImageResponseBase', 'ImageFlavorWEBAPICONTAINER', 'ImageFlavorACCELCONTAINER'
	ImageFlavor ImageFlavor `json:"imageFlavor,omitempty"`
}

// MarshalJSON is the custom marshaler for DockerImageResponse.
func (dir DockerImageResponse) MarshalJSON() ([]byte, error) {
	dir.ImageFlavor = ImageFlavorWEBAPICONTAINER
	objectMap := make(map[string]interface{})
	if dir.DriverProgram != nil {
		objectMap["driverProgram"] = dir.DriverProgram
	}
	if dir.Assets != nil {
		objectMap["assets"] = dir.Assets
	}
	if dir.TargetRuntime != nil {
		objectMap["targetRuntime"] = dir.TargetRuntime
	}
	if dir.DockerFileURI != nil {
		objectMap["dockerFileUri"] = dir.DockerFileURI
	}
	if dir.GeneratedDockerFileURI != nil {
		objectMap["generatedDockerFileUri"] = dir.GeneratedDockerFileURI
	}
	if dir.ID != nil {
		objectMap["id"] = dir.ID
	}
	if dir.Name != nil {
		objectMap["name"] = dir.Name
	}
	if dir.Version != nil {
		objectMap["version"] = dir.Version
	}
	if dir.Description != nil {
		objectMap["description"] = dir.Description
	}
	if dir.KvTags != nil {
		objectMap["kvTags"] = dir.KvTags
	}
	if dir.Properties != nil {
		objectMap["properties"] = dir.Properties
	}
	if dir.CreatedTime != nil {
		objectMap["createdTime"] = dir.CreatedTime
	}
	if dir.ModifiedTime != nil {
		objectMap["modifiedTime"] = dir.ModifiedTime
	}
	if dir.AutoDelete != nil {
		objectMap["autoDelete"] = dir.AutoDelete
	}
	if dir.ImageType != "" {
		objectMap["imageType"] = dir.ImageType
	}
	if dir.CreationState != "" {
		objectMap["creationState"] = dir.CreationState
	}
	if dir.Error != nil {
		objectMap["error"] = dir.Error
	}
	if dir.ModelIds != nil {
		objectMap["modelIds"] = dir.ModelIds
	}
	if dir.ModelDetails != nil {
		objectMap["modelDetails"] = dir.ModelDetails
	}
	if dir.ImageLocation != nil {
		objectMap["imageLocation"] = dir.ImageLocation
	}
	if dir.ImageBuildLogURI != nil {
		objectMap["imageBuildLogUri"] = dir.ImageBuildLogURI
	}
	if dir.OperationID != nil {
		objectMap["operationId"] = dir.OperationID
	}
	if dir.ImageFlavor != "" {
		objectMap["imageFlavor"] = dir.ImageFlavor
	}
	return json.Marshal(objectMap)
}

// AsDockerImageResponse is the BasicImageResponseBase implementation for DockerImageResponse.
func (dir DockerImageResponse) AsDockerImageResponse() (*DockerImageResponse, bool) {
	return &dir, true
}

// AsFPGADockerImageResponse is the BasicImageResponseBase implementation for DockerImageResponse.
func (dir DockerImageResponse) AsFPGADockerImageResponse() (*FPGADockerImageResponse, bool) {
	return nil, false
}

// AsImageResponseBase is the BasicImageResponseBase implementation for DockerImageResponse.
func (dir DockerImageResponse) AsImageResponseBase() (*ImageResponseBase, bool) {
	return nil, false
}

// AsBasicImageResponseBase is the BasicImageResponseBase implementation for DockerImageResponse.
func (dir DockerImageResponse) AsBasicImageResponseBase() (BasicImageResponseBase, bool) {
	return &dir, true
}

// DockerSection ...
type DockerSection struct {
	// BaseImage - Base image used for Docker-based runs. Mutually exclusive with BaseDockerfile.
	BaseImage *string `json:"baseImage,omitempty"`
	// BaseDockerfile - Base Dockerfile used for Docker-based runs. Mutually exclusive with BaseImage.
	BaseDockerfile *string `json:"baseDockerfile,omitempty"`
	// Enabled - Set true to perform this run inside a Docker container.
	Enabled *bool `json:"enabled,omitempty"`
	// SharedVolumes - Set false to disable AzureML's usage of the Docker shared volumes feature to work around bugs in certain versions of Docker for Windows.
	SharedVolumes *bool `json:"sharedVolumes,omitempty"`
	// Arguments - Extra arguments to the Docker run command.
	Arguments *[]string `json:"arguments,omitempty"`
	// BaseImageRegistry - Image registry that contains the base image.
	BaseImageRegistry *ContainerRegistry `json:"baseImageRegistry,omitempty"`
}

// EnvironmentDefinition ...
type EnvironmentDefinition struct {
	// Name - The name of the environment.
	Name *string `json:"name,omitempty"`
	// Version - The environment version.
	Version *string `json:"version,omitempty"`
	// Python - Settings for a Python environment.
	Python *PythonSection `json:"python,omitempty"`
	// EnvironmentVariables - Definition of environment variables to be defined in the environment.
	EnvironmentVariables map[string]*string `json:"environmentVariables"`
	// Docker - The definition of a Docker container.
	Docker *DockerSection `json:"docker,omitempty"`
	// Spark - The configuration for a Spark environment.
	Spark *SparkSection `json:"spark,omitempty"`
	// InferencingStackVersion - The inferencing stack version added to the image. To avoid adding an inferencing stack, do not set this value. Valid values: "latest".
	InferencingStackVersion *string `json:"inferencingStackVersion,omitempty"`
}

// MarshalJSON is the custom marshaler for EnvironmentDefinition.
func (ed EnvironmentDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ed.Name != nil {
		objectMap["name"] = ed.Name
	}
	if ed.Version != nil {
		objectMap["version"] = ed.Version
	}
	if ed.Python != nil {
		objectMap["python"] = ed.Python
	}
	if ed.EnvironmentVariables != nil {
		objectMap["environmentVariables"] = ed.EnvironmentVariables
	}
	if ed.Docker != nil {
		objectMap["docker"] = ed.Docker
	}
	if ed.Spark != nil {
		objectMap["spark"] = ed.Spark
	}
	if ed.InferencingStackVersion != nil {
		objectMap["inferencingStackVersion"] = ed.InferencingStackVersion
	}
	return json.Marshal(objectMap)
}

// EnvironmentImageAsset an Image asset.
type EnvironmentImageAsset struct {
	// ID - The Asset Id.
	ID *string `json:"id,omitempty"`
	// MimeType - The mime type.
	MimeType *string `json:"mimeType,omitempty"`
	// URL - The Url of the Asset.
	URL *string `json:"url,omitempty"`
	// Unpack - Whether the Asset is unpacked.
	Unpack *bool `json:"unpack,omitempty"`
}

// EnvironmentImageRequest request to create a Docker image based on Environment.
type EnvironmentImageRequest struct {
	// DriverProgram - The name of the driver file.
	DriverProgram *string `json:"driverProgram,omitempty"`
	// Assets - The list of assets.
	Assets *[]EnvironmentImageAsset `json:"assets,omitempty"`
	// ModelIds - The list of model Ids.
	ModelIds *[]string `json:"modelIds,omitempty"`
	// Environment - The details of the AZURE ML environment.
	Environment *ModelEnvironmentDefinition `json:"environment,omitempty"`
}

// ErrorDetails the error details.
type ErrorDetails struct {
	// Code - The error code.
	Code *string `json:"code,omitempty"`
	// Message - The error message.
	Message *string `json:"message,omitempty"`
	// Target - The target of the error (e.g., the name of the property in error).
	Target *string `json:"target,omitempty"`
}

// ErrorResponse the error response.
type ErrorResponse struct {
	// Error - The top level error that occurred.
	Error *RootError `json:"error,omitempty"`
	// Correlation - Dictionary containing correlation details for the error.
	Correlation map[string]*string `json:"correlation"`
	// Environment - The hosting environment.
	Environment *string `json:"environment,omitempty"`
	// Location - The Azure region.
	Location *string `json:"location,omitempty"`
	// Time - The time in UTC.
	Time *date.Time `json:"time,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorResponse.
func (er ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if er.Error != nil {
		objectMap["error"] = er.Error
	}
	if er.Correlation != nil {
		objectMap["correlation"] = er.Correlation
	}
	if er.Environment != nil {
		objectMap["environment"] = er.Environment
	}
	if er.Location != nil {
		objectMap["location"] = er.Location
	}
	if er.Time != nil {
		objectMap["time"] = er.Time
	}
	return json.Marshal(objectMap)
}

// Experiment ...
type Experiment struct {
	autorest.Response          `json:"-"`
	ExperimentID               *string            `json:"experimentId,omitempty"`
	Name                       *string            `json:"name,omitempty"`
	Description                *string            `json:"description,omitempty"`
	CreatedUtc                 *date.Time         `json:"createdUtc,omitempty"`
	Tags                       map[string]*string `json:"tags"`
	ArchivedTime               *date.Time         `json:"archivedTime,omitempty"`
	LatestCreatedRunCreatedUtc *date.Time         `json:"latestCreatedRunCreatedUtc,omitempty"`
	LatestCreatedRunID         *string            `json:"latestCreatedRunId,omitempty"`
}

// MarshalJSON is the custom marshaler for Experiment.
func (e Experiment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if e.ExperimentID != nil {
		objectMap["experimentId"] = e.ExperimentID
	}
	if e.Name != nil {
		objectMap["name"] = e.Name
	}
	if e.Description != nil {
		objectMap["description"] = e.Description
	}
	if e.CreatedUtc != nil {
		objectMap["createdUtc"] = e.CreatedUtc
	}
	if e.Tags != nil {
		objectMap["tags"] = e.Tags
	}
	if e.ArchivedTime != nil {
		objectMap["archivedTime"] = e.ArchivedTime
	}
	if e.LatestCreatedRunCreatedUtc != nil {
		objectMap["latestCreatedRunCreatedUtc"] = e.LatestCreatedRunCreatedUtc
	}
	if e.LatestCreatedRunID != nil {
		objectMap["latestCreatedRunId"] = e.LatestCreatedRunID
	}
	return json.Marshal(objectMap)
}

// FPGADockerImageResponse the FPGA Docker Image response.
type FPGADockerImageResponse struct {
	// ID - The image Id.
	ID *string `json:"id,omitempty"`
	// Name - The image name.
	Name *string `json:"name,omitempty"`
	// Version - The image version.
	Version *int64 `json:"version,omitempty"`
	// Description - The image description.
	Description *string `json:"description,omitempty"`
	// KvTags - The image tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The image properties dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// CreatedTime - The time the image was created.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// ModifiedTime - The time the image was last modified.
	ModifiedTime *date.Time `json:"modifiedTime,omitempty"`
	// AutoDelete - Whether the image will be automatically deleted with the last service using it.
	AutoDelete *bool `json:"autoDelete,omitempty"`
	// ImageType - The type of the image. Possible values include: 'Docker'
	ImageType ImageType `json:"imageType,omitempty"`
	// CreationState - The state of the operation. Possible values include: 'NotStarted', 'Running', 'Cancelled', 'Succeeded', 'Failed', 'TimedOut'
	CreationState AsyncOperationState `json:"creationState,omitempty"`
	// Error - The error response.
	Error *ModelErrorResponse `json:"error,omitempty"`
	// ModelIds - The list of model Ids.
	ModelIds *[]string `json:"modelIds,omitempty"`
	// ModelDetails - The list of models.
	ModelDetails *[]Model `json:"modelDetails,omitempty"`
	// ImageLocation - The Image location string.
	ImageLocation *string `json:"imageLocation,omitempty"`
	// ImageBuildLogURI - The Uri to the image build logs.
	ImageBuildLogURI *string `json:"imageBuildLogUri,omitempty"`
	// OperationID - The ID of the asynchronous operation for this image.
	OperationID *string `json:"operationId,omitempty"`
	// ImageFlavor - Possible values include: 'ImageFlavorImageResponseBase', 'ImageFlavorWEBAPICONTAINER', 'ImageFlavorACCELCONTAINER'
	ImageFlavor ImageFlavor `json:"imageFlavor,omitempty"`
}

// MarshalJSON is the custom marshaler for FPGADockerImageResponse.
func (fdir FPGADockerImageResponse) MarshalJSON() ([]byte, error) {
	fdir.ImageFlavor = ImageFlavorACCELCONTAINER
	objectMap := make(map[string]interface{})
	if fdir.ID != nil {
		objectMap["id"] = fdir.ID
	}
	if fdir.Name != nil {
		objectMap["name"] = fdir.Name
	}
	if fdir.Version != nil {
		objectMap["version"] = fdir.Version
	}
	if fdir.Description != nil {
		objectMap["description"] = fdir.Description
	}
	if fdir.KvTags != nil {
		objectMap["kvTags"] = fdir.KvTags
	}
	if fdir.Properties != nil {
		objectMap["properties"] = fdir.Properties
	}
	if fdir.CreatedTime != nil {
		objectMap["createdTime"] = fdir.CreatedTime
	}
	if fdir.ModifiedTime != nil {
		objectMap["modifiedTime"] = fdir.ModifiedTime
	}
	if fdir.AutoDelete != nil {
		objectMap["autoDelete"] = fdir.AutoDelete
	}
	if fdir.ImageType != "" {
		objectMap["imageType"] = fdir.ImageType
	}
	if fdir.CreationState != "" {
		objectMap["creationState"] = fdir.CreationState
	}
	if fdir.Error != nil {
		objectMap["error"] = fdir.Error
	}
	if fdir.ModelIds != nil {
		objectMap["modelIds"] = fdir.ModelIds
	}
	if fdir.ModelDetails != nil {
		objectMap["modelDetails"] = fdir.ModelDetails
	}
	if fdir.ImageLocation != nil {
		objectMap["imageLocation"] = fdir.ImageLocation
	}
	if fdir.ImageBuildLogURI != nil {
		objectMap["imageBuildLogUri"] = fdir.ImageBuildLogURI
	}
	if fdir.OperationID != nil {
		objectMap["operationId"] = fdir.OperationID
	}
	if fdir.ImageFlavor != "" {
		objectMap["imageFlavor"] = fdir.ImageFlavor
	}
	return json.Marshal(objectMap)
}

// AsDockerImageResponse is the BasicImageResponseBase implementation for FPGADockerImageResponse.
func (fdir FPGADockerImageResponse) AsDockerImageResponse() (*DockerImageResponse, bool) {
	return nil, false
}

// AsFPGADockerImageResponse is the BasicImageResponseBase implementation for FPGADockerImageResponse.
func (fdir FPGADockerImageResponse) AsFPGADockerImageResponse() (*FPGADockerImageResponse, bool) {
	return &fdir, true
}

// AsImageResponseBase is the BasicImageResponseBase implementation for FPGADockerImageResponse.
func (fdir FPGADockerImageResponse) AsImageResponseBase() (*ImageResponseBase, bool) {
	return nil, false
}

// AsBasicImageResponseBase is the BasicImageResponseBase implementation for FPGADockerImageResponse.
func (fdir FPGADockerImageResponse) AsBasicImageResponseBase() (BasicImageResponseBase, bool) {
	return &fdir, true
}

// GlusterFs ...
type GlusterFs struct {
	// ServerAddress - The server address of one of the servers that hosts the GlusterFS. Can be either the IP address
	// or server name.
	ServerAddress *string `json:"serverAddress,omitempty"`
	// VolumeName - The name of the created GlusterFS volume.
	VolumeName *string `json:"volumeName,omitempty"`
}

// HdiConfiguration ...
type HdiConfiguration struct {
	// YarnDeployMode - Possible values include: 'YarnDeployModeNone', 'YarnDeployModeClient', 'YarnDeployModeCluster'
	YarnDeployMode YarnDeployMode `json:"yarnDeployMode,omitempty"`
}

// HistoryConfiguration ...
type HistoryConfiguration struct {
	// OutputCollection - Set to true to collect outputs and store in run history.
	OutputCollection *bool `json:"outputCollection,omitempty"`
	// DirectoriesToWatch - The list of directories to monitor and upload files from.
	DirectoriesToWatch *[]string `json:"directoriesToWatch,omitempty"`
}

// HyperDriveBanditPolicy bandit Policy configuration. Please refer
// https://docs.microsoft.com/en-us/python/api/azureml-train-core/azureml.train.hyperdrive.banditpolicy?view=azure-ml-py
// for more information.
type HyperDriveBanditPolicy struct {
	// Properties - Policy configuration properties.
	Properties *HyperDriveBanditPolicyProperties `json:"properties,omitempty"`
	// Name - Possible values include: 'NameHyperDrivePolicyConfigBase', 'NameDefault', 'NameBandit', 'NameMedianStopping', 'NameTruncationSelection'
	Name NameBasicHyperDrivePolicyConfigBase `json:"name,omitempty"`
}

// MarshalJSON is the custom marshaler for HyperDriveBanditPolicy.
func (hdbp HyperDriveBanditPolicy) MarshalJSON() ([]byte, error) {
	hdbp.Name = NameBandit
	objectMap := make(map[string]interface{})
	if hdbp.Properties != nil {
		objectMap["properties"] = hdbp.Properties
	}
	if hdbp.Name != "" {
		objectMap["name"] = hdbp.Name
	}
	return json.Marshal(objectMap)
}

// AsHyperDriveDefaultPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveBanditPolicy.
func (hdbp HyperDriveBanditPolicy) AsHyperDriveDefaultPolicy() (*HyperDriveDefaultPolicy, bool) {
	return nil, false
}

// AsHyperDriveBanditPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveBanditPolicy.
func (hdbp HyperDriveBanditPolicy) AsHyperDriveBanditPolicy() (*HyperDriveBanditPolicy, bool) {
	return &hdbp, true
}

// AsHyperDriveMedianStoppingPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveBanditPolicy.
func (hdbp HyperDriveBanditPolicy) AsHyperDriveMedianStoppingPolicy() (*HyperDriveMedianStoppingPolicy, bool) {
	return nil, false
}

// AsHyperDriveTruncationSelectionPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveBanditPolicy.
func (hdbp HyperDriveBanditPolicy) AsHyperDriveTruncationSelectionPolicy() (*HyperDriveTruncationSelectionPolicy, bool) {
	return nil, false
}

// AsHyperDrivePolicyConfigBase is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveBanditPolicy.
func (hdbp HyperDriveBanditPolicy) AsHyperDrivePolicyConfigBase() (*HyperDrivePolicyConfigBase, bool) {
	return nil, false
}

// AsBasicHyperDrivePolicyConfigBase is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveBanditPolicy.
func (hdbp HyperDriveBanditPolicy) AsBasicHyperDrivePolicyConfigBase() (BasicHyperDrivePolicyConfigBase, bool) {
	return &hdbp, true
}

// HyperDriveBanditPolicyProperties policy configuration properties.
type HyperDriveBanditPolicyProperties struct {
	// EvaluationInterval - Evaluation interval of the policy.
	EvaluationInterval *int32 `json:"evaluation_interval,omitempty"`
	// DelayEvaluation - Value indicating the number of sequences for which the first evaluation is delayed.
	DelayEvaluation *int32 `json:"delay_evaluation,omitempty"`
	// SlackFactor - Slack factor.
	SlackFactor *float64 `json:"slack_factor,omitempty"`
	// SlackAmount - Slack amount.
	SlackAmount *float64 `json:"slack_amount,omitempty"`
}

// HyperDriveCancelExperimentResponse response for HyperDrive_CancelExperiment in case of success.
type HyperDriveCancelExperimentResponse struct {
	autorest.Response `json:"-"`
	// Code - Response code.
	Code *int32 `json:"code,omitempty"`
	// Result - Message indicating operation success.
	Result *string `json:"result,omitempty"`
}

// HyperDriveCreateExperiment part of request for HyperDrive_CreateExperiment. Contains configuration
// details required to create hyperdrive run.
type HyperDriveCreateExperiment struct {
	// User - User who is creating the Hyperdrive run.
	User *string `json:"user,omitempty"`
	// Description - The description for Hyperdrive run.
	Description *string `json:"description,omitempty"`
	// GeneratorConfig - Hyperparameter space and the sampling method configuration.
	GeneratorConfig *HyperDriveExperimentBaseGeneratorConfig `json:"generator_config,omitempty"`
	// MaxConcurrentJobs - Maximum number of runs to run concurrently.
	MaxConcurrentJobs *int32 `json:"max_concurrent_jobs,omitempty"`
	// MaxDurationMinutes - Maximum duration of the Hyperdrive run.
	MaxDurationMinutes *int32 `json:"max_duration_minutes,omitempty"`
	// MaxTotalJobs - Maximum number of runs.
	MaxTotalJobs *int32 `json:"max_total_jobs,omitempty"`
	// Name - Name of the Hyperdrive run.
	Name *string `json:"name,omitempty"`
	// Platform - Platform of the Hyperdrive run.
	Platform *string `json:"platform,omitempty"`
	// PlatformConfig - Platform config object specifying the run definition structure.
	PlatformConfig interface{} `json:"platform_config,omitempty"`
	// PolicyConfig - Early termination policy configuration.
	PolicyConfig BasicHyperDrivePolicyConfigBase `json:"policy_config,omitempty"`
	// PrimaryMetricConfig - Name of the primary metric and goal of optimizing.
	PrimaryMetricConfig *HyperDriveExperimentBasePrimaryMetricConfig `json:"primary_metric_config,omitempty"`
	// StudyID - Study Id of the Hyperdrive run.
	StudyID *int32 `json:"study_id,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for HyperDriveCreateExperiment struct.
func (hdce *HyperDriveCreateExperiment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "user":
			if v != nil {
				var userVar string
				err = json.Unmarshal(*v, &userVar)
				if err != nil {
					return err
				}
				hdce.User = &userVar
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				hdce.Description = &description
			}
		case "generator_config":
			if v != nil {
				var generatorConfig HyperDriveExperimentBaseGeneratorConfig
				err = json.Unmarshal(*v, &generatorConfig)
				if err != nil {
					return err
				}
				hdce.GeneratorConfig = &generatorConfig
			}
		case "max_concurrent_jobs":
			if v != nil {
				var maxConcurrentJobs int32
				err = json.Unmarshal(*v, &maxConcurrentJobs)
				if err != nil {
					return err
				}
				hdce.MaxConcurrentJobs = &maxConcurrentJobs
			}
		case "max_duration_minutes":
			if v != nil {
				var maxDurationMinutes int32
				err = json.Unmarshal(*v, &maxDurationMinutes)
				if err != nil {
					return err
				}
				hdce.MaxDurationMinutes = &maxDurationMinutes
			}
		case "max_total_jobs":
			if v != nil {
				var maxTotalJobs int32
				err = json.Unmarshal(*v, &maxTotalJobs)
				if err != nil {
					return err
				}
				hdce.MaxTotalJobs = &maxTotalJobs
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				hdce.Name = &name
			}
		case "platform":
			if v != nil {
				var platform string
				err = json.Unmarshal(*v, &platform)
				if err != nil {
					return err
				}
				hdce.Platform = &platform
			}
		case "platform_config":
			if v != nil {
				var platformConfig interface{}
				err = json.Unmarshal(*v, &platformConfig)
				if err != nil {
					return err
				}
				hdce.PlatformConfig = platformConfig
			}
		case "policy_config":
			if v != nil {
				policyConfig, err := unmarshalBasicHyperDrivePolicyConfigBase(*v)
				if err != nil {
					return err
				}
				hdce.PolicyConfig = policyConfig
			}
		case "primary_metric_config":
			if v != nil {
				var primaryMetricConfig HyperDriveExperimentBasePrimaryMetricConfig
				err = json.Unmarshal(*v, &primaryMetricConfig)
				if err != nil {
					return err
				}
				hdce.PrimaryMetricConfig = &primaryMetricConfig
			}
		case "study_id":
			if v != nil {
				var studyID int32
				err = json.Unmarshal(*v, &studyID)
				if err != nil {
					return err
				}
				hdce.StudyID = &studyID
			}
		}
	}

	return nil
}

// HyperDriveDefaultPolicy no early termination is applied in the case of DefaultPolicy
type HyperDriveDefaultPolicy struct {
	// Name - Possible values include: 'NameHyperDrivePolicyConfigBase', 'NameDefault', 'NameBandit', 'NameMedianStopping', 'NameTruncationSelection'
	Name NameBasicHyperDrivePolicyConfigBase `json:"name,omitempty"`
}

// MarshalJSON is the custom marshaler for HyperDriveDefaultPolicy.
func (hddp HyperDriveDefaultPolicy) MarshalJSON() ([]byte, error) {
	hddp.Name = NameDefault
	objectMap := make(map[string]interface{})
	if hddp.Name != "" {
		objectMap["name"] = hddp.Name
	}
	return json.Marshal(objectMap)
}

// AsHyperDriveDefaultPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveDefaultPolicy.
func (hddp HyperDriveDefaultPolicy) AsHyperDriveDefaultPolicy() (*HyperDriveDefaultPolicy, bool) {
	return &hddp, true
}

// AsHyperDriveBanditPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveDefaultPolicy.
func (hddp HyperDriveDefaultPolicy) AsHyperDriveBanditPolicy() (*HyperDriveBanditPolicy, bool) {
	return nil, false
}

// AsHyperDriveMedianStoppingPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveDefaultPolicy.
func (hddp HyperDriveDefaultPolicy) AsHyperDriveMedianStoppingPolicy() (*HyperDriveMedianStoppingPolicy, bool) {
	return nil, false
}

// AsHyperDriveTruncationSelectionPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveDefaultPolicy.
func (hddp HyperDriveDefaultPolicy) AsHyperDriveTruncationSelectionPolicy() (*HyperDriveTruncationSelectionPolicy, bool) {
	return nil, false
}

// AsHyperDrivePolicyConfigBase is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveDefaultPolicy.
func (hddp HyperDriveDefaultPolicy) AsHyperDrivePolicyConfigBase() (*HyperDrivePolicyConfigBase, bool) {
	return nil, false
}

// AsBasicHyperDrivePolicyConfigBase is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveDefaultPolicy.
func (hddp HyperDriveDefaultPolicy) AsBasicHyperDrivePolicyConfigBase() (BasicHyperDrivePolicyConfigBase, bool) {
	return &hddp, true
}

// HyperDriveErrorResponse response in case of an error.
type HyperDriveErrorResponse struct {
	// Code - Error response code.
	Code *int32 `json:"code,omitempty"`
	// Message - Error message.
	Message *string `json:"message,omitempty"`
}

// HyperDriveExperiment part of response for HyperDrive_CreateExperiment in case of success. Contains
// details about the created hyperdrive run.
type HyperDriveExperiment struct {
	// AllJobsGenerated - Indicates if all runs have been generated.
	AllJobsGenerated *bool `json:"all_jobs_generated,omitempty"`
	// CancellationRequested - Indicates if cancellation has been requested for this Hyperdrive run.
	CancellationRequested *bool `json:"cancellation_requested,omitempty"`
	// Created - Hyperdrive run creation time.
	Created *date.Time `json:"created,omitempty"`
	// CreatedByUserID - Id of the user who created the Hyperdrive run.
	CreatedByUserID *int32 `json:"created_by_user_id,omitempty"`
	// ExperimentID - Hyperdrive run id.
	ExperimentID *string `json:"experiment_id,omitempty"`
	// ExperimentURI - Hyperdrive run Uri.
	ExperimentURI *string `json:"experiment_uri,omitempty"`
	// Modified - Hyperdrive run modification time.
	Modified *date.Time `json:"modified,omitempty"`
	// Status - Hyperdrive run status.
	Status *string `json:"status,omitempty"`
	// StudyURI - Study Uri of the Hyperdrive run.
	StudyURI *string `json:"study_uri,omitempty"`
	// HyperdriveRunID - Hyperdrive run id.
	HyperdriveRunID *string `json:"hyperdrive_run_id,omitempty"`
	// Description - The description for Hyperdrive run.
	Description *string `json:"description,omitempty"`
	// GeneratorConfig - Hyperparameter space and the sampling method configuration.
	GeneratorConfig *HyperDriveExperimentBaseGeneratorConfig `json:"generator_config,omitempty"`
	// MaxConcurrentJobs - Maximum number of runs to run concurrently.
	MaxConcurrentJobs *int32 `json:"max_concurrent_jobs,omitempty"`
	// MaxDurationMinutes - Maximum duration of the Hyperdrive run.
	MaxDurationMinutes *int32 `json:"max_duration_minutes,omitempty"`
	// MaxTotalJobs - Maximum number of runs.
	MaxTotalJobs *int32 `json:"max_total_jobs,omitempty"`
	// Name - Name of the Hyperdrive run.
	Name *string `json:"name,omitempty"`
	// Platform - Platform of the Hyperdrive run.
	Platform *string `json:"platform,omitempty"`
	// PlatformConfig - Platform config object specifying the run definition structure.
	PlatformConfig interface{} `json:"platform_config,omitempty"`
	// PolicyConfig - Early termination policy configuration.
	PolicyConfig BasicHyperDrivePolicyConfigBase `json:"policy_config,omitempty"`
	// PrimaryMetricConfig - Name of the primary metric and goal of optimizing.
	PrimaryMetricConfig *HyperDriveExperimentBasePrimaryMetricConfig `json:"primary_metric_config,omitempty"`
	// StudyID - Study Id of the Hyperdrive run.
	StudyID *int32 `json:"study_id,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for HyperDriveExperiment struct.
func (hde *HyperDriveExperiment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "all_jobs_generated":
			if v != nil {
				var allJobsGenerated bool
				err = json.Unmarshal(*v, &allJobsGenerated)
				if err != nil {
					return err
				}
				hde.AllJobsGenerated = &allJobsGenerated
			}
		case "cancellation_requested":
			if v != nil {
				var cancellationRequested bool
				err = json.Unmarshal(*v, &cancellationRequested)
				if err != nil {
					return err
				}
				hde.CancellationRequested = &cancellationRequested
			}
		case "created":
			if v != nil {
				var created date.Time
				err = json.Unmarshal(*v, &created)
				if err != nil {
					return err
				}
				hde.Created = &created
			}
		case "created_by_user_id":
			if v != nil {
				var createdByUserID int32
				err = json.Unmarshal(*v, &createdByUserID)
				if err != nil {
					return err
				}
				hde.CreatedByUserID = &createdByUserID
			}
		case "experiment_id":
			if v != nil {
				var experimentID string
				err = json.Unmarshal(*v, &experimentID)
				if err != nil {
					return err
				}
				hde.ExperimentID = &experimentID
			}
		case "experiment_uri":
			if v != nil {
				var experimentURI string
				err = json.Unmarshal(*v, &experimentURI)
				if err != nil {
					return err
				}
				hde.ExperimentURI = &experimentURI
			}
		case "modified":
			if v != nil {
				var modified date.Time
				err = json.Unmarshal(*v, &modified)
				if err != nil {
					return err
				}
				hde.Modified = &modified
			}
		case "status":
			if v != nil {
				var status string
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				hde.Status = &status
			}
		case "study_uri":
			if v != nil {
				var studyURI string
				err = json.Unmarshal(*v, &studyURI)
				if err != nil {
					return err
				}
				hde.StudyURI = &studyURI
			}
		case "hyperdrive_run_id":
			if v != nil {
				var hyperdriveRunID string
				err = json.Unmarshal(*v, &hyperdriveRunID)
				if err != nil {
					return err
				}
				hde.HyperdriveRunID = &hyperdriveRunID
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				hde.Description = &description
			}
		case "generator_config":
			if v != nil {
				var generatorConfig HyperDriveExperimentBaseGeneratorConfig
				err = json.Unmarshal(*v, &generatorConfig)
				if err != nil {
					return err
				}
				hde.GeneratorConfig = &generatorConfig
			}
		case "max_concurrent_jobs":
			if v != nil {
				var maxConcurrentJobs int32
				err = json.Unmarshal(*v, &maxConcurrentJobs)
				if err != nil {
					return err
				}
				hde.MaxConcurrentJobs = &maxConcurrentJobs
			}
		case "max_duration_minutes":
			if v != nil {
				var maxDurationMinutes int32
				err = json.Unmarshal(*v, &maxDurationMinutes)
				if err != nil {
					return err
				}
				hde.MaxDurationMinutes = &maxDurationMinutes
			}
		case "max_total_jobs":
			if v != nil {
				var maxTotalJobs int32
				err = json.Unmarshal(*v, &maxTotalJobs)
				if err != nil {
					return err
				}
				hde.MaxTotalJobs = &maxTotalJobs
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				hde.Name = &name
			}
		case "platform":
			if v != nil {
				var platform string
				err = json.Unmarshal(*v, &platform)
				if err != nil {
					return err
				}
				hde.Platform = &platform
			}
		case "platform_config":
			if v != nil {
				var platformConfig interface{}
				err = json.Unmarshal(*v, &platformConfig)
				if err != nil {
					return err
				}
				hde.PlatformConfig = platformConfig
			}
		case "policy_config":
			if v != nil {
				policyConfig, err := unmarshalBasicHyperDrivePolicyConfigBase(*v)
				if err != nil {
					return err
				}
				hde.PolicyConfig = policyConfig
			}
		case "primary_metric_config":
			if v != nil {
				var primaryMetricConfig HyperDriveExperimentBasePrimaryMetricConfig
				err = json.Unmarshal(*v, &primaryMetricConfig)
				if err != nil {
					return err
				}
				hde.PrimaryMetricConfig = &primaryMetricConfig
			}
		case "study_id":
			if v != nil {
				var studyID int32
				err = json.Unmarshal(*v, &studyID)
				if err != nil {
					return err
				}
				hde.StudyID = &studyID
			}
		}
	}

	return nil
}

// HyperDriveExperimentBase base object for both request and response of HyperDrive_CreateExperiment api.
type HyperDriveExperimentBase struct {
	// Description - The description for Hyperdrive run.
	Description *string `json:"description,omitempty"`
	// GeneratorConfig - Hyperparameter space and the sampling method configuration.
	GeneratorConfig *HyperDriveExperimentBaseGeneratorConfig `json:"generator_config,omitempty"`
	// MaxConcurrentJobs - Maximum number of runs to run concurrently.
	MaxConcurrentJobs *int32 `json:"max_concurrent_jobs,omitempty"`
	// MaxDurationMinutes - Maximum duration of the Hyperdrive run.
	MaxDurationMinutes *int32 `json:"max_duration_minutes,omitempty"`
	// MaxTotalJobs - Maximum number of runs.
	MaxTotalJobs *int32 `json:"max_total_jobs,omitempty"`
	// Name - Name of the Hyperdrive run.
	Name *string `json:"name,omitempty"`
	// Platform - Platform of the Hyperdrive run.
	Platform *string `json:"platform,omitempty"`
	// PlatformConfig - Platform config object specifying the run definition structure.
	PlatformConfig interface{} `json:"platform_config,omitempty"`
	// PolicyConfig - Early termination policy configuration.
	PolicyConfig BasicHyperDrivePolicyConfigBase `json:"policy_config,omitempty"`
	// PrimaryMetricConfig - Name of the primary metric and goal of optimizing.
	PrimaryMetricConfig *HyperDriveExperimentBasePrimaryMetricConfig `json:"primary_metric_config,omitempty"`
	// StudyID - Study Id of the Hyperdrive run.
	StudyID *int32 `json:"study_id,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for HyperDriveExperimentBase struct.
func (hdeb *HyperDriveExperimentBase) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				hdeb.Description = &description
			}
		case "generator_config":
			if v != nil {
				var generatorConfig HyperDriveExperimentBaseGeneratorConfig
				err = json.Unmarshal(*v, &generatorConfig)
				if err != nil {
					return err
				}
				hdeb.GeneratorConfig = &generatorConfig
			}
		case "max_concurrent_jobs":
			if v != nil {
				var maxConcurrentJobs int32
				err = json.Unmarshal(*v, &maxConcurrentJobs)
				if err != nil {
					return err
				}
				hdeb.MaxConcurrentJobs = &maxConcurrentJobs
			}
		case "max_duration_minutes":
			if v != nil {
				var maxDurationMinutes int32
				err = json.Unmarshal(*v, &maxDurationMinutes)
				if err != nil {
					return err
				}
				hdeb.MaxDurationMinutes = &maxDurationMinutes
			}
		case "max_total_jobs":
			if v != nil {
				var maxTotalJobs int32
				err = json.Unmarshal(*v, &maxTotalJobs)
				if err != nil {
					return err
				}
				hdeb.MaxTotalJobs = &maxTotalJobs
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				hdeb.Name = &name
			}
		case "platform":
			if v != nil {
				var platform string
				err = json.Unmarshal(*v, &platform)
				if err != nil {
					return err
				}
				hdeb.Platform = &platform
			}
		case "platform_config":
			if v != nil {
				var platformConfig interface{}
				err = json.Unmarshal(*v, &platformConfig)
				if err != nil {
					return err
				}
				hdeb.PlatformConfig = platformConfig
			}
		case "policy_config":
			if v != nil {
				policyConfig, err := unmarshalBasicHyperDrivePolicyConfigBase(*v)
				if err != nil {
					return err
				}
				hdeb.PolicyConfig = policyConfig
			}
		case "primary_metric_config":
			if v != nil {
				var primaryMetricConfig HyperDriveExperimentBasePrimaryMetricConfig
				err = json.Unmarshal(*v, &primaryMetricConfig)
				if err != nil {
					return err
				}
				hdeb.PrimaryMetricConfig = &primaryMetricConfig
			}
		case "study_id":
			if v != nil {
				var studyID int32
				err = json.Unmarshal(*v, &studyID)
				if err != nil {
					return err
				}
				hdeb.StudyID = &studyID
			}
		}
	}

	return nil
}

// HyperDriveExperimentBaseGeneratorConfig hyperparameter space and the sampling method configuration.
type HyperDriveExperimentBaseGeneratorConfig struct {
	// Name - Hyperparameter sampling method. Possible values include: 'RANDOM', 'GRID', 'BAYESIANOPTIMIZATION'
	Name Name `json:"name,omitempty"`
	// ParameterSpace - Dictionary specifying hyperparameter space.
	ParameterSpace map[string][]interface{} `json:"parameter_space"`
}

// MarshalJSON is the custom marshaler for HyperDriveExperimentBaseGeneratorConfig.
func (hdeb HyperDriveExperimentBaseGeneratorConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hdeb.Name != "" {
		objectMap["name"] = hdeb.Name
	}
	if hdeb.ParameterSpace != nil {
		objectMap["parameter_space"] = hdeb.ParameterSpace
	}
	return json.Marshal(objectMap)
}

// HyperDriveExperimentBasePrimaryMetricConfig name of the primary metric and goal of optimizing.
type HyperDriveExperimentBasePrimaryMetricConfig struct {
	// Goal - Determines if the primary metric has to be minimized/maximized. Possible values include: 'MAXIMIZE', 'MINIMIZE'
	Goal Goal `json:"goal,omitempty"`
	// Name - Name of the primary metric reported by runs.
	Name *string `json:"name,omitempty"`
}

// HyperDriveExperimentResponse response for HyperDrive_CreateExperiment in case of success.
type HyperDriveExperimentResponse struct {
	autorest.Response `json:"-"`
	// Code - Response code.
	Code *int32 `json:"code,omitempty"`
	// Result - Details about created Hyperdrive run.
	Result *HyperDriveExperiment `json:"result,omitempty"`
}

// HyperDriveMedianStoppingPolicy median stopping policy configuration. Please refer
// https://docs.microsoft.com/en-us/python/api/azureml-train-core/azureml.train.hyperdrive.medianstoppingpolicy?view=azure-ml-py
// for more information.
type HyperDriveMedianStoppingPolicy struct {
	// Properties - Policy configuration properties.
	Properties *HyperDriveMedianStoppingPolicyProperties `json:"properties,omitempty"`
	// Name - Possible values include: 'NameHyperDrivePolicyConfigBase', 'NameDefault', 'NameBandit', 'NameMedianStopping', 'NameTruncationSelection'
	Name NameBasicHyperDrivePolicyConfigBase `json:"name,omitempty"`
}

// MarshalJSON is the custom marshaler for HyperDriveMedianStoppingPolicy.
func (hdmsp HyperDriveMedianStoppingPolicy) MarshalJSON() ([]byte, error) {
	hdmsp.Name = NameMedianStopping
	objectMap := make(map[string]interface{})
	if hdmsp.Properties != nil {
		objectMap["properties"] = hdmsp.Properties
	}
	if hdmsp.Name != "" {
		objectMap["name"] = hdmsp.Name
	}
	return json.Marshal(objectMap)
}

// AsHyperDriveDefaultPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveMedianStoppingPolicy.
func (hdmsp HyperDriveMedianStoppingPolicy) AsHyperDriveDefaultPolicy() (*HyperDriveDefaultPolicy, bool) {
	return nil, false
}

// AsHyperDriveBanditPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveMedianStoppingPolicy.
func (hdmsp HyperDriveMedianStoppingPolicy) AsHyperDriveBanditPolicy() (*HyperDriveBanditPolicy, bool) {
	return nil, false
}

// AsHyperDriveMedianStoppingPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveMedianStoppingPolicy.
func (hdmsp HyperDriveMedianStoppingPolicy) AsHyperDriveMedianStoppingPolicy() (*HyperDriveMedianStoppingPolicy, bool) {
	return &hdmsp, true
}

// AsHyperDriveTruncationSelectionPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveMedianStoppingPolicy.
func (hdmsp HyperDriveMedianStoppingPolicy) AsHyperDriveTruncationSelectionPolicy() (*HyperDriveTruncationSelectionPolicy, bool) {
	return nil, false
}

// AsHyperDrivePolicyConfigBase is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveMedianStoppingPolicy.
func (hdmsp HyperDriveMedianStoppingPolicy) AsHyperDrivePolicyConfigBase() (*HyperDrivePolicyConfigBase, bool) {
	return nil, false
}

// AsBasicHyperDrivePolicyConfigBase is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveMedianStoppingPolicy.
func (hdmsp HyperDriveMedianStoppingPolicy) AsBasicHyperDrivePolicyConfigBase() (BasicHyperDrivePolicyConfigBase, bool) {
	return &hdmsp, true
}

// HyperDriveMedianStoppingPolicyProperties policy configuration properties.
type HyperDriveMedianStoppingPolicyProperties struct {
	// EvaluationInterval - Evaluation interval of the policy.
	EvaluationInterval *int32 `json:"evaluation_interval,omitempty"`
	// DelayEvaluation - Value indicating the number of sequences for which the first evaluation is delayed.
	DelayEvaluation *int32 `json:"delay_evaluation,omitempty"`
}

// BasicHyperDrivePolicyConfigBase early termination policy configuration.
type BasicHyperDrivePolicyConfigBase interface {
	AsHyperDriveDefaultPolicy() (*HyperDriveDefaultPolicy, bool)
	AsHyperDriveBanditPolicy() (*HyperDriveBanditPolicy, bool)
	AsHyperDriveMedianStoppingPolicy() (*HyperDriveMedianStoppingPolicy, bool)
	AsHyperDriveTruncationSelectionPolicy() (*HyperDriveTruncationSelectionPolicy, bool)
	AsHyperDrivePolicyConfigBase() (*HyperDrivePolicyConfigBase, bool)
}

// HyperDrivePolicyConfigBase early termination policy configuration.
type HyperDrivePolicyConfigBase struct {
	// Name - Possible values include: 'NameHyperDrivePolicyConfigBase', 'NameDefault', 'NameBandit', 'NameMedianStopping', 'NameTruncationSelection'
	Name NameBasicHyperDrivePolicyConfigBase `json:"name,omitempty"`
}

func unmarshalBasicHyperDrivePolicyConfigBase(body []byte) (BasicHyperDrivePolicyConfigBase, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["name"] {
	case string(NameDefault):
		var hddp HyperDriveDefaultPolicy
		err := json.Unmarshal(body, &hddp)
		return hddp, err
	case string(NameBandit):
		var hdbp HyperDriveBanditPolicy
		err := json.Unmarshal(body, &hdbp)
		return hdbp, err
	case string(NameMedianStopping):
		var hdmsp HyperDriveMedianStoppingPolicy
		err := json.Unmarshal(body, &hdmsp)
		return hdmsp, err
	case string(NameTruncationSelection):
		var hdtsp HyperDriveTruncationSelectionPolicy
		err := json.Unmarshal(body, &hdtsp)
		return hdtsp, err
	default:
		var hdpcb HyperDrivePolicyConfigBase
		err := json.Unmarshal(body, &hdpcb)
		return hdpcb, err
	}
}
func unmarshalBasicHyperDrivePolicyConfigBaseArray(body []byte) ([]BasicHyperDrivePolicyConfigBase, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	hdpcbArray := make([]BasicHyperDrivePolicyConfigBase, len(rawMessages))

	for index, rawMessage := range rawMessages {
		hdpcb, err := unmarshalBasicHyperDrivePolicyConfigBase(*rawMessage)
		if err != nil {
			return nil, err
		}
		hdpcbArray[index] = hdpcb
	}
	return hdpcbArray, nil
}

// MarshalJSON is the custom marshaler for HyperDrivePolicyConfigBase.
func (hdpcb HyperDrivePolicyConfigBase) MarshalJSON() ([]byte, error) {
	hdpcb.Name = NameHyperDrivePolicyConfigBase
	objectMap := make(map[string]interface{})
	if hdpcb.Name != "" {
		objectMap["name"] = hdpcb.Name
	}
	return json.Marshal(objectMap)
}

// AsHyperDriveDefaultPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDrivePolicyConfigBase.
func (hdpcb HyperDrivePolicyConfigBase) AsHyperDriveDefaultPolicy() (*HyperDriveDefaultPolicy, bool) {
	return nil, false
}

// AsHyperDriveBanditPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDrivePolicyConfigBase.
func (hdpcb HyperDrivePolicyConfigBase) AsHyperDriveBanditPolicy() (*HyperDriveBanditPolicy, bool) {
	return nil, false
}

// AsHyperDriveMedianStoppingPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDrivePolicyConfigBase.
func (hdpcb HyperDrivePolicyConfigBase) AsHyperDriveMedianStoppingPolicy() (*HyperDriveMedianStoppingPolicy, bool) {
	return nil, false
}

// AsHyperDriveTruncationSelectionPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDrivePolicyConfigBase.
func (hdpcb HyperDrivePolicyConfigBase) AsHyperDriveTruncationSelectionPolicy() (*HyperDriveTruncationSelectionPolicy, bool) {
	return nil, false
}

// AsHyperDrivePolicyConfigBase is the BasicHyperDrivePolicyConfigBase implementation for HyperDrivePolicyConfigBase.
func (hdpcb HyperDrivePolicyConfigBase) AsHyperDrivePolicyConfigBase() (*HyperDrivePolicyConfigBase, bool) {
	return &hdpcb, true
}

// AsBasicHyperDrivePolicyConfigBase is the BasicHyperDrivePolicyConfigBase implementation for HyperDrivePolicyConfigBase.
func (hdpcb HyperDrivePolicyConfigBase) AsBasicHyperDrivePolicyConfigBase() (BasicHyperDrivePolicyConfigBase, bool) {
	return &hdpcb, true
}

// HyperDriveTruncationSelectionPolicy truncation selection policy configuration. Please refer
// https://docs.microsoft.com/en-us/python/api/azureml-train-core/azureml.train.hyperdrive.truncationselectionpolicy?view=azure-ml-py
// for more information.
type HyperDriveTruncationSelectionPolicy struct {
	// Properties - Policy configuration properties.
	Properties *HyperDriveTruncationSelectionPolicyProperties `json:"properties,omitempty"`
	// Name - Possible values include: 'NameHyperDrivePolicyConfigBase', 'NameDefault', 'NameBandit', 'NameMedianStopping', 'NameTruncationSelection'
	Name NameBasicHyperDrivePolicyConfigBase `json:"name,omitempty"`
}

// MarshalJSON is the custom marshaler for HyperDriveTruncationSelectionPolicy.
func (hdtsp HyperDriveTruncationSelectionPolicy) MarshalJSON() ([]byte, error) {
	hdtsp.Name = NameTruncationSelection
	objectMap := make(map[string]interface{})
	if hdtsp.Properties != nil {
		objectMap["properties"] = hdtsp.Properties
	}
	if hdtsp.Name != "" {
		objectMap["name"] = hdtsp.Name
	}
	return json.Marshal(objectMap)
}

// AsHyperDriveDefaultPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveTruncationSelectionPolicy.
func (hdtsp HyperDriveTruncationSelectionPolicy) AsHyperDriveDefaultPolicy() (*HyperDriveDefaultPolicy, bool) {
	return nil, false
}

// AsHyperDriveBanditPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveTruncationSelectionPolicy.
func (hdtsp HyperDriveTruncationSelectionPolicy) AsHyperDriveBanditPolicy() (*HyperDriveBanditPolicy, bool) {
	return nil, false
}

// AsHyperDriveMedianStoppingPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveTruncationSelectionPolicy.
func (hdtsp HyperDriveTruncationSelectionPolicy) AsHyperDriveMedianStoppingPolicy() (*HyperDriveMedianStoppingPolicy, bool) {
	return nil, false
}

// AsHyperDriveTruncationSelectionPolicy is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveTruncationSelectionPolicy.
func (hdtsp HyperDriveTruncationSelectionPolicy) AsHyperDriveTruncationSelectionPolicy() (*HyperDriveTruncationSelectionPolicy, bool) {
	return &hdtsp, true
}

// AsHyperDrivePolicyConfigBase is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveTruncationSelectionPolicy.
func (hdtsp HyperDriveTruncationSelectionPolicy) AsHyperDrivePolicyConfigBase() (*HyperDrivePolicyConfigBase, bool) {
	return nil, false
}

// AsBasicHyperDrivePolicyConfigBase is the BasicHyperDrivePolicyConfigBase implementation for HyperDriveTruncationSelectionPolicy.
func (hdtsp HyperDriveTruncationSelectionPolicy) AsBasicHyperDrivePolicyConfigBase() (BasicHyperDrivePolicyConfigBase, bool) {
	return &hdtsp, true
}

// HyperDriveTruncationSelectionPolicyProperties policy configuration properties.
type HyperDriveTruncationSelectionPolicyProperties struct {
	// EvaluationInterval - Evaluation interval of the policy.
	EvaluationInterval *int32 `json:"evaluation_interval,omitempty"`
	// DelayEvaluation - Value indicating the number of sequences for which the first evaluation is delayed.
	DelayEvaluation *int32 `json:"delay_evaluation,omitempty"`
	// TruncationPercentage - Truncation percentage value.
	TruncationPercentage *int32 `json:"truncation_percentage,omitempty"`
	// ExcludeFinishedJobs - Boolean indicating if metrics from finished jobs should be excluded in the policy decision process.
	ExcludeFinishedJobs *bool `json:"exclude_finished_jobs,omitempty"`
}

// BasicImageResponseBase ...
type BasicImageResponseBase interface {
	AsDockerImageResponse() (*DockerImageResponse, bool)
	AsFPGADockerImageResponse() (*FPGADockerImageResponse, bool)
	AsImageResponseBase() (*ImageResponseBase, bool)
}

// ImageResponseBase ...
type ImageResponseBase struct {
	// ID - The image Id.
	ID *string `json:"id,omitempty"`
	// Name - The image name.
	Name *string `json:"name,omitempty"`
	// Version - The image version.
	Version *int64 `json:"version,omitempty"`
	// Description - The image description.
	Description *string `json:"description,omitempty"`
	// KvTags - The image tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The image properties dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// CreatedTime - The time the image was created.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// ModifiedTime - The time the image was last modified.
	ModifiedTime *date.Time `json:"modifiedTime,omitempty"`
	// AutoDelete - Whether the image will be automatically deleted with the last service using it.
	AutoDelete *bool `json:"autoDelete,omitempty"`
	// ImageType - The type of the image. Possible values include: 'Docker'
	ImageType ImageType `json:"imageType,omitempty"`
	// CreationState - The state of the operation. Possible values include: 'NotStarted', 'Running', 'Cancelled', 'Succeeded', 'Failed', 'TimedOut'
	CreationState AsyncOperationState `json:"creationState,omitempty"`
	// Error - The error response.
	Error *ModelErrorResponse `json:"error,omitempty"`
	// ModelIds - The list of model Ids.
	ModelIds *[]string `json:"modelIds,omitempty"`
	// ModelDetails - The list of models.
	ModelDetails *[]Model `json:"modelDetails,omitempty"`
	// ImageLocation - The Image location string.
	ImageLocation *string `json:"imageLocation,omitempty"`
	// ImageBuildLogURI - The Uri to the image build logs.
	ImageBuildLogURI *string `json:"imageBuildLogUri,omitempty"`
	// OperationID - The ID of the asynchronous operation for this image.
	OperationID *string `json:"operationId,omitempty"`
	// ImageFlavor - Possible values include: 'ImageFlavorImageResponseBase', 'ImageFlavorWEBAPICONTAINER', 'ImageFlavorACCELCONTAINER'
	ImageFlavor ImageFlavor `json:"imageFlavor,omitempty"`
}

func unmarshalBasicImageResponseBase(body []byte) (BasicImageResponseBase, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["imageFlavor"] {
	case string(ImageFlavorWEBAPICONTAINER):
		var dir DockerImageResponse
		err := json.Unmarshal(body, &dir)
		return dir, err
	case string(ImageFlavorACCELCONTAINER):
		var fdir FPGADockerImageResponse
		err := json.Unmarshal(body, &fdir)
		return fdir, err
	default:
		var irb ImageResponseBase
		err := json.Unmarshal(body, &irb)
		return irb, err
	}
}
func unmarshalBasicImageResponseBaseArray(body []byte) ([]BasicImageResponseBase, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	irbArray := make([]BasicImageResponseBase, len(rawMessages))

	for index, rawMessage := range rawMessages {
		irb, err := unmarshalBasicImageResponseBase(*rawMessage)
		if err != nil {
			return nil, err
		}
		irbArray[index] = irb
	}
	return irbArray, nil
}

// MarshalJSON is the custom marshaler for ImageResponseBase.
func (irb ImageResponseBase) MarshalJSON() ([]byte, error) {
	irb.ImageFlavor = ImageFlavorImageResponseBase
	objectMap := make(map[string]interface{})
	if irb.ID != nil {
		objectMap["id"] = irb.ID
	}
	if irb.Name != nil {
		objectMap["name"] = irb.Name
	}
	if irb.Version != nil {
		objectMap["version"] = irb.Version
	}
	if irb.Description != nil {
		objectMap["description"] = irb.Description
	}
	if irb.KvTags != nil {
		objectMap["kvTags"] = irb.KvTags
	}
	if irb.Properties != nil {
		objectMap["properties"] = irb.Properties
	}
	if irb.CreatedTime != nil {
		objectMap["createdTime"] = irb.CreatedTime
	}
	if irb.ModifiedTime != nil {
		objectMap["modifiedTime"] = irb.ModifiedTime
	}
	if irb.AutoDelete != nil {
		objectMap["autoDelete"] = irb.AutoDelete
	}
	if irb.ImageType != "" {
		objectMap["imageType"] = irb.ImageType
	}
	if irb.CreationState != "" {
		objectMap["creationState"] = irb.CreationState
	}
	if irb.Error != nil {
		objectMap["error"] = irb.Error
	}
	if irb.ModelIds != nil {
		objectMap["modelIds"] = irb.ModelIds
	}
	if irb.ModelDetails != nil {
		objectMap["modelDetails"] = irb.ModelDetails
	}
	if irb.ImageLocation != nil {
		objectMap["imageLocation"] = irb.ImageLocation
	}
	if irb.ImageBuildLogURI != nil {
		objectMap["imageBuildLogUri"] = irb.ImageBuildLogURI
	}
	if irb.OperationID != nil {
		objectMap["operationId"] = irb.OperationID
	}
	if irb.ImageFlavor != "" {
		objectMap["imageFlavor"] = irb.ImageFlavor
	}
	return json.Marshal(objectMap)
}

// AsDockerImageResponse is the BasicImageResponseBase implementation for ImageResponseBase.
func (irb ImageResponseBase) AsDockerImageResponse() (*DockerImageResponse, bool) {
	return nil, false
}

// AsFPGADockerImageResponse is the BasicImageResponseBase implementation for ImageResponseBase.
func (irb ImageResponseBase) AsFPGADockerImageResponse() (*FPGADockerImageResponse, bool) {
	return nil, false
}

// AsImageResponseBase is the BasicImageResponseBase implementation for ImageResponseBase.
func (irb ImageResponseBase) AsImageResponseBase() (*ImageResponseBase, bool) {
	return &irb, true
}

// AsBasicImageResponseBase is the BasicImageResponseBase implementation for ImageResponseBase.
func (irb ImageResponseBase) AsBasicImageResponseBase() (BasicImageResponseBase, bool) {
	return &irb, true
}

// InnerErrorResponse a nested structure of errors.
type InnerErrorResponse struct {
	// Code - The error code.
	Code *string `json:"code,omitempty"`
	// InnerError - A nested list of inner errors. When evaluating errors, clients MUST traverse through all of the nested “innerErrors” and choose the deepest one that they understand.
	InnerError *InnerErrorResponse `json:"innerError,omitempty"`
}

// IotBaseModuleSettings ...
type IotBaseModuleSettings struct {
	ModuleName           *string            `json:"moduleName,omitempty"`
	PropertiesDesired    map[string]*string `json:"propertiesDesired"`
	CreateOptions        *string            `json:"createOptions,omitempty"`
	EnvironmentVariables map[string]*string `json:"environmentVariables"`
}

// MarshalJSON is the custom marshaler for IotBaseModuleSettings.
func (ibms IotBaseModuleSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ibms.ModuleName != nil {
		objectMap["moduleName"] = ibms.ModuleName
	}
	if ibms.PropertiesDesired != nil {
		objectMap["propertiesDesired"] = ibms.PropertiesDesired
	}
	if ibms.CreateOptions != nil {
		objectMap["createOptions"] = ibms.CreateOptions
	}
	if ibms.EnvironmentVariables != nil {
		objectMap["environmentVariables"] = ibms.EnvironmentVariables
	}
	return json.Marshal(objectMap)
}

// IotModuleSettings ...
type IotModuleSettings struct {
	ImageLocation        *string            `json:"imageLocation,omitempty"`
	ModuleName           *string            `json:"moduleName,omitempty"`
	PropertiesDesired    map[string]*string `json:"propertiesDesired"`
	CreateOptions        *string            `json:"createOptions,omitempty"`
	EnvironmentVariables map[string]*string `json:"environmentVariables"`
}

// MarshalJSON is the custom marshaler for IotModuleSettings.
func (ims IotModuleSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ims.ImageLocation != nil {
		objectMap["imageLocation"] = ims.ImageLocation
	}
	if ims.ModuleName != nil {
		objectMap["moduleName"] = ims.ModuleName
	}
	if ims.PropertiesDesired != nil {
		objectMap["propertiesDesired"] = ims.PropertiesDesired
	}
	if ims.CreateOptions != nil {
		objectMap["createOptions"] = ims.CreateOptions
	}
	if ims.EnvironmentVariables != nil {
		objectMap["environmentVariables"] = ims.EnvironmentVariables
	}
	return json.Marshal(objectMap)
}

// IotServiceResponse ...
type IotServiceResponse struct {
	IotDeviceID    *string                `json:"iotDeviceId,omitempty"`
	Routes         map[string]*string     `json:"routes"`
	ComputeName    *string                `json:"computeName,omitempty"`
	IotEdgeModules *[]IotModuleSettings   `json:"iotEdgeModules,omitempty"`
	AuthEnabled    *bool                  `json:"authEnabled,omitempty"`
	ImageDetails   BasicImageResponseBase `json:"imageDetails,omitempty"`
	ImageID        *string                `json:"imageId,omitempty"`
	// ID - The service Id.
	ID *string `json:"id,omitempty"`
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The service description.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service property dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// OperationID - The ID of the latest asynchronous operation for this service.
	OperationID *string `json:"operationId,omitempty"`
	// State - The current state of the service. Possible values include: 'WebServiceStateTransitioning', 'WebServiceStateHealthy', 'WebServiceStateUnhealthy', 'WebServiceStateFailed'
	State WebServiceState `json:"state,omitempty"`
	// CreatedTime - The time the service was created.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// UpdatedTime - The time the service was updated.
	UpdatedTime *date.Time `json:"updatedTime,omitempty"`
	// Error - The error details.
	Error *ModelErrorResponse `json:"error,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeServiceResponseBase', 'ComputeTypeACI', 'ComputeTypeAKS', 'ComputeTypeAKSENDPOINT', 'ComputeTypeAKSVariantResponse', 'ComputeTypeAMLCOMPUTE', 'ComputeTypeIOT', 'ComputeTypeUNKNOWON'
	ComputeType ComputeType `json:"computeType,omitempty"`
}

// MarshalJSON is the custom marshaler for IotServiceResponse.
func (isr IotServiceResponse) MarshalJSON() ([]byte, error) {
	isr.ComputeType = ComputeTypeIOT
	objectMap := make(map[string]interface{})
	if isr.IotDeviceID != nil {
		objectMap["iotDeviceId"] = isr.IotDeviceID
	}
	if isr.Routes != nil {
		objectMap["routes"] = isr.Routes
	}
	if isr.ComputeName != nil {
		objectMap["computeName"] = isr.ComputeName
	}
	if isr.IotEdgeModules != nil {
		objectMap["iotEdgeModules"] = isr.IotEdgeModules
	}
	if isr.AuthEnabled != nil {
		objectMap["authEnabled"] = isr.AuthEnabled
	}
	objectMap["imageDetails"] = isr.ImageDetails
	if isr.ImageID != nil {
		objectMap["imageId"] = isr.ImageID
	}
	if isr.ID != nil {
		objectMap["id"] = isr.ID
	}
	if isr.Name != nil {
		objectMap["name"] = isr.Name
	}
	if isr.Description != nil {
		objectMap["description"] = isr.Description
	}
	if isr.KvTags != nil {
		objectMap["kvTags"] = isr.KvTags
	}
	if isr.Properties != nil {
		objectMap["properties"] = isr.Properties
	}
	if isr.OperationID != nil {
		objectMap["operationId"] = isr.OperationID
	}
	if isr.State != "" {
		objectMap["state"] = isr.State
	}
	if isr.CreatedTime != nil {
		objectMap["createdTime"] = isr.CreatedTime
	}
	if isr.UpdatedTime != nil {
		objectMap["updatedTime"] = isr.UpdatedTime
	}
	if isr.Error != nil {
		objectMap["error"] = isr.Error
	}
	if isr.DeploymentType != "" {
		objectMap["deploymentType"] = isr.DeploymentType
	}
	if isr.ComputeType != "" {
		objectMap["computeType"] = isr.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceResponse is the BasicServiceResponseBase implementation for IotServiceResponse.
func (isr IotServiceResponse) AsACIServiceResponse() (*ACIServiceResponse, bool) {
	return nil, false
}

// AsAKSServiceResponse is the BasicServiceResponseBase implementation for IotServiceResponse.
func (isr IotServiceResponse) AsAKSServiceResponse() (*AKSServiceResponse, bool) {
	return nil, false
}

// AsAKSEndpointResponse is the BasicServiceResponseBase implementation for IotServiceResponse.
func (isr IotServiceResponse) AsAKSEndpointResponse() (*AKSEndpointResponse, bool) {
	return nil, false
}

// AsAKSVariantResponse is the BasicServiceResponseBase implementation for IotServiceResponse.
func (isr IotServiceResponse) AsAKSVariantResponse() (*AKSVariantResponse, bool) {
	return nil, false
}

// AsBasicAKSVariantResponse is the BasicServiceResponseBase implementation for IotServiceResponse.
func (isr IotServiceResponse) AsBasicAKSVariantResponse() (BasicAKSVariantResponse, bool) {
	return nil, false
}

// AsBatchServiceResponse is the BasicServiceResponseBase implementation for IotServiceResponse.
func (isr IotServiceResponse) AsBatchServiceResponse() (*BatchServiceResponse, bool) {
	return nil, false
}

// AsIotServiceResponse is the BasicServiceResponseBase implementation for IotServiceResponse.
func (isr IotServiceResponse) AsIotServiceResponse() (*IotServiceResponse, bool) {
	return &isr, true
}

// AsUnknownServiceResponse is the BasicServiceResponseBase implementation for IotServiceResponse.
func (isr IotServiceResponse) AsUnknownServiceResponse() (*UnknownServiceResponse, bool) {
	return nil, false
}

// AsServiceResponseBase is the BasicServiceResponseBase implementation for IotServiceResponse.
func (isr IotServiceResponse) AsServiceResponseBase() (*ServiceResponseBase, bool) {
	return nil, false
}

// AsBasicServiceResponseBase is the BasicServiceResponseBase implementation for IotServiceResponse.
func (isr IotServiceResponse) AsBasicServiceResponseBase() (BasicServiceResponseBase, bool) {
	return &isr, true
}

// UnmarshalJSON is the custom unmarshaler for IotServiceResponse struct.
func (isr *IotServiceResponse) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "iotDeviceId":
			if v != nil {
				var iotDeviceID string
				err = json.Unmarshal(*v, &iotDeviceID)
				if err != nil {
					return err
				}
				isr.IotDeviceID = &iotDeviceID
			}
		case "routes":
			if v != nil {
				var routes map[string]*string
				err = json.Unmarshal(*v, &routes)
				if err != nil {
					return err
				}
				isr.Routes = routes
			}
		case "computeName":
			if v != nil {
				var computeName string
				err = json.Unmarshal(*v, &computeName)
				if err != nil {
					return err
				}
				isr.ComputeName = &computeName
			}
		case "iotEdgeModules":
			if v != nil {
				var iotEdgeModules []IotModuleSettings
				err = json.Unmarshal(*v, &iotEdgeModules)
				if err != nil {
					return err
				}
				isr.IotEdgeModules = &iotEdgeModules
			}
		case "authEnabled":
			if v != nil {
				var authEnabled bool
				err = json.Unmarshal(*v, &authEnabled)
				if err != nil {
					return err
				}
				isr.AuthEnabled = &authEnabled
			}
		case "imageDetails":
			if v != nil {
				imageDetails, err := unmarshalBasicImageResponseBase(*v)
				if err != nil {
					return err
				}
				isr.ImageDetails = imageDetails
			}
		case "imageId":
			if v != nil {
				var imageID string
				err = json.Unmarshal(*v, &imageID)
				if err != nil {
					return err
				}
				isr.ImageID = &imageID
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				isr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				isr.Name = &name
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				isr.Description = &description
			}
		case "kvTags":
			if v != nil {
				var kvTags map[string]*string
				err = json.Unmarshal(*v, &kvTags)
				if err != nil {
					return err
				}
				isr.KvTags = kvTags
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				isr.Properties = properties
			}
		case "operationId":
			if v != nil {
				var operationID string
				err = json.Unmarshal(*v, &operationID)
				if err != nil {
					return err
				}
				isr.OperationID = &operationID
			}
		case "state":
			if v != nil {
				var state WebServiceState
				err = json.Unmarshal(*v, &state)
				if err != nil {
					return err
				}
				isr.State = state
			}
		case "createdTime":
			if v != nil {
				var createdTime date.Time
				err = json.Unmarshal(*v, &createdTime)
				if err != nil {
					return err
				}
				isr.CreatedTime = &createdTime
			}
		case "updatedTime":
			if v != nil {
				var updatedTime date.Time
				err = json.Unmarshal(*v, &updatedTime)
				if err != nil {
					return err
				}
				isr.UpdatedTime = &updatedTime
			}
		case "error":
			if v != nil {
				var errorVar ModelErrorResponse
				err = json.Unmarshal(*v, &errorVar)
				if err != nil {
					return err
				}
				isr.Error = &errorVar
			}
		case "deploymentType":
			if v != nil {
				var deploymentType DeploymentType
				err = json.Unmarshal(*v, &deploymentType)
				if err != nil {
					return err
				}
				isr.DeploymentType = deploymentType
			}
		case "computeType":
			if v != nil {
				var computeType ComputeType
				err = json.Unmarshal(*v, &computeType)
				if err != nil {
					return err
				}
				isr.ComputeType = computeType
			}
		}
	}

	return nil
}

// JSONPatchOperation the Json Patch definition.
type JSONPatchOperation struct {
	// Value - The value.
	Value interface{} `json:"value,omitempty"`
	// Path - The target location.
	Path *string `json:"path,omitempty"`
	// Op - The operation.
	Op *string `json:"op,omitempty"`
	// From - The source location.
	From *string `json:"from,omitempty"`
}

// KeyValuePairBaseEventErrorResponse ...
type KeyValuePairBaseEventErrorResponse struct {
	// Key - READ-ONLY
	Key *BaseEvent `json:"key,omitempty"`
	// Value - READ-ONLY
	Value *ErrorResponse `json:"value,omitempty"`
}

// MarshalJSON is the custom marshaler for KeyValuePairBaseEventErrorResponse.
func (kvpbeer KeyValuePairBaseEventErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// LivenessProbeRequirements the liveness probe requirements.
type LivenessProbeRequirements struct {
	// FailureThreshold - The number of failures to allow before returning an unhealthy status.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`
	// SuccessThreshold - The number of successful probes before returning a healthy status.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`
	// TimeoutSeconds - The probe timeout in seconds.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
	// PeriodSeconds - The length of time between probes in seconds.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`
	// InitialDelaySeconds - The delay before the first probe in seconds.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`
}

// Metric ...
type Metric struct {
	MetricID        *uuid.UUID                `json:"metricId,omitempty"`
	DataContainerID *string                   `json:"dataContainerId,omitempty"`
	MetricType      *string                   `json:"metricType,omitempty"`
	CreatedUtc      *date.Time                `json:"createdUtc,omitempty"`
	Name            *string                   `json:"name,omitempty"`
	Description     *string                   `json:"description,omitempty"`
	Label           *string                   `json:"label,omitempty"`
	NumCells        *int32                    `json:"numCells,omitempty"`
	DataLocation    *string                   `json:"dataLocation,omitempty"`
	Cells           *[]map[string]interface{} `json:"cells,omitempty"`
	Schema          *MetricSchema             `json:"schema,omitempty"`
}

// MetricSchema ...
type MetricSchema struct {
	NumProperties *int32                  `json:"numProperties,omitempty"`
	Properties    *[]MetricSchemaProperty `json:"properties,omitempty"`
}

// MetricSchemaProperty ...
type MetricSchemaProperty struct {
	PropertyID *string `json:"propertyId,omitempty"`
	Name       *string `json:"name,omitempty"`
	Type       *string `json:"type,omitempty"`
}

// Model an Azure Machine Learning Model.
type Model struct {
	autorest.Response `json:"-"`
	// ID - The Model Id.
	ID *string `json:"id,omitempty"`
	// Name - The Model name.
	Name *string `json:"name,omitempty"`
	// Framework - The Model framework.
	Framework *string `json:"framework,omitempty"`
	// FrameworkVersion - The Model framework version.
	FrameworkVersion *string `json:"frameworkVersion,omitempty"`
	// Version - The Model version assigned by Model Management Service.
	Version *int64 `json:"version,omitempty"`
	// Datasets - The list of datasets associated with the model.
	Datasets *[]DatasetReference `json:"datasets,omitempty"`
	// URL - The URL of the Model. Usually a SAS URL.
	URL *string `json:"url,omitempty"`
	// MimeType - The MIME type of Model content. For more details about MIME type, please open https://www.iana.org/assignments/media-types/media-types.xhtml
	MimeType *string `json:"mimeType,omitempty"`
	// Description - The Model description text.
	Description *string `json:"description,omitempty"`
	// CreatedTime - READ-ONLY; The Model creation time (UTC).
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// ModifiedTime - READ-ONLY; The Model last modified time (UTC).
	ModifiedTime *date.Time `json:"modifiedTime,omitempty"`
	// Unpack - Indicates whether we need to unpack the Model during docker Image creation.
	Unpack *bool `json:"unpack,omitempty"`
	// ParentModelID - The Parent Model Id.
	ParentModelID *string `json:"parentModelId,omitempty"`
	// RunID - The RunId that created this model.
	RunID *string `json:"runId,omitempty"`
	// ExperimentName - The name of the experiment where this model was created.
	ExperimentName *string `json:"experimentName,omitempty"`
	// KvTags - The Model tag dictionary. Items are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The Model property dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
}

// MarshalJSON is the custom marshaler for Model.
func (mVar Model) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mVar.ID != nil {
		objectMap["id"] = mVar.ID
	}
	if mVar.Name != nil {
		objectMap["name"] = mVar.Name
	}
	if mVar.Framework != nil {
		objectMap["framework"] = mVar.Framework
	}
	if mVar.FrameworkVersion != nil {
		objectMap["frameworkVersion"] = mVar.FrameworkVersion
	}
	if mVar.Version != nil {
		objectMap["version"] = mVar.Version
	}
	if mVar.Datasets != nil {
		objectMap["datasets"] = mVar.Datasets
	}
	if mVar.URL != nil {
		objectMap["url"] = mVar.URL
	}
	if mVar.MimeType != nil {
		objectMap["mimeType"] = mVar.MimeType
	}
	if mVar.Description != nil {
		objectMap["description"] = mVar.Description
	}
	if mVar.Unpack != nil {
		objectMap["unpack"] = mVar.Unpack
	}
	if mVar.ParentModelID != nil {
		objectMap["parentModelId"] = mVar.ParentModelID
	}
	if mVar.RunID != nil {
		objectMap["runId"] = mVar.RunID
	}
	if mVar.ExperimentName != nil {
		objectMap["experimentName"] = mVar.ExperimentName
	}
	if mVar.KvTags != nil {
		objectMap["kvTags"] = mVar.KvTags
	}
	if mVar.Properties != nil {
		objectMap["properties"] = mVar.Properties
	}
	return json.Marshal(objectMap)
}

// ModelDataCollection the Model data collection properties.
type ModelDataCollection struct {
	// EventHubEnabled - Option for enabling/disabling Event Hub.
	EventHubEnabled *bool `json:"eventHubEnabled,omitempty"`
	// StorageEnabled - Option for enabling/disabling storage.
	StorageEnabled *bool `json:"storageEnabled,omitempty"`
}

// ModelDockerSection ...
type ModelDockerSection struct {
	// BaseImage - Base image used for Docker-based runs. Mutually exclusive with BaseDockerfile.
	BaseImage *string `json:"baseImage,omitempty"`
	// BaseDockerfile - Base Dockerfile used for Docker-based runs. Mutually exclusive with BaseImage.
	BaseDockerfile *string `json:"baseDockerfile,omitempty"`
	// Enabled - Set True to perform this run inside a Docker container.
	Enabled *bool `json:"enabled,omitempty"`
	// SharedVolumes - Set False if necessary to work around shared volume bugs on Windows.
	SharedVolumes *bool `json:"sharedVolumes,omitempty"`
	// GpuSupport - Run with NVidia Docker extension to support GPUs.
	GpuSupport *bool `json:"gpuSupport,omitempty"`
	// ShmSize - The shared memory size setting for NVidia GPUs.
	ShmSize *string `json:"shmSize,omitempty"`
	// Arguments - Extra arguments to the Docker run command.
	Arguments *[]string `json:"arguments,omitempty"`
	// BaseImageRegistry - Image registry that contains the base image.
	BaseImageRegistry *ContainerRegistry `json:"baseImageRegistry,omitempty"`
}

// ModelEnvironmentDefinition ...
type ModelEnvironmentDefinition struct {
	// Name - The name of the environment.
	Name *string `json:"name,omitempty"`
	// Version - The environment version.
	Version *string `json:"version,omitempty"`
	// Python - Settings for a Python environment.
	Python *ModelPythonSection `json:"python,omitempty"`
	// EnvironmentVariables - Definition of environment variables to be defined in the environment.
	EnvironmentVariables map[string]*string `json:"environmentVariables"`
	// Docker - The definition of a Docker container.
	Docker *ModelDockerSection `json:"docker,omitempty"`
	// Spark - The configuration for a Spark environment.
	Spark *ModelSparkSection `json:"spark,omitempty"`
	// InferencingStackVersion - The Inferencing stack version.
	InferencingStackVersion *string `json:"inferencingStackVersion,omitempty"`
}

// MarshalJSON is the custom marshaler for ModelEnvironmentDefinition.
func (med ModelEnvironmentDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if med.Name != nil {
		objectMap["name"] = med.Name
	}
	if med.Version != nil {
		objectMap["version"] = med.Version
	}
	if med.Python != nil {
		objectMap["python"] = med.Python
	}
	if med.EnvironmentVariables != nil {
		objectMap["environmentVariables"] = med.EnvironmentVariables
	}
	if med.Docker != nil {
		objectMap["docker"] = med.Docker
	}
	if med.Spark != nil {
		objectMap["spark"] = med.Spark
	}
	if med.InferencingStackVersion != nil {
		objectMap["inferencingStackVersion"] = med.InferencingStackVersion
	}
	return json.Marshal(objectMap)
}

// ModelErrorResponse the Model Management Service Error object.
type ModelErrorResponse struct {
	// Code - The error code.
	Code *string `json:"code,omitempty"`
	// StatusCode - The HTTP status code.
	StatusCode *int32 `json:"statusCode,omitempty"`
	// Message - The error message.
	Message *string `json:"message,omitempty"`
	// Details - An array of error detail objects.
	Details *[]ErrorDetails `json:"details,omitempty"`
}

// ModelOperationalState the operational state of the Model.
type ModelOperationalState struct {
	autorest.Response `json:"-"`
	// DeploymentSummary - The summary of the deployment.
	DeploymentSummary *DeploymentSummary `json:"deploymentSummary,omitempty"`
	// EndTime - The deployment end time.
	EndTime *string `json:"endTime,omitempty"`
	// StartTime - The deployment start time.
	StartTime *string `json:"startTime,omitempty"`
}

// ModelPythonSection ...
type ModelPythonSection struct {
	// InterpreterPath - The python interpreter path. This is only used when user_managed_dependencies=True.
	InterpreterPath *string `json:"interpreterPath,omitempty"`
	// UserManagedDependencies - True means that AzureML reuses an existing python environment; False means that AzureML will create a python environment based on the Conda dependencies specification.
	UserManagedDependencies *bool       `json:"userManagedDependencies,omitempty"`
	CondaDependencies       interface{} `json:"condaDependencies,omitempty"`
	BaseCondaEnvironment    *string     `json:"baseCondaEnvironment,omitempty"`
}

// ModelSparkSection ...
type ModelSparkSection struct {
	// Repositories - The list of spark repositories.
	Repositories *[]string `json:"repositories,omitempty"`
	// Packages - The Spark packages to use.
	Packages *[]SparkMavenPackage `json:"packages,omitempty"`
	// PrecachePackages - Whether to precache the packages.
	PrecachePackages *bool `json:"precachePackages,omitempty"`
}

// ModifyExperiment ...
type ModifyExperiment struct {
	Description *string            `json:"description,omitempty"`
	Tags        map[string]*string `json:"tags"`
	Archive     *bool              `json:"archive,omitempty"`
}

// MarshalJSON is the custom marshaler for ModifyExperiment.
func (me ModifyExperiment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if me.Description != nil {
		objectMap["description"] = me.Description
	}
	if me.Tags != nil {
		objectMap["tags"] = me.Tags
	}
	if me.Archive != nil {
		objectMap["archive"] = me.Archive
	}
	return json.Marshal(objectMap)
}

// MpiConfiguration ...
type MpiConfiguration struct {
	// ProcessCountPerNode - Number of processes per node.
	ProcessCountPerNode *int32 `json:"processCountPerNode,omitempty"`
}

// PaginatedArtifactContentInformationList a paginated list of ArtifactContentInformations.
type PaginatedArtifactContentInformationList struct {
	autorest.Response `json:"-"`
	// Value - An array of objects of type ArtifactContentInformation.
	Value *[]ArtifactContentInformation `json:"value,omitempty"`
	// ContinuationToken - The token used in retrieving the next page.  If null, there are no additional pages.
	ContinuationToken *string `json:"continuationToken,omitempty"`
	// NextLink - The link to the next page constructed using the continuationToken.  If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
}

// PaginatedArtifactContentInformationListIterator provides access to a complete listing of
// ArtifactContentInformation values.
type PaginatedArtifactContentInformationListIterator struct {
	i    int
	page PaginatedArtifactContentInformationListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PaginatedArtifactContentInformationListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedArtifactContentInformationListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PaginatedArtifactContentInformationListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PaginatedArtifactContentInformationListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PaginatedArtifactContentInformationListIterator) Response() PaginatedArtifactContentInformationList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PaginatedArtifactContentInformationListIterator) Value() ArtifactContentInformation {
	if !iter.page.NotDone() {
		return ArtifactContentInformation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PaginatedArtifactContentInformationListIterator type.
func NewPaginatedArtifactContentInformationListIterator(page PaginatedArtifactContentInformationListPage) PaginatedArtifactContentInformationListIterator {
	return PaginatedArtifactContentInformationListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pacil PaginatedArtifactContentInformationList) IsEmpty() bool {
	return pacil.Value == nil || len(*pacil.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pacil PaginatedArtifactContentInformationList) hasNextLink() bool {
	return pacil.NextLink != nil && len(*pacil.NextLink) != 0
}

// paginatedArtifactContentInformationListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pacil PaginatedArtifactContentInformationList) paginatedArtifactContentInformationListPreparer(ctx context.Context) (*http.Request, error) {
	if !pacil.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pacil.NextLink)))
}

// PaginatedArtifactContentInformationListPage contains a page of ArtifactContentInformation values.
type PaginatedArtifactContentInformationListPage struct {
	fn    func(context.Context, PaginatedArtifactContentInformationList) (PaginatedArtifactContentInformationList, error)
	pacil PaginatedArtifactContentInformationList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PaginatedArtifactContentInformationListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedArtifactContentInformationListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pacil)
		if err != nil {
			return err
		}
		page.pacil = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PaginatedArtifactContentInformationListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PaginatedArtifactContentInformationListPage) NotDone() bool {
	return !page.pacil.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PaginatedArtifactContentInformationListPage) Response() PaginatedArtifactContentInformationList {
	return page.pacil
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PaginatedArtifactContentInformationListPage) Values() []ArtifactContentInformation {
	if page.pacil.IsEmpty() {
		return nil
	}
	return *page.pacil.Value
}

// Creates a new instance of the PaginatedArtifactContentInformationListPage type.
func NewPaginatedArtifactContentInformationListPage(cur PaginatedArtifactContentInformationList, getNextPage func(context.Context, PaginatedArtifactContentInformationList) (PaginatedArtifactContentInformationList, error)) PaginatedArtifactContentInformationListPage {
	return PaginatedArtifactContentInformationListPage{
		fn:    getNextPage,
		pacil: cur,
	}
}

// PaginatedArtifactList a paginated list of Artifacts.
type PaginatedArtifactList struct {
	autorest.Response `json:"-"`
	// Value - An array of objects of type Artifact.
	Value *[]Artifact `json:"value,omitempty"`
	// ContinuationToken - The token used in retrieving the next page.  If null, there are no additional pages.
	ContinuationToken *string `json:"continuationToken,omitempty"`
	// NextLink - The link to the next page constructed using the continuationToken.  If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
}

// PaginatedArtifactListIterator provides access to a complete listing of Artifact values.
type PaginatedArtifactListIterator struct {
	i    int
	page PaginatedArtifactListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PaginatedArtifactListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedArtifactListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PaginatedArtifactListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PaginatedArtifactListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PaginatedArtifactListIterator) Response() PaginatedArtifactList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PaginatedArtifactListIterator) Value() Artifact {
	if !iter.page.NotDone() {
		return Artifact{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PaginatedArtifactListIterator type.
func NewPaginatedArtifactListIterator(page PaginatedArtifactListPage) PaginatedArtifactListIterator {
	return PaginatedArtifactListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pal PaginatedArtifactList) IsEmpty() bool {
	return pal.Value == nil || len(*pal.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pal PaginatedArtifactList) hasNextLink() bool {
	return pal.NextLink != nil && len(*pal.NextLink) != 0
}

// paginatedArtifactListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pal PaginatedArtifactList) paginatedArtifactListPreparer(ctx context.Context) (*http.Request, error) {
	if !pal.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pal.NextLink)))
}

// PaginatedArtifactListPage contains a page of Artifact values.
type PaginatedArtifactListPage struct {
	fn  func(context.Context, PaginatedArtifactList) (PaginatedArtifactList, error)
	pal PaginatedArtifactList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PaginatedArtifactListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedArtifactListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pal)
		if err != nil {
			return err
		}
		page.pal = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PaginatedArtifactListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PaginatedArtifactListPage) NotDone() bool {
	return !page.pal.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PaginatedArtifactListPage) Response() PaginatedArtifactList {
	return page.pal
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PaginatedArtifactListPage) Values() []Artifact {
	if page.pal.IsEmpty() {
		return nil
	}
	return *page.pal.Value
}

// Creates a new instance of the PaginatedArtifactListPage type.
func NewPaginatedArtifactListPage(cur PaginatedArtifactList, getNextPage func(context.Context, PaginatedArtifactList) (PaginatedArtifactList, error)) PaginatedArtifactListPage {
	return PaginatedArtifactListPage{
		fn:  getNextPage,
		pal: cur,
	}
}

// PaginatedAssetList a paginated list of Assets.
type PaginatedAssetList struct {
	autorest.Response `json:"-"`
	// Value - An array of objects of type Asset.
	Value *[]Asset `json:"value,omitempty"`
	// NextLink - A continuation link (absolute URI) to the next page of results in the list.
	NextLink *string `json:"nextLink,omitempty"`
}

// PaginatedAssetListIterator provides access to a complete listing of Asset values.
type PaginatedAssetListIterator struct {
	i    int
	page PaginatedAssetListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PaginatedAssetListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedAssetListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PaginatedAssetListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PaginatedAssetListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PaginatedAssetListIterator) Response() PaginatedAssetList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PaginatedAssetListIterator) Value() Asset {
	if !iter.page.NotDone() {
		return Asset{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PaginatedAssetListIterator type.
func NewPaginatedAssetListIterator(page PaginatedAssetListPage) PaginatedAssetListIterator {
	return PaginatedAssetListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pal PaginatedAssetList) IsEmpty() bool {
	return pal.Value == nil || len(*pal.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pal PaginatedAssetList) hasNextLink() bool {
	return pal.NextLink != nil && len(*pal.NextLink) != 0
}

// paginatedAssetListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pal PaginatedAssetList) paginatedAssetListPreparer(ctx context.Context) (*http.Request, error) {
	if !pal.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pal.NextLink)))
}

// PaginatedAssetListPage contains a page of Asset values.
type PaginatedAssetListPage struct {
	fn  func(context.Context, PaginatedAssetList) (PaginatedAssetList, error)
	pal PaginatedAssetList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PaginatedAssetListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedAssetListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pal)
		if err != nil {
			return err
		}
		page.pal = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PaginatedAssetListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PaginatedAssetListPage) NotDone() bool {
	return !page.pal.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PaginatedAssetListPage) Response() PaginatedAssetList {
	return page.pal
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PaginatedAssetListPage) Values() []Asset {
	if page.pal.IsEmpty() {
		return nil
	}
	return *page.pal.Value
}

// Creates a new instance of the PaginatedAssetListPage type.
func NewPaginatedAssetListPage(cur PaginatedAssetList, getNextPage func(context.Context, PaginatedAssetList) (PaginatedAssetList, error)) PaginatedAssetListPage {
	return PaginatedAssetListPage{
		fn:  getNextPage,
		pal: cur,
	}
}

// PaginatedDataStoreList a paginated list of DataStores.
type PaginatedDataStoreList struct {
	autorest.Response `json:"-"`
	// Value - An array of objects of type DataStore.
	Value *[]DataStore `json:"value,omitempty"`
	// ContinuationToken - The token used in retrieving the next page.  If null, there are no additional pages.
	ContinuationToken *string `json:"continuationToken,omitempty"`
	// NextLink - The link to the next page constructed using the continuationToken.  If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
}

// PaginatedDataStoreListIterator provides access to a complete listing of DataStore values.
type PaginatedDataStoreListIterator struct {
	i    int
	page PaginatedDataStoreListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PaginatedDataStoreListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedDataStoreListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PaginatedDataStoreListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PaginatedDataStoreListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PaginatedDataStoreListIterator) Response() PaginatedDataStoreList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PaginatedDataStoreListIterator) Value() DataStore {
	if !iter.page.NotDone() {
		return DataStore{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PaginatedDataStoreListIterator type.
func NewPaginatedDataStoreListIterator(page PaginatedDataStoreListPage) PaginatedDataStoreListIterator {
	return PaginatedDataStoreListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pdsl PaginatedDataStoreList) IsEmpty() bool {
	return pdsl.Value == nil || len(*pdsl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pdsl PaginatedDataStoreList) hasNextLink() bool {
	return pdsl.NextLink != nil && len(*pdsl.NextLink) != 0
}

// paginatedDataStoreListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pdsl PaginatedDataStoreList) paginatedDataStoreListPreparer(ctx context.Context) (*http.Request, error) {
	if !pdsl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pdsl.NextLink)))
}

// PaginatedDataStoreListPage contains a page of DataStore values.
type PaginatedDataStoreListPage struct {
	fn   func(context.Context, PaginatedDataStoreList) (PaginatedDataStoreList, error)
	pdsl PaginatedDataStoreList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PaginatedDataStoreListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedDataStoreListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pdsl)
		if err != nil {
			return err
		}
		page.pdsl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PaginatedDataStoreListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PaginatedDataStoreListPage) NotDone() bool {
	return !page.pdsl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PaginatedDataStoreListPage) Response() PaginatedDataStoreList {
	return page.pdsl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PaginatedDataStoreListPage) Values() []DataStore {
	if page.pdsl.IsEmpty() {
		return nil
	}
	return *page.pdsl.Value
}

// Creates a new instance of the PaginatedDataStoreListPage type.
func NewPaginatedDataStoreListPage(cur PaginatedDataStoreList, getNextPage func(context.Context, PaginatedDataStoreList) (PaginatedDataStoreList, error)) PaginatedDataStoreListPage {
	return PaginatedDataStoreListPage{
		fn:   getNextPage,
		pdsl: cur,
	}
}

// PaginatedExperimentList a paginated list of Experiments.
type PaginatedExperimentList struct {
	autorest.Response `json:"-"`
	// Value - An array of objects of type Experiment.
	Value *[]Experiment `json:"value,omitempty"`
	// ContinuationToken - The token used in retrieving the next page.  If null, there are no additional pages.
	ContinuationToken *string `json:"continuationToken,omitempty"`
	// NextLink - The link to the next page constructed using the continuationToken.  If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
}

// PaginatedExperimentListIterator provides access to a complete listing of Experiment values.
type PaginatedExperimentListIterator struct {
	i    int
	page PaginatedExperimentListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PaginatedExperimentListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedExperimentListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PaginatedExperimentListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PaginatedExperimentListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PaginatedExperimentListIterator) Response() PaginatedExperimentList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PaginatedExperimentListIterator) Value() Experiment {
	if !iter.page.NotDone() {
		return Experiment{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PaginatedExperimentListIterator type.
func NewPaginatedExperimentListIterator(page PaginatedExperimentListPage) PaginatedExperimentListIterator {
	return PaginatedExperimentListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pel PaginatedExperimentList) IsEmpty() bool {
	return pel.Value == nil || len(*pel.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pel PaginatedExperimentList) hasNextLink() bool {
	return pel.NextLink != nil && len(*pel.NextLink) != 0
}

// paginatedExperimentListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pel PaginatedExperimentList) paginatedExperimentListPreparer(ctx context.Context) (*http.Request, error) {
	if !pel.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pel.NextLink)))
}

// PaginatedExperimentListPage contains a page of Experiment values.
type PaginatedExperimentListPage struct {
	fn  func(context.Context, PaginatedExperimentList) (PaginatedExperimentList, error)
	pel PaginatedExperimentList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PaginatedExperimentListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedExperimentListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pel)
		if err != nil {
			return err
		}
		page.pel = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PaginatedExperimentListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PaginatedExperimentListPage) NotDone() bool {
	return !page.pel.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PaginatedExperimentListPage) Response() PaginatedExperimentList {
	return page.pel
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PaginatedExperimentListPage) Values() []Experiment {
	if page.pel.IsEmpty() {
		return nil
	}
	return *page.pel.Value
}

// Creates a new instance of the PaginatedExperimentListPage type.
func NewPaginatedExperimentListPage(cur PaginatedExperimentList, getNextPage func(context.Context, PaginatedExperimentList) (PaginatedExperimentList, error)) PaginatedExperimentListPage {
	return PaginatedExperimentListPage{
		fn:  getNextPage,
		pel: cur,
	}
}

// PaginatedModelList a paginated list of Models.
type PaginatedModelList struct {
	autorest.Response `json:"-"`
	// Value - An array of objects of type Model.
	Value *[]Model `json:"value,omitempty"`
	// NextLink - A continuation link (absolute URI) to the next page of results in the list.
	NextLink *string `json:"nextLink,omitempty"`
}

// PaginatedModelListIterator provides access to a complete listing of Model values.
type PaginatedModelListIterator struct {
	i    int
	page PaginatedModelListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PaginatedModelListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedModelListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PaginatedModelListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PaginatedModelListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PaginatedModelListIterator) Response() PaginatedModelList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PaginatedModelListIterator) Value() Model {
	if !iter.page.NotDone() {
		return Model{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PaginatedModelListIterator type.
func NewPaginatedModelListIterator(page PaginatedModelListPage) PaginatedModelListIterator {
	return PaginatedModelListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pml PaginatedModelList) IsEmpty() bool {
	return pml.Value == nil || len(*pml.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pml PaginatedModelList) hasNextLink() bool {
	return pml.NextLink != nil && len(*pml.NextLink) != 0
}

// paginatedModelListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pml PaginatedModelList) paginatedModelListPreparer(ctx context.Context) (*http.Request, error) {
	if !pml.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pml.NextLink)))
}

// PaginatedModelListPage contains a page of Model values.
type PaginatedModelListPage struct {
	fn  func(context.Context, PaginatedModelList) (PaginatedModelList, error)
	pml PaginatedModelList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PaginatedModelListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedModelListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pml)
		if err != nil {
			return err
		}
		page.pml = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PaginatedModelListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PaginatedModelListPage) NotDone() bool {
	return !page.pml.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PaginatedModelListPage) Response() PaginatedModelList {
	return page.pml
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PaginatedModelListPage) Values() []Model {
	if page.pml.IsEmpty() {
		return nil
	}
	return *page.pml.Value
}

// Creates a new instance of the PaginatedModelListPage type.
func NewPaginatedModelListPage(cur PaginatedModelList, getNextPage func(context.Context, PaginatedModelList) (PaginatedModelList, error)) PaginatedModelListPage {
	return PaginatedModelListPage{
		fn:  getNextPage,
		pml: cur,
	}
}

// PaginatedProfileResponseList a paginated list of ProfileResponses.
type PaginatedProfileResponseList struct {
	autorest.Response `json:"-"`
	// Value - An array of objects of type ProfileResponse.
	Value *[]ProfileResponse `json:"value,omitempty"`
	// NextLink - A continuation link (absolute URI) to the next page of results in the list.
	NextLink *string `json:"nextLink,omitempty"`
}

// PaginatedProfileResponseListIterator provides access to a complete listing of ProfileResponse values.
type PaginatedProfileResponseListIterator struct {
	i    int
	page PaginatedProfileResponseListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PaginatedProfileResponseListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedProfileResponseListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PaginatedProfileResponseListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PaginatedProfileResponseListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PaginatedProfileResponseListIterator) Response() PaginatedProfileResponseList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PaginatedProfileResponseListIterator) Value() ProfileResponse {
	if !iter.page.NotDone() {
		return ProfileResponse{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PaginatedProfileResponseListIterator type.
func NewPaginatedProfileResponseListIterator(page PaginatedProfileResponseListPage) PaginatedProfileResponseListIterator {
	return PaginatedProfileResponseListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pprl PaginatedProfileResponseList) IsEmpty() bool {
	return pprl.Value == nil || len(*pprl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pprl PaginatedProfileResponseList) hasNextLink() bool {
	return pprl.NextLink != nil && len(*pprl.NextLink) != 0
}

// paginatedProfileResponseListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pprl PaginatedProfileResponseList) paginatedProfileResponseListPreparer(ctx context.Context) (*http.Request, error) {
	if !pprl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pprl.NextLink)))
}

// PaginatedProfileResponseListPage contains a page of ProfileResponse values.
type PaginatedProfileResponseListPage struct {
	fn   func(context.Context, PaginatedProfileResponseList) (PaginatedProfileResponseList, error)
	pprl PaginatedProfileResponseList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PaginatedProfileResponseListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedProfileResponseListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pprl)
		if err != nil {
			return err
		}
		page.pprl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PaginatedProfileResponseListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PaginatedProfileResponseListPage) NotDone() bool {
	return !page.pprl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PaginatedProfileResponseListPage) Response() PaginatedProfileResponseList {
	return page.pprl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PaginatedProfileResponseListPage) Values() []ProfileResponse {
	if page.pprl.IsEmpty() {
		return nil
	}
	return *page.pprl.Value
}

// Creates a new instance of the PaginatedProfileResponseListPage type.
func NewPaginatedProfileResponseListPage(cur PaginatedProfileResponseList, getNextPage func(context.Context, PaginatedProfileResponseList) (PaginatedProfileResponseList, error)) PaginatedProfileResponseListPage {
	return PaginatedProfileResponseListPage{
		fn:   getNextPage,
		pprl: cur,
	}
}

// PaginatedRunList a paginated list of Runs.
type PaginatedRunList struct {
	autorest.Response `json:"-"`
	// Value - An array of objects of type Run.
	Value *[]Run `json:"value,omitempty"`
	// ContinuationToken - The token used in retrieving the next page.  If null, there are no additional pages.
	ContinuationToken *string `json:"continuationToken,omitempty"`
	// NextLink - The link to the next page constructed using the continuationToken.  If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
}

// PaginatedRunListIterator provides access to a complete listing of Run values.
type PaginatedRunListIterator struct {
	i    int
	page PaginatedRunListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PaginatedRunListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedRunListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PaginatedRunListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PaginatedRunListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PaginatedRunListIterator) Response() PaginatedRunList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PaginatedRunListIterator) Value() Run {
	if !iter.page.NotDone() {
		return Run{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PaginatedRunListIterator type.
func NewPaginatedRunListIterator(page PaginatedRunListPage) PaginatedRunListIterator {
	return PaginatedRunListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (prl PaginatedRunList) IsEmpty() bool {
	return prl.Value == nil || len(*prl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (prl PaginatedRunList) hasNextLink() bool {
	return prl.NextLink != nil && len(*prl.NextLink) != 0
}

// paginatedRunListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (prl PaginatedRunList) paginatedRunListPreparer(ctx context.Context) (*http.Request, error) {
	if !prl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(prl.NextLink)))
}

// PaginatedRunListPage contains a page of Run values.
type PaginatedRunListPage struct {
	fn  func(context.Context, PaginatedRunList) (PaginatedRunList, error)
	prl PaginatedRunList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PaginatedRunListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedRunListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.prl)
		if err != nil {
			return err
		}
		page.prl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PaginatedRunListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PaginatedRunListPage) NotDone() bool {
	return !page.prl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PaginatedRunListPage) Response() PaginatedRunList {
	return page.prl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PaginatedRunListPage) Values() []Run {
	if page.prl.IsEmpty() {
		return nil
	}
	return *page.prl.Value
}

// Creates a new instance of the PaginatedRunListPage type.
func NewPaginatedRunListPage(cur PaginatedRunList, getNextPage func(context.Context, PaginatedRunList) (PaginatedRunList, error)) PaginatedRunListPage {
	return PaginatedRunListPage{
		fn:  getNextPage,
		prl: cur,
	}
}

// PaginatedRunMetricList a paginated list of RunMetrics.
type PaginatedRunMetricList struct {
	autorest.Response `json:"-"`
	// Value - An array of objects of type RunMetric.
	Value *[]RunMetric `json:"value,omitempty"`
	// ContinuationToken - The token used in retrieving the next page.  If null, there are no additional pages.
	ContinuationToken *string `json:"continuationToken,omitempty"`
	// NextLink - The link to the next page constructed using the continuationToken.  If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
}

// PaginatedRunMetricListIterator provides access to a complete listing of RunMetric values.
type PaginatedRunMetricListIterator struct {
	i    int
	page PaginatedRunMetricListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PaginatedRunMetricListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedRunMetricListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PaginatedRunMetricListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PaginatedRunMetricListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PaginatedRunMetricListIterator) Response() PaginatedRunMetricList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PaginatedRunMetricListIterator) Value() RunMetric {
	if !iter.page.NotDone() {
		return RunMetric{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PaginatedRunMetricListIterator type.
func NewPaginatedRunMetricListIterator(page PaginatedRunMetricListPage) PaginatedRunMetricListIterator {
	return PaginatedRunMetricListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (prml PaginatedRunMetricList) IsEmpty() bool {
	return prml.Value == nil || len(*prml.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (prml PaginatedRunMetricList) hasNextLink() bool {
	return prml.NextLink != nil && len(*prml.NextLink) != 0
}

// paginatedRunMetricListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (prml PaginatedRunMetricList) paginatedRunMetricListPreparer(ctx context.Context) (*http.Request, error) {
	if !prml.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(prml.NextLink)))
}

// PaginatedRunMetricListPage contains a page of RunMetric values.
type PaginatedRunMetricListPage struct {
	fn   func(context.Context, PaginatedRunMetricList) (PaginatedRunMetricList, error)
	prml PaginatedRunMetricList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PaginatedRunMetricListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedRunMetricListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.prml)
		if err != nil {
			return err
		}
		page.prml = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PaginatedRunMetricListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PaginatedRunMetricListPage) NotDone() bool {
	return !page.prml.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PaginatedRunMetricListPage) Response() PaginatedRunMetricList {
	return page.prml
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PaginatedRunMetricListPage) Values() []RunMetric {
	if page.prml.IsEmpty() {
		return nil
	}
	return *page.prml.Value
}

// Creates a new instance of the PaginatedRunMetricListPage type.
func NewPaginatedRunMetricListPage(cur PaginatedRunMetricList, getNextPage func(context.Context, PaginatedRunMetricList) (PaginatedRunMetricList, error)) PaginatedRunMetricListPage {
	return PaginatedRunMetricListPage{
		fn:   getNextPage,
		prml: cur,
	}
}

// PaginatedServiceList a paginated list of Services.
type PaginatedServiceList struct {
	autorest.Response `json:"-"`
	// Value - An array of objects of type Service.
	Value *[]BasicServiceResponseBase `json:"value,omitempty"`
	// NextLink - A continuation link (absolute URI) to the next page of results in the list.
	NextLink *string `json:"nextLink,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for PaginatedServiceList struct.
func (psl *PaginatedServiceList) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "value":
			if v != nil {
				value, err := unmarshalBasicServiceResponseBaseArray(*v)
				if err != nil {
					return err
				}
				psl.Value = &value
			}
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				psl.NextLink = &nextLink
			}
		}
	}

	return nil
}

// PaginatedServiceListIterator provides access to a complete listing of ServiceResponseBase values.
type PaginatedServiceListIterator struct {
	i    int
	page PaginatedServiceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PaginatedServiceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedServiceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PaginatedServiceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PaginatedServiceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PaginatedServiceListIterator) Response() PaginatedServiceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PaginatedServiceListIterator) Value() BasicServiceResponseBase {
	if !iter.page.NotDone() {
		return ServiceResponseBase{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PaginatedServiceListIterator type.
func NewPaginatedServiceListIterator(page PaginatedServiceListPage) PaginatedServiceListIterator {
	return PaginatedServiceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (psl PaginatedServiceList) IsEmpty() bool {
	return psl.Value == nil || len(*psl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (psl PaginatedServiceList) hasNextLink() bool {
	return psl.NextLink != nil && len(*psl.NextLink) != 0
}

// paginatedServiceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (psl PaginatedServiceList) paginatedServiceListPreparer(ctx context.Context) (*http.Request, error) {
	if !psl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(psl.NextLink)))
}

// PaginatedServiceListPage contains a page of BasicServiceResponseBase values.
type PaginatedServiceListPage struct {
	fn  func(context.Context, PaginatedServiceList) (PaginatedServiceList, error)
	psl PaginatedServiceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PaginatedServiceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedServiceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.psl)
		if err != nil {
			return err
		}
		page.psl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PaginatedServiceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PaginatedServiceListPage) NotDone() bool {
	return !page.psl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PaginatedServiceListPage) Response() PaginatedServiceList {
	return page.psl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PaginatedServiceListPage) Values() []BasicServiceResponseBase {
	if page.psl.IsEmpty() {
		return nil
	}
	return *page.psl.Value
}

// Creates a new instance of the PaginatedServiceListPage type.
func NewPaginatedServiceListPage(cur PaginatedServiceList, getNextPage func(context.Context, PaginatedServiceList) (PaginatedServiceList, error)) PaginatedServiceListPage {
	return PaginatedServiceListPage{
		fn:  getNextPage,
		psl: cur,
	}
}

// ProfileRequestBase the request for creating a profile.
type ProfileRequestBase struct {
	// Name - The profile name.
	Name *string `json:"name,omitempty"`
	// Description - The profile description.
	Description *string `json:"description,omitempty"`
	// InputData - The profile input data.
	InputData *string `json:"inputData,omitempty"`
	// KvTags - The tags dictionary.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The properties dictionary.
	Properties map[string]*string `json:"properties"`
}

// MarshalJSON is the custom marshaler for ProfileRequestBase.
func (prb ProfileRequestBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if prb.Name != nil {
		objectMap["name"] = prb.Name
	}
	if prb.Description != nil {
		objectMap["description"] = prb.Description
	}
	if prb.InputData != nil {
		objectMap["inputData"] = prb.InputData
	}
	if prb.KvTags != nil {
		objectMap["kvTags"] = prb.KvTags
	}
	if prb.Properties != nil {
		objectMap["properties"] = prb.Properties
	}
	return json.Marshal(objectMap)
}

// ProfileResponse the profile response.
type ProfileResponse struct {
	autorest.Response `json:"-"`
	// Name - The profile name.
	Name *string `json:"name,omitempty"`
	// Description - The profile description.
	Description *string `json:"description,omitempty"`
	// ImageID - The Image Id.
	ImageID *string `json:"imageId,omitempty"`
	// InputData - The input data.
	InputData *string `json:"inputData,omitempty"`
	// State - The state of the profile.
	State *string `json:"state,omitempty"`
	// CreatedTime - The profile creation time (UTC).
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// KvTags - The profile tags dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The profile properties dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// RecommendedMemoryInGB - The recommended amount of memory to allocate in GB.
	RecommendedMemoryInGB *float64 `json:"recommendedMemoryInGB,omitempty"`
	// RecommendedCPU - The recommended CPU allocation.
	RecommendedCPU *float64 `json:"recommendedCpu,omitempty"`
	// RecommendationLatencyInMs - Latency associated with the recommended memory/cpu config
	RecommendationLatencyInMs *float64 `json:"recommendationLatencyInMs,omitempty"`
	// ProfileRunResult - The profile run result.
	ProfileRunResult *string `json:"profileRunResult,omitempty"`
	// Error - The error details.
	Error *ModelErrorResponse `json:"error,omitempty"`
	// ProfilingErrorLogs - The profiling error logs.
	ProfilingErrorLogs *string `json:"profilingErrorLogs,omitempty"`
}

// MarshalJSON is the custom marshaler for ProfileResponse.
func (pr ProfileResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pr.Name != nil {
		objectMap["name"] = pr.Name
	}
	if pr.Description != nil {
		objectMap["description"] = pr.Description
	}
	if pr.ImageID != nil {
		objectMap["imageId"] = pr.ImageID
	}
	if pr.InputData != nil {
		objectMap["inputData"] = pr.InputData
	}
	if pr.State != nil {
		objectMap["state"] = pr.State
	}
	if pr.CreatedTime != nil {
		objectMap["createdTime"] = pr.CreatedTime
	}
	if pr.KvTags != nil {
		objectMap["kvTags"] = pr.KvTags
	}
	if pr.Properties != nil {
		objectMap["properties"] = pr.Properties
	}
	if pr.RecommendedMemoryInGB != nil {
		objectMap["recommendedMemoryInGB"] = pr.RecommendedMemoryInGB
	}
	if pr.RecommendedCPU != nil {
		objectMap["recommendedCpu"] = pr.RecommendedCPU
	}
	if pr.RecommendationLatencyInMs != nil {
		objectMap["recommendationLatencyInMs"] = pr.RecommendationLatencyInMs
	}
	if pr.ProfileRunResult != nil {
		objectMap["profileRunResult"] = pr.ProfileRunResult
	}
	if pr.Error != nil {
		objectMap["error"] = pr.Error
	}
	if pr.ProfilingErrorLogs != nil {
		objectMap["profilingErrorLogs"] = pr.ProfilingErrorLogs
	}
	return json.Marshal(objectMap)
}

// PythonSection ...
type PythonSection struct {
	// InterpreterPath - The python interpreter path. This is only used when user_managed_dependencies=True.
	InterpreterPath *string `json:"interpreterPath,omitempty"`
	// UserManagedDependencies - True means that AzureML reuses an existing python environment; False means that AzureML will create a python environment based on the Conda dependencies specification.
	UserManagedDependencies *bool       `json:"userManagedDependencies,omitempty"`
	CondaDependencies       interface{} `json:"condaDependencies,omitempty"`
	BaseCondaEnvironment    *string     `json:"baseCondaEnvironment,omitempty"`
}

// QueryParams the set of supported filters.
type QueryParams struct {
	// Filter - Allows for filtering the collection of resources.
	// The expression specified is evaluated for each resource in the collection, and only items where the expression evaluates to true are included in the response.
	// See https://docs.microsoft.com/en-us/azure/search/query-odata-filter-orderby-syntax for details on the expression syntax.
	Filter *string `json:"filter,omitempty"`
	// ContinuationToken - The continuation token to use for getting the next set of resources.
	ContinuationToken *string `json:"continuationToken,omitempty"`
	// OrderBy - The comma separated list of resource properties to use for sorting the requested resources.
	// Optionally, can be followed by either 'asc' or 'desc'
	OrderBy *string `json:"orderBy,omitempty"`
	// Top - The maximum number of items in the resource collection to be included in the result.
	// If not specified, all items are returned.
	Top *int32 `json:"top,omitempty"`
}

// ReadCloser ...
type ReadCloser struct {
	autorest.Response `json:"-"`
	Value             *io.ReadCloser `json:"value,omitempty"`
}

// RegenerateServiceKeysRequest ...
type RegenerateServiceKeysRequest struct {
	// KeyType - Specification for which type of key to generate.
	KeyType *int32 `json:"keyType,omitempty"`
	// KeyValue - The value the key is set to.
	KeyValue *string `json:"keyValue,omitempty"`
}

// RegistryInfo contains registry information.
type RegistryInfo struct {
	// User - The user.
	User *string `json:"user,omitempty"`
	// Location - The location.
	Location *string `json:"location,omitempty"`
	// Password - The password.
	Password *string `json:"password,omitempty"`
}

// RootError the root error.
type RootError struct {
	// Code - The service-defined error code. Supported error codes: ServiceError, UserError, ValidationError, AzureStorageError, TransientError, RequestThrottled.
	Code *string `json:"code,omitempty"`
	// Message - A human-readable representation of the error.
	Message *string `json:"message,omitempty"`
	// Target - The target of the error (e.g., the name of the property in error).
	Target *string `json:"target,omitempty"`
	// Details - The related errors that occurred during the request.
	Details *[]ErrorDetails `json:"details,omitempty"`
	// InnerError - A nested list of inner errors. When evaluating errors, clients MUST traverse through all of the nested “innerErrors” and choose the deepest one that they understand.
	InnerError *InnerErrorResponse `json:"innerError,omitempty"`
}

// Run the definition of a Run.
type Run struct {
	autorest.Response `json:"-"`
	RunNumber         *int32  `json:"runNumber,omitempty"`
	RootRunID         *string `json:"rootRunId,omitempty"`
	// ExperimentID - The Id of the experiment that created this run.
	ExperimentID *string `json:"experimentId,omitempty"`
	// CreatedUtc - The time the run was created in UTC.
	CreatedUtc *date.Time `json:"createdUtc,omitempty"`
	// CreatedBy - The details of the user who created the run.
	CreatedBy *CreatedBy `json:"createdBy,omitempty"`
	// UserID - The Id of the user that created the run.
	UserID *string `json:"userId,omitempty"`
	// Token - A token used for authenticating a run.
	Token *string `json:"token,omitempty"`
	// TokenExpiryTimeUtc - The Token expiration time in UTC.
	TokenExpiryTimeUtc *date.Time `json:"tokenExpiryTimeUtc,omitempty"`
	// Error - If an error occurred during the run, this will be populated.
	Error *ErrorResponse `json:"error,omitempty"`
	// Warnings - A list of warnings that occurred during the run.
	Warnings *[]RunDetailsWarning `json:"warnings,omitempty"`
	Revision *int32               `json:"revision,omitempty"`
	// RunID - The identifier for the run. Run IDs must be less than 256 characters and contain only alphanumeric characters with dashes and underscores.
	RunID *string `json:"runId,omitempty"`
	// ParentRunID - The parent of the run if the run is hierarchical; otherwise, Null.
	ParentRunID *string `json:"parentRunId,omitempty"`
	// Status - The status of the run. The Status string value maps to the RunStatus Enum.
	Status *string `json:"status,omitempty"`
	// StartTimeUtc - The start time of the run in UTC.
	StartTimeUtc *date.Time `json:"startTimeUtc,omitempty"`
	// EndTimeUtc - The end time of the run in UTC.
	EndTimeUtc       *date.Time         `json:"endTimeUtc,omitempty"`
	HeartbeatEnabled *bool              `json:"heartbeatEnabled,omitempty"`
	Options          *RunOptions        `json:"options,omitempty"`
	Name             *string            `json:"name,omitempty"`
	DataContainerID  *string            `json:"dataContainerId,omitempty"`
	Description      *string            `json:"description,omitempty"`
	Hidden           *bool              `json:"hidden,omitempty"`
	RunType          *string            `json:"runType,omitempty"`
	Properties       map[string]*string `json:"properties"`
	ScriptName       *string            `json:"scriptName,omitempty"`
	Target           *string            `json:"target,omitempty"`
	Tags             map[string]*string `json:"tags"`
	RunDefinition    interface{}        `json:"runDefinition,omitempty"`
	CreatedFrom      *CreatedFrom       `json:"createdFrom,omitempty"`
	CancelURI        *string            `json:"cancelUri,omitempty"`
	DiagnosticsURI   *string            `json:"diagnosticsUri,omitempty"`
}

// MarshalJSON is the custom marshaler for Run.
func (r Run) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.RunNumber != nil {
		objectMap["runNumber"] = r.RunNumber
	}
	if r.RootRunID != nil {
		objectMap["rootRunId"] = r.RootRunID
	}
	if r.ExperimentID != nil {
		objectMap["experimentId"] = r.ExperimentID
	}
	if r.CreatedUtc != nil {
		objectMap["createdUtc"] = r.CreatedUtc
	}
	if r.CreatedBy != nil {
		objectMap["createdBy"] = r.CreatedBy
	}
	if r.UserID != nil {
		objectMap["userId"] = r.UserID
	}
	if r.Token != nil {
		objectMap["token"] = r.Token
	}
	if r.TokenExpiryTimeUtc != nil {
		objectMap["tokenExpiryTimeUtc"] = r.TokenExpiryTimeUtc
	}
	if r.Error != nil {
		objectMap["error"] = r.Error
	}
	if r.Warnings != nil {
		objectMap["warnings"] = r.Warnings
	}
	if r.Revision != nil {
		objectMap["revision"] = r.Revision
	}
	if r.RunID != nil {
		objectMap["runId"] = r.RunID
	}
	if r.ParentRunID != nil {
		objectMap["parentRunId"] = r.ParentRunID
	}
	if r.Status != nil {
		objectMap["status"] = r.Status
	}
	if r.StartTimeUtc != nil {
		objectMap["startTimeUtc"] = r.StartTimeUtc
	}
	if r.EndTimeUtc != nil {
		objectMap["endTimeUtc"] = r.EndTimeUtc
	}
	if r.HeartbeatEnabled != nil {
		objectMap["heartbeatEnabled"] = r.HeartbeatEnabled
	}
	if r.Options != nil {
		objectMap["options"] = r.Options
	}
	if r.Name != nil {
		objectMap["name"] = r.Name
	}
	if r.DataContainerID != nil {
		objectMap["dataContainerId"] = r.DataContainerID
	}
	if r.Description != nil {
		objectMap["description"] = r.Description
	}
	if r.Hidden != nil {
		objectMap["hidden"] = r.Hidden
	}
	if r.RunType != nil {
		objectMap["runType"] = r.RunType
	}
	if r.Properties != nil {
		objectMap["properties"] = r.Properties
	}
	if r.ScriptName != nil {
		objectMap["scriptName"] = r.ScriptName
	}
	if r.Target != nil {
		objectMap["target"] = r.Target
	}
	if r.Tags != nil {
		objectMap["tags"] = r.Tags
	}
	if r.RunDefinition != nil {
		objectMap["runDefinition"] = r.RunDefinition
	}
	if r.CreatedFrom != nil {
		objectMap["createdFrom"] = r.CreatedFrom
	}
	if r.CancelURI != nil {
		objectMap["cancelUri"] = r.CancelURI
	}
	if r.DiagnosticsURI != nil {
		objectMap["diagnosticsUri"] = r.DiagnosticsURI
	}
	return json.Marshal(objectMap)
}

// RunConfiguration ...
type RunConfiguration struct {
	// Script - The relative path to the python script file. The file path is relative to the source_directory passed to submit run.
	Script *string `json:"script,omitempty"`
	// Arguments - Command line arguments for the python script file.
	Arguments *[]string `json:"arguments,omitempty"`
	// Framework - The supported frameworks are Python, PySpark, CNTK, TensorFlow, and PyTorch. Use Tensorflow for AmlCompute clusters, and Python for distributed training jobs. Possible values include: 'Python', 'PySpark', 'Cntk', 'TensorFlow', 'PyTorch'
	Framework Framework `json:"framework,omitempty"`
	// Communicator - The supported communicators are None, ParameterServer, OpenMpi, and IntelMpi Keep in mind that OpenMpi requires a custom image with OpenMpi installed.
	// Use ParameterServer or OpenMpi for AmlCompute clusters. Use IntelMpi for distributed training jobs. Possible values include: 'None', 'ParameterServer', 'Gloo', 'Mpi', 'Nccl'
	Communicator Communicator `json:"communicator,omitempty"`
	// Target - Target refers to compute where the job is scheduled for execution. The default target is "local" referring to the local machine.
	Target *string `json:"target,omitempty"`
	// DataReferences - All the data sources are made available to the run during execution based on each configuration.
	DataReferences map[string]*DataReferenceConfiguration `json:"dataReferences"`
	// JobName - This is primarily intended for notebooks to override the default job name.
	// Defaults to ArgumentVector[0] if not specified.
	JobName *string `json:"jobName,omitempty"`
	// MaxRunDurationSeconds - Maximum allowed time for the run. The system will attempt to automatically cancel the run if it took longer than this value.
	// MaxRunDurationSeconds=null means infinite duration.
	MaxRunDurationSeconds *int64 `json:"maxRunDurationSeconds,omitempty"`
	// NodeCount - Number of compute nodes to run the job on. Only applies to AMLCompute.
	NodeCount *int32 `json:"nodeCount,omitempty"`
	// Environment - The environment definition, This field configures the python environment.
	// It can be configured to use an existing Python environment or configured to setup a temp environment for the experiment.
	// The definition is also responsible for setting the required application dependencies.
	Environment *EnvironmentDefinition `json:"environment,omitempty"`
	// History - This section is used to disable and enable experiment history logging features.
	History *HistoryConfiguration `json:"history,omitempty"`
	// Spark - When the platform is set to Pyspark, The spark configuration is used to set the default sparkconf for the submitted job.
	Spark *SparkConfiguration `json:"spark,omitempty"`
	// Tensorflow - The attribute is used to configure the distributed tensorflow parameters.
	// This attribute takes effect only when the framework is set to TensorFlow, and the communicator to ParameterServer.
	// AmlCompute is the only supported compute for this configuration.
	Tensorflow *TensorflowConfiguration `json:"tensorflow,omitempty"`
	// Mpi - The attribute is used to configure the distributed MPI job parameters.
	// This attribute takes effect only when the framework is set to Python, and the communicator to OpenMpi or IntelMpi.
	// AmlCompute is the only supported compute type for this configuration.
	Mpi *MpiConfiguration `json:"mpi,omitempty"`
	// Hdi - This attribute takes effect only when the target is set to an Azure HDI compute.
	// The HDI Configuration is used to set the YARN deployment mode. It is defaulted to cluster mode.
	Hdi *HdiConfiguration `json:"hdi,omitempty"`
}

// MarshalJSON is the custom marshaler for RunConfiguration.
func (rc RunConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rc.Script != nil {
		objectMap["script"] = rc.Script
	}
	if rc.Arguments != nil {
		objectMap["arguments"] = rc.Arguments
	}
	if rc.Framework != "" {
		objectMap["framework"] = rc.Framework
	}
	if rc.Communicator != "" {
		objectMap["communicator"] = rc.Communicator
	}
	if rc.Target != nil {
		objectMap["target"] = rc.Target
	}
	if rc.DataReferences != nil {
		objectMap["dataReferences"] = rc.DataReferences
	}
	if rc.JobName != nil {
		objectMap["jobName"] = rc.JobName
	}
	if rc.MaxRunDurationSeconds != nil {
		objectMap["maxRunDurationSeconds"] = rc.MaxRunDurationSeconds
	}
	if rc.NodeCount != nil {
		objectMap["nodeCount"] = rc.NodeCount
	}
	if rc.Environment != nil {
		objectMap["environment"] = rc.Environment
	}
	if rc.History != nil {
		objectMap["history"] = rc.History
	}
	if rc.Spark != nil {
		objectMap["spark"] = rc.Spark
	}
	if rc.Tensorflow != nil {
		objectMap["tensorflow"] = rc.Tensorflow
	}
	if rc.Mpi != nil {
		objectMap["mpi"] = rc.Mpi
	}
	if rc.Hdi != nil {
		objectMap["hdi"] = rc.Hdi
	}
	return json.Marshal(objectMap)
}

// RunDefinition ...
type RunDefinition struct {
	// Configuration - Fully specified configuration information for the run. Even when that information
	// is contained in configuration files within the project folder, the client collapses
	// it all and inlines it into the run definition when submitting a run.
	Configuration *RunConfiguration `json:"configuration,omitempty"`
	// SnapshotID - Snapshots are user project folders that have been uploaded to the cloud for subsequent
	// execution. This field is required when executing against cloud-based compute targets
	// unless the run submission was against the API endpoint that takes a zipped project folder
	// inline with the request.
	SnapshotID *uuid.UUID `json:"snapshotId,omitempty"`
	// ParentRunID - Specifies that the run history entry for this execution should be scoped within
	// an existing run as a child. Defaults to null, meaning the run has no parent.
	// This is intended for first-party service integration, not third-party API users.
	ParentRunID *string `json:"parentRunId,omitempty"`
	// RunType - Specifies the runsource property for this run. The default value is "experiment" if not specified.
	RunType *string `json:"runType,omitempty"`
}

// RunDetails the details of the run.
type RunDetails struct {
	autorest.Response `json:"-"`
	// RunID - The identifier for the run.
	RunID *string `json:"runId,omitempty"`
	// Target - The name of the compute target where the run is executed.
	Target *string `json:"target,omitempty"`
	// Status - The status of the run. The Status string value maps to the RunStatus Enum.
	Status *string `json:"status,omitempty"`
	// ParentRunID - The parent of the run if the run is hierarchical.
	ParentRunID *string `json:"parentRunId,omitempty"`
	// StartTimeUtc - The start time of the run in UTC.
	StartTimeUtc *date.Time `json:"startTimeUtc,omitempty"`
	// EndTimeUtc - The end time of the run in UTC.
	EndTimeUtc *date.Time `json:"endTimeUtc,omitempty"`
	// Error - If an error occurred during the run, this will be populated.
	Error *ErrorResponse `json:"error,omitempty"`
	// Warnings - A list of warnings that occurred during the run.
	Warnings *[]RunDetailsWarning `json:"warnings,omitempty"`
	// Tags - The tag dictionary for the run. Tags are mutable.
	Tags map[string]*string `json:"tags"`
	// Properties - The properties dictionary for the run. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// RunDefinition - The run definition specification.
	RunDefinition interface{}        `json:"runDefinition,omitempty"`
	LogFiles      map[string]*string `json:"logFiles"`
	Revision      *int32             `json:"revision,omitempty"`
}

// MarshalJSON is the custom marshaler for RunDetails.
func (rd RunDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rd.RunID != nil {
		objectMap["runId"] = rd.RunID
	}
	if rd.Target != nil {
		objectMap["target"] = rd.Target
	}
	if rd.Status != nil {
		objectMap["status"] = rd.Status
	}
	if rd.ParentRunID != nil {
		objectMap["parentRunId"] = rd.ParentRunID
	}
	if rd.StartTimeUtc != nil {
		objectMap["startTimeUtc"] = rd.StartTimeUtc
	}
	if rd.EndTimeUtc != nil {
		objectMap["endTimeUtc"] = rd.EndTimeUtc
	}
	if rd.Error != nil {
		objectMap["error"] = rd.Error
	}
	if rd.Warnings != nil {
		objectMap["warnings"] = rd.Warnings
	}
	if rd.Tags != nil {
		objectMap["tags"] = rd.Tags
	}
	if rd.Properties != nil {
		objectMap["properties"] = rd.Properties
	}
	if rd.RunDefinition != nil {
		objectMap["runDefinition"] = rd.RunDefinition
	}
	if rd.LogFiles != nil {
		objectMap["logFiles"] = rd.LogFiles
	}
	if rd.Revision != nil {
		objectMap["revision"] = rd.Revision
	}
	return json.Marshal(objectMap)
}

// RunDetailsWarning ...
type RunDetailsWarning struct {
	Source  *string `json:"source,omitempty"`
	Message *string `json:"message,omitempty"`
}

// RunMetric ...
type RunMetric struct {
	autorest.Response `json:"-"`
	RunID             *string                   `json:"runId,omitempty"`
	MetricID          *uuid.UUID                `json:"metricId,omitempty"`
	DataContainerID   *string                   `json:"dataContainerId,omitempty"`
	MetricType        *string                   `json:"metricType,omitempty"`
	CreatedUtc        *date.Time                `json:"createdUtc,omitempty"`
	Name              *string                   `json:"name,omitempty"`
	Description       *string                   `json:"description,omitempty"`
	Label             *string                   `json:"label,omitempty"`
	NumCells          *int32                    `json:"numCells,omitempty"`
	DataLocation      *string                   `json:"dataLocation,omitempty"`
	Cells             *[]map[string]interface{} `json:"cells,omitempty"`
	Schema            *MetricSchema             `json:"schema,omitempty"`
}

// RunOptions ...
type RunOptions struct {
	GenerateDataContainerIDIfNotSpecified *bool `json:"generateDataContainerIdIfNotSpecified,omitempty"`
}

// BasicServiceResponseBase the base service response. The correct inherited response based on computeType will be
// returned (ex. ACIServiceResponse)
type BasicServiceResponseBase interface {
	AsACIServiceResponse() (*ACIServiceResponse, bool)
	AsAKSServiceResponse() (*AKSServiceResponse, bool)
	AsAKSEndpointResponse() (*AKSEndpointResponse, bool)
	AsAKSVariantResponse() (*AKSVariantResponse, bool)
	AsBasicAKSVariantResponse() (BasicAKSVariantResponse, bool)
	AsBatchServiceResponse() (*BatchServiceResponse, bool)
	AsIotServiceResponse() (*IotServiceResponse, bool)
	AsUnknownServiceResponse() (*UnknownServiceResponse, bool)
	AsServiceResponseBase() (*ServiceResponseBase, bool)
}

// ServiceResponseBase the base service response. The correct inherited response based on computeType will be
// returned (ex. ACIServiceResponse)
type ServiceResponseBase struct {
	autorest.Response `json:"-"`
	// ID - The service Id.
	ID *string `json:"id,omitempty"`
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The service description.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service property dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// OperationID - The ID of the latest asynchronous operation for this service.
	OperationID *string `json:"operationId,omitempty"`
	// State - The current state of the service. Possible values include: 'WebServiceStateTransitioning', 'WebServiceStateHealthy', 'WebServiceStateUnhealthy', 'WebServiceStateFailed'
	State WebServiceState `json:"state,omitempty"`
	// CreatedTime - The time the service was created.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// UpdatedTime - The time the service was updated.
	UpdatedTime *date.Time `json:"updatedTime,omitempty"`
	// Error - The error details.
	Error *ModelErrorResponse `json:"error,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeServiceResponseBase', 'ComputeTypeACI', 'ComputeTypeAKS', 'ComputeTypeAKSENDPOINT', 'ComputeTypeAKSVariantResponse', 'ComputeTypeAMLCOMPUTE', 'ComputeTypeIOT', 'ComputeTypeUNKNOWON'
	ComputeType ComputeType `json:"computeType,omitempty"`
}

func unmarshalBasicServiceResponseBase(body []byte) (BasicServiceResponseBase, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["computeType"] {
	case string(ComputeTypeACI):
		var asr ACIServiceResponse
		err := json.Unmarshal(body, &asr)
		return asr, err
	case string(ComputeTypeAKS):
		var asr AKSServiceResponse
		err := json.Unmarshal(body, &asr)
		return asr, err
	case string(ComputeTypeAKSENDPOINT):
		var aer AKSEndpointResponse
		err := json.Unmarshal(body, &aer)
		return aer, err
	case string(ComputeTypeAKSVariantResponse):
		var avr AKSVariantResponse
		err := json.Unmarshal(body, &avr)
		return avr, err
	case string(ComputeTypeAMLCOMPUTE):
		var bsr BatchServiceResponse
		err := json.Unmarshal(body, &bsr)
		return bsr, err
	case string(ComputeTypeIOT):
		var isr IotServiceResponse
		err := json.Unmarshal(body, &isr)
		return isr, err
	case string(ComputeTypeUNKNOWON):
		var usr UnknownServiceResponse
		err := json.Unmarshal(body, &usr)
		return usr, err
	default:
		var srb ServiceResponseBase
		err := json.Unmarshal(body, &srb)
		return srb, err
	}
}
func unmarshalBasicServiceResponseBaseArray(body []byte) ([]BasicServiceResponseBase, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	srbArray := make([]BasicServiceResponseBase, len(rawMessages))

	for index, rawMessage := range rawMessages {
		srb, err := unmarshalBasicServiceResponseBase(*rawMessage)
		if err != nil {
			return nil, err
		}
		srbArray[index] = srb
	}
	return srbArray, nil
}

// MarshalJSON is the custom marshaler for ServiceResponseBase.
func (srb ServiceResponseBase) MarshalJSON() ([]byte, error) {
	srb.ComputeType = ComputeTypeServiceResponseBase
	objectMap := make(map[string]interface{})
	if srb.ID != nil {
		objectMap["id"] = srb.ID
	}
	if srb.Name != nil {
		objectMap["name"] = srb.Name
	}
	if srb.Description != nil {
		objectMap["description"] = srb.Description
	}
	if srb.KvTags != nil {
		objectMap["kvTags"] = srb.KvTags
	}
	if srb.Properties != nil {
		objectMap["properties"] = srb.Properties
	}
	if srb.OperationID != nil {
		objectMap["operationId"] = srb.OperationID
	}
	if srb.State != "" {
		objectMap["state"] = srb.State
	}
	if srb.CreatedTime != nil {
		objectMap["createdTime"] = srb.CreatedTime
	}
	if srb.UpdatedTime != nil {
		objectMap["updatedTime"] = srb.UpdatedTime
	}
	if srb.Error != nil {
		objectMap["error"] = srb.Error
	}
	if srb.DeploymentType != "" {
		objectMap["deploymentType"] = srb.DeploymentType
	}
	if srb.ComputeType != "" {
		objectMap["computeType"] = srb.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceResponse is the BasicServiceResponseBase implementation for ServiceResponseBase.
func (srb ServiceResponseBase) AsACIServiceResponse() (*ACIServiceResponse, bool) {
	return nil, false
}

// AsAKSServiceResponse is the BasicServiceResponseBase implementation for ServiceResponseBase.
func (srb ServiceResponseBase) AsAKSServiceResponse() (*AKSServiceResponse, bool) {
	return nil, false
}

// AsAKSEndpointResponse is the BasicServiceResponseBase implementation for ServiceResponseBase.
func (srb ServiceResponseBase) AsAKSEndpointResponse() (*AKSEndpointResponse, bool) {
	return nil, false
}

// AsAKSVariantResponse is the BasicServiceResponseBase implementation for ServiceResponseBase.
func (srb ServiceResponseBase) AsAKSVariantResponse() (*AKSVariantResponse, bool) {
	return nil, false
}

// AsBasicAKSVariantResponse is the BasicServiceResponseBase implementation for ServiceResponseBase.
func (srb ServiceResponseBase) AsBasicAKSVariantResponse() (BasicAKSVariantResponse, bool) {
	return nil, false
}

// AsBatchServiceResponse is the BasicServiceResponseBase implementation for ServiceResponseBase.
func (srb ServiceResponseBase) AsBatchServiceResponse() (*BatchServiceResponse, bool) {
	return nil, false
}

// AsIotServiceResponse is the BasicServiceResponseBase implementation for ServiceResponseBase.
func (srb ServiceResponseBase) AsIotServiceResponse() (*IotServiceResponse, bool) {
	return nil, false
}

// AsUnknownServiceResponse is the BasicServiceResponseBase implementation for ServiceResponseBase.
func (srb ServiceResponseBase) AsUnknownServiceResponse() (*UnknownServiceResponse, bool) {
	return nil, false
}

// AsServiceResponseBase is the BasicServiceResponseBase implementation for ServiceResponseBase.
func (srb ServiceResponseBase) AsServiceResponseBase() (*ServiceResponseBase, bool) {
	return &srb, true
}

// AsBasicServiceResponseBase is the BasicServiceResponseBase implementation for ServiceResponseBase.
func (srb ServiceResponseBase) AsBasicServiceResponseBase() (BasicServiceResponseBase, bool) {
	return &srb, true
}

// ServiceResponseBaseModel ...
type ServiceResponseBaseModel struct {
	autorest.Response `json:"-"`
	Value             BasicServiceResponseBase `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ServiceResponseBaseModel struct.
func (srbm *ServiceResponseBaseModel) UnmarshalJSON(body []byte) error {
	srb, err := unmarshalBasicServiceResponseBase(body)
	if err != nil {
		return err
	}
	srbm.Value = srb

	return nil
}

// SparkConfiguration ...
type SparkConfiguration struct {
	Configuration map[string]*string `json:"configuration"`
}

// MarshalJSON is the custom marshaler for SparkConfiguration.
func (sc SparkConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sc.Configuration != nil {
		objectMap["configuration"] = sc.Configuration
	}
	return json.Marshal(objectMap)
}

// SparkMavenPackage ...
type SparkMavenPackage struct {
	Group    *string `json:"group,omitempty"`
	Artifact *string `json:"artifact,omitempty"`
	Version  *string `json:"version,omitempty"`
}

// SparkSection ...
type SparkSection struct {
	// Repositories - The list of spark repositories.
	Repositories *[]string `json:"repositories,omitempty"`
	// Packages - The Spark packages to use.
	Packages *[]SparkMavenPackage `json:"packages,omitempty"`
	// PrecachePackages - Whether to precache the packages.
	PrecachePackages *bool `json:"precachePackages,omitempty"`
}

// SQLDataPath ...
type SQLDataPath struct {
	SQLTableName             *string                     `json:"sqlTableName,omitempty"`
	SQLQuery                 *string                     `json:"sqlQuery,omitempty"`
	SQLStoredProcedureName   *string                     `json:"sqlStoredProcedureName,omitempty"`
	SQLStoredProcedureParams *[]StoredProcedureParameter `json:"sqlStoredProcedureParams,omitempty"`
}

// StartRunResult contains the details of a run.
type StartRunResult struct {
	autorest.Response `json:"-"`
	// RunID - The identifier for a run.
	RunID *string `json:"runId,omitempty"`
}

// StoredProcedureParameter ...
type StoredProcedureParameter struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
	// Type - Possible values include: 'StoredProcedureParameterTypeString', 'StoredProcedureParameterTypeInt', 'StoredProcedureParameterTypeDecimal', 'StoredProcedureParameterTypeGUID', 'StoredProcedureParameterTypeBoolean', 'StoredProcedureParameterTypeDate'
	Type StoredProcedureParameterType `json:"type,omitempty"`
}

// String ...
type String struct {
	autorest.Response `json:"-"`
	Value             *string `json:"value,omitempty"`
}

// TargetRuntime the target runtime.
type TargetRuntime struct {
	// TargetArchitecture - The target architecture. Possible values include: 'Amd64', 'Arm32v7'
	TargetArchitecture ArchitectureType `json:"targetArchitecture,omitempty"`
	// OsType - The target operating system. Possible values include: 'Linux', 'Windows'
	OsType OSType `json:"osType,omitempty"`
	// RuntimeType - The target runtime type. Possible values include: 'RuntimeTypeSparkPython', 'RuntimeTypeTlc37', 'RuntimeTypeTlc38', 'RuntimeTypeTlc310', 'RuntimeTypePython', 'RuntimeTypePythonSlim', 'RuntimeTypePythonCustom'
	RuntimeType RuntimeType `json:"runtimeType,omitempty"`
	// Properties - READ-ONLY; The properties dictionary.
	Properties map[string]*string `json:"properties"`
}

// MarshalJSON is the custom marshaler for TargetRuntime.
func (tr TargetRuntime) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.TargetArchitecture != "" {
		objectMap["targetArchitecture"] = tr.TargetArchitecture
	}
	if tr.OsType != "" {
		objectMap["osType"] = tr.OsType
	}
	if tr.RuntimeType != "" {
		objectMap["runtimeType"] = tr.RuntimeType
	}
	return json.Marshal(objectMap)
}

// TensorflowConfiguration ...
type TensorflowConfiguration struct {
	// WorkerCount - The number of workers.
	WorkerCount *int32 `json:"workerCount,omitempty"`
	// ParameterServerCount - Number of parameter servers.
	ParameterServerCount *int32 `json:"parameterServerCount,omitempty"`
}

// UnknownServiceResponse the response for an unsupported Service
// Defines the basic service properties
type UnknownServiceResponse struct {
	// ID - The service Id.
	ID *string `json:"id,omitempty"`
	// Name - The service name.
	Name *string `json:"name,omitempty"`
	// Description - The service description.
	Description *string `json:"description,omitempty"`
	// KvTags - The service tag dictionary. Tags are mutable.
	KvTags map[string]*string `json:"kvTags"`
	// Properties - The service property dictionary. Properties are immutable.
	Properties map[string]*string `json:"properties"`
	// OperationID - The ID of the latest asynchronous operation for this service.
	OperationID *string `json:"operationId,omitempty"`
	// State - The current state of the service. Possible values include: 'WebServiceStateTransitioning', 'WebServiceStateHealthy', 'WebServiceStateUnhealthy', 'WebServiceStateFailed'
	State WebServiceState `json:"state,omitempty"`
	// CreatedTime - The time the service was created.
	CreatedTime *date.Time `json:"createdTime,omitempty"`
	// UpdatedTime - The time the service was updated.
	UpdatedTime *date.Time `json:"updatedTime,omitempty"`
	// Error - The error details.
	Error *ModelErrorResponse `json:"error,omitempty"`
	// DeploymentType - The deployment type for the service. Possible values include: 'GRPCRealtimeEndpoint', 'HTTPRealtimeEndpoint', 'Batch'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeServiceResponseBase', 'ComputeTypeACI', 'ComputeTypeAKS', 'ComputeTypeAKSENDPOINT', 'ComputeTypeAKSVariantResponse', 'ComputeTypeAMLCOMPUTE', 'ComputeTypeIOT', 'ComputeTypeUNKNOWON'
	ComputeType ComputeType `json:"computeType,omitempty"`
}

// MarshalJSON is the custom marshaler for UnknownServiceResponse.
func (usr UnknownServiceResponse) MarshalJSON() ([]byte, error) {
	usr.ComputeType = ComputeTypeUNKNOWON
	objectMap := make(map[string]interface{})
	if usr.ID != nil {
		objectMap["id"] = usr.ID
	}
	if usr.Name != nil {
		objectMap["name"] = usr.Name
	}
	if usr.Description != nil {
		objectMap["description"] = usr.Description
	}
	if usr.KvTags != nil {
		objectMap["kvTags"] = usr.KvTags
	}
	if usr.Properties != nil {
		objectMap["properties"] = usr.Properties
	}
	if usr.OperationID != nil {
		objectMap["operationId"] = usr.OperationID
	}
	if usr.State != "" {
		objectMap["state"] = usr.State
	}
	if usr.CreatedTime != nil {
		objectMap["createdTime"] = usr.CreatedTime
	}
	if usr.UpdatedTime != nil {
		objectMap["updatedTime"] = usr.UpdatedTime
	}
	if usr.Error != nil {
		objectMap["error"] = usr.Error
	}
	if usr.DeploymentType != "" {
		objectMap["deploymentType"] = usr.DeploymentType
	}
	if usr.ComputeType != "" {
		objectMap["computeType"] = usr.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsACIServiceResponse is the BasicServiceResponseBase implementation for UnknownServiceResponse.
func (usr UnknownServiceResponse) AsACIServiceResponse() (*ACIServiceResponse, bool) {
	return nil, false
}

// AsAKSServiceResponse is the BasicServiceResponseBase implementation for UnknownServiceResponse.
func (usr UnknownServiceResponse) AsAKSServiceResponse() (*AKSServiceResponse, bool) {
	return nil, false
}

// AsAKSEndpointResponse is the BasicServiceResponseBase implementation for UnknownServiceResponse.
func (usr UnknownServiceResponse) AsAKSEndpointResponse() (*AKSEndpointResponse, bool) {
	return nil, false
}

// AsAKSVariantResponse is the BasicServiceResponseBase implementation for UnknownServiceResponse.
func (usr UnknownServiceResponse) AsAKSVariantResponse() (*AKSVariantResponse, bool) {
	return nil, false
}

// AsBasicAKSVariantResponse is the BasicServiceResponseBase implementation for UnknownServiceResponse.
func (usr UnknownServiceResponse) AsBasicAKSVariantResponse() (BasicAKSVariantResponse, bool) {
	return nil, false
}

// AsBatchServiceResponse is the BasicServiceResponseBase implementation for UnknownServiceResponse.
func (usr UnknownServiceResponse) AsBatchServiceResponse() (*BatchServiceResponse, bool) {
	return nil, false
}

// AsIotServiceResponse is the BasicServiceResponseBase implementation for UnknownServiceResponse.
func (usr UnknownServiceResponse) AsIotServiceResponse() (*IotServiceResponse, bool) {
	return nil, false
}

// AsUnknownServiceResponse is the BasicServiceResponseBase implementation for UnknownServiceResponse.
func (usr UnknownServiceResponse) AsUnknownServiceResponse() (*UnknownServiceResponse, bool) {
	return &usr, true
}

// AsServiceResponseBase is the BasicServiceResponseBase implementation for UnknownServiceResponse.
func (usr UnknownServiceResponse) AsServiceResponseBase() (*ServiceResponseBase, bool) {
	return nil, false
}

// AsBasicServiceResponseBase is the BasicServiceResponseBase implementation for UnknownServiceResponse.
func (usr UnknownServiceResponse) AsBasicServiceResponseBase() (BasicServiceResponseBase, bool) {
	return &usr, true
}
