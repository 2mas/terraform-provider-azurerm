package machinelearningservices

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
	"github.com/gofrs/uuid"
	"net/http"
)

// ArtifactsClient is the these APIs allow end users to manage Azure Machine Learning Services.
type ArtifactsClient struct {
	BaseClient
}

// NewArtifactsClient creates an instance of the ArtifactsClient client.
func NewArtifactsClient() ArtifactsClient {
	return NewArtifactsClientWithBaseURI(DefaultBaseURI)
}

// NewArtifactsClientWithBaseURI creates an instance of the ArtifactsClient client using a custom endpoint.  Use this
// when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
func NewArtifactsClientWithBaseURI(baseURI string) ArtifactsClient {
	return ArtifactsClient{NewWithBaseURI(baseURI)}
}

// BatchCreateEmptyArtifacts create a Batch of empty Artifacts from the supplied paths.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// artifactPaths - the list of Artifact paths to create.
func (client ArtifactsClient) BatchCreateEmptyArtifacts(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, artifactPaths ArtifactPathList) (result BatchArtifactContentInformationResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.BatchCreateEmptyArtifacts")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: artifactPaths,
			Constraints: []validation.Constraint{{Target: "artifactPaths.Paths", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.ArtifactsClient", "BatchCreateEmptyArtifacts", err.Error())
	}

	req, err := client.BatchCreateEmptyArtifactsPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, artifactPaths)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "BatchCreateEmptyArtifacts", nil, "Failure preparing request")
		return
	}

	resp, err := client.BatchCreateEmptyArtifactsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "BatchCreateEmptyArtifacts", resp, "Failure sending request")
		return
	}

	result, err = client.BatchCreateEmptyArtifactsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "BatchCreateEmptyArtifacts", resp, "Failure responding to request")
		return
	}

	return
}

// BatchCreateEmptyArtifactsPreparer prepares the BatchCreateEmptyArtifacts request.
func (client ArtifactsClient) BatchCreateEmptyArtifactsPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, artifactPaths ArtifactPathList) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}/batch/metadata", pathParameters),
		autorest.WithJSON(artifactPaths))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// BatchCreateEmptyArtifactsSender sends the BatchCreateEmptyArtifacts request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) BatchCreateEmptyArtifactsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// BatchCreateEmptyArtifactsResponder handles the response to the BatchCreateEmptyArtifacts request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) BatchCreateEmptyArtifactsResponder(resp *http.Response) (result BatchArtifactContentInformationResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// BatchGetByID get Batch Artifacts by the specific Ids.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// artifactIds - the command for Batch Artifact get request.
func (client ArtifactsClient) BatchGetByID(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, artifactIds ArtifactIDList) (result BatchArtifactContentInformationResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.BatchGetByID")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: artifactIds,
			Constraints: []validation.Constraint{{Target: "artifactIds.ArtifactIds", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.ArtifactsClient", "BatchGetByID", err.Error())
	}

	req, err := client.BatchGetByIDPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, artifactIds)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "BatchGetByID", nil, "Failure preparing request")
		return
	}

	resp, err := client.BatchGetByIDSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "BatchGetByID", resp, "Failure sending request")
		return
	}

	result, err = client.BatchGetByIDResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "BatchGetByID", resp, "Failure responding to request")
		return
	}

	return
}

// BatchGetByIDPreparer prepares the BatchGetByID request.
func (client ArtifactsClient) BatchGetByIDPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, artifactIds ArtifactIDList) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/batch/metadata", pathParameters),
		autorest.WithJSON(artifactIds))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// BatchGetByIDSender sends the BatchGetByID request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) BatchGetByIDSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// BatchGetByIDResponder handles the response to the BatchGetByID request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) BatchGetByIDResponder(resp *http.Response) (result BatchArtifactContentInformationResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// BatchGetStorageByID get Batch Artifacts storage by specific Ids.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// artifactIds - the list of artifactIds to get.
func (client ArtifactsClient) BatchGetStorageByID(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, artifactIds ArtifactIDList) (result BatchArtifactContentInformationResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.BatchGetStorageByID")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: artifactIds,
			Constraints: []validation.Constraint{{Target: "artifactIds.ArtifactIds", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.ArtifactsClient", "BatchGetStorageByID", err.Error())
	}

	req, err := client.BatchGetStorageByIDPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, artifactIds)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "BatchGetStorageByID", nil, "Failure preparing request")
		return
	}

	resp, err := client.BatchGetStorageByIDSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "BatchGetStorageByID", resp, "Failure sending request")
		return
	}

	result, err = client.BatchGetStorageByIDResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "BatchGetStorageByID", resp, "Failure responding to request")
		return
	}

	return
}

// BatchGetStorageByIDPreparer prepares the BatchGetStorageByID request.
func (client ArtifactsClient) BatchGetStorageByIDPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, artifactIds ArtifactIDList) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/storageuri/batch/metadata", pathParameters),
		autorest.WithJSON(artifactIds))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// BatchGetStorageByIDSender sends the BatchGetStorageByID request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) BatchGetStorageByIDSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// BatchGetStorageByIDResponder handles the response to the BatchGetStorageByID request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) BatchGetStorageByIDResponder(resp *http.Response) (result BatchArtifactContentInformationResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// BatchIngestFromSas ingest Batch Artifacts using shared access signature.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// artifactContainerSas - the artifact container shared access signature to use for batch ingest.
func (client ArtifactsClient) BatchIngestFromSas(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, artifactContainerSas ArtifactContainerSas) (result PaginatedArtifactListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.BatchIngestFromSas")
		defer func() {
			sc := -1
			if result.pal.Response.Response != nil {
				sc = result.pal.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: artifactContainerSas,
			Constraints: []validation.Constraint{{Target: "artifactContainerSas.ContainerSas", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "artifactContainerSas.ContainerURI", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.ArtifactsClient", "BatchIngestFromSas", err.Error())
	}

	result.fn = client.batchIngestFromSasNextResults
	req, err := client.BatchIngestFromSasPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, artifactContainerSas)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "BatchIngestFromSas", nil, "Failure preparing request")
		return
	}

	resp, err := client.BatchIngestFromSasSender(req)
	if err != nil {
		result.pal.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "BatchIngestFromSas", resp, "Failure sending request")
		return
	}

	result.pal, err = client.BatchIngestFromSasResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "BatchIngestFromSas", resp, "Failure responding to request")
		return
	}
	if result.pal.hasNextLink() && result.pal.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// BatchIngestFromSasPreparer prepares the BatchIngestFromSas request.
func (client ArtifactsClient) BatchIngestFromSasPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, artifactContainerSas ArtifactContainerSas) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}/batch/ingest/containersas", pathParameters),
		autorest.WithJSON(artifactContainerSas))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// BatchIngestFromSasSender sends the BatchIngestFromSas request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) BatchIngestFromSasSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// BatchIngestFromSasResponder handles the response to the BatchIngestFromSas request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) BatchIngestFromSasResponder(resp *http.Response) (result PaginatedArtifactList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// batchIngestFromSasNextResults retrieves the next set of results, if any.
func (client ArtifactsClient) batchIngestFromSasNextResults(ctx context.Context, lastResults PaginatedArtifactList) (result PaginatedArtifactList, err error) {
	req, err := lastResults.paginatedArtifactListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "batchIngestFromSasNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.BatchIngestFromSasSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "batchIngestFromSasNextResults", resp, "Failure sending next results request")
	}
	result, err = client.BatchIngestFromSasResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "batchIngestFromSasNextResults", resp, "Failure responding to next results request")
	}
	return
}

// BatchIngestFromSasComplete enumerates all values, automatically crossing page boundaries as required.
func (client ArtifactsClient) BatchIngestFromSasComplete(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, artifactContainerSas ArtifactContainerSas) (result PaginatedArtifactListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.BatchIngestFromSas")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.BatchIngestFromSas(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, artifactContainerSas)
	return
}

// Create create an Artifact.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// artifact - the Artifact details.
func (client ArtifactsClient) Create(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, artifact Artifact) (result Artifact, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.Create")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: artifact,
			Constraints: []validation.Constraint{{Target: "artifact.Origin", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "artifact.Container", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "artifact.Path", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.ArtifactsClient", "Create", err.Error())
	}

	req, err := client.CreatePreparer(ctx, subscriptionID, resourceGroupName, workspaceName, artifact)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Create", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Create", resp, "Failure sending request")
		return
	}

	result, err = client.CreateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Create", resp, "Failure responding to request")
		return
	}

	return
}

// CreatePreparer prepares the Create request.
func (client ArtifactsClient) CreatePreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, artifact Artifact) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	artifact.Etag = nil
	artifact.CreatedTime = nil
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/metadata", pathParameters),
		autorest.WithJSON(artifact))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateSender sends the Create request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) CreateSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateResponder handles the response to the Create request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) CreateResponder(resp *http.Response) (result Artifact, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteBatchMetaData delete a Batch of Artifact Metadata.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// artifactPaths - the list of Artifact paths to delete.
// hardDelete - if set to true, the delete cannot be reverted at a later time.
func (client ArtifactsClient) DeleteBatchMetaData(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, artifactPaths ArtifactPathList, hardDelete *bool) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.DeleteBatchMetaData")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: artifactPaths,
			Constraints: []validation.Constraint{{Target: "artifactPaths.Paths", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.ArtifactsClient", "DeleteBatchMetaData", err.Error())
	}

	req, err := client.DeleteBatchMetaDataPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, artifactPaths, hardDelete)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "DeleteBatchMetaData", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteBatchMetaDataSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "DeleteBatchMetaData", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteBatchMetaDataResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "DeleteBatchMetaData", resp, "Failure responding to request")
		return
	}

	return
}

// DeleteBatchMetaDataPreparer prepares the DeleteBatchMetaData request.
func (client ArtifactsClient) DeleteBatchMetaDataPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, artifactPaths ArtifactPathList, hardDelete *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if hardDelete != nil {
		queryParameters["hardDelete"] = autorest.Encode("query", *hardDelete)
	} else {
		queryParameters["hardDelete"] = autorest.Encode("query", false)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}/batch/metadata:delete", pathParameters),
		autorest.WithJSON(artifactPaths),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteBatchMetaDataSender sends the DeleteBatchMetaData request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) DeleteBatchMetaDataSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteBatchMetaDataResponder handles the response to the DeleteBatchMetaData request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) DeleteBatchMetaDataResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteMetaData delete an Artifact Metadata.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// pathParameter - the Artifact Path.
// hardDelete - if set to true. The delete cannot be revert at later time.
func (client ArtifactsClient) DeleteMetaData(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string, hardDelete *bool) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.DeleteMetaData")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteMetaDataPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, pathParameter, hardDelete)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "DeleteMetaData", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteMetaDataSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "DeleteMetaData", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteMetaDataResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "DeleteMetaData", resp, "Failure responding to request")
		return
	}

	return
}

// DeleteMetaDataPreparer prepares the DeleteMetaData request.
func (client ArtifactsClient) DeleteMetaDataPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string, hardDelete *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if len(pathParameter) > 0 {
		queryParameters["path"] = autorest.Encode("query", pathParameter)
	}
	if hardDelete != nil {
		queryParameters["hardDelete"] = autorest.Encode("query", *hardDelete)
	} else {
		queryParameters["hardDelete"] = autorest.Encode("query", false)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}/metadata", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteMetaDataSender sends the DeleteMetaData request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) DeleteMetaDataSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteMetaDataResponder handles the response to the DeleteMetaData request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) DeleteMetaDataResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteMetaDataInContainer delete Artifact Metadata in a specific container.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// hardDelete - if set to true. The delete cannot be revert at later time.
func (client ArtifactsClient) DeleteMetaDataInContainer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, hardDelete *bool) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.DeleteMetaDataInContainer")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteMetaDataInContainerPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, hardDelete)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "DeleteMetaDataInContainer", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteMetaDataInContainerSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "DeleteMetaDataInContainer", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteMetaDataInContainerResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "DeleteMetaDataInContainer", resp, "Failure responding to request")
		return
	}

	return
}

// DeleteMetaDataInContainerPreparer prepares the DeleteMetaDataInContainer request.
func (client ArtifactsClient) DeleteMetaDataInContainerPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, hardDelete *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if hardDelete != nil {
		queryParameters["hardDelete"] = autorest.Encode("query", *hardDelete)
	} else {
		queryParameters["hardDelete"] = autorest.Encode("query", false)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}/batch", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteMetaDataInContainerSender sends the DeleteMetaDataInContainer request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) DeleteMetaDataInContainerSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteMetaDataInContainerResponder handles the response to the DeleteMetaDataInContainer request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) DeleteMetaDataInContainerResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Download get Artifact content of a specific Id.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// pathParameter - the Artifact Path.
func (client ArtifactsClient) Download(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string) (result ReadCloser, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.Download")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DownloadPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, pathParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Download", nil, "Failure preparing request")
		return
	}

	resp, err := client.DownloadSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Download", resp, "Failure sending request")
		return
	}

	result, err = client.DownloadResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Download", resp, "Failure responding to request")
		return
	}

	return
}

// DownloadPreparer prepares the Download request.
func (client ArtifactsClient) DownloadPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if len(pathParameter) > 0 {
		queryParameters["path"] = autorest.Encode("query", pathParameter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}/content", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DownloadSender sends the Download request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) DownloadSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DownloadResponder handles the response to the Download request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) DownloadResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK))
	result.Response = autorest.Response{Response: resp}
	return
}

// Get get Artifact metadata for a specific Id.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// pathParameter - the Artifact Path.
func (client ArtifactsClient) Get(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string) (result Artifact, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.Get")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, pathParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Get", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Get", resp, "Failure sending request")
		return
	}

	result, err = client.GetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Get", resp, "Failure responding to request")
		return
	}

	return
}

// GetPreparer prepares the Get request.
func (client ArtifactsClient) GetPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{
		"path": autorest.Encode("query", pathParameter),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}/metadata", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSender sends the Get request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) GetSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetResponder handles the response to the Get request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) GetResponder(resp *http.Response) (result Artifact, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetContentInformation get content information of an Artifact.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// pathParameter - the Artifact Path.
func (client ArtifactsClient) GetContentInformation(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string) (result ArtifactContentInformation, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.GetContentInformation")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetContentInformationPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, pathParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "GetContentInformation", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetContentInformationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "GetContentInformation", resp, "Failure sending request")
		return
	}

	result, err = client.GetContentInformationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "GetContentInformation", resp, "Failure responding to request")
		return
	}

	return
}

// GetContentInformationPreparer prepares the GetContentInformation request.
func (client ArtifactsClient) GetContentInformationPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if len(pathParameter) > 0 {
		queryParameters["path"] = autorest.Encode("query", pathParameter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}/contentinfo", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetContentInformationSender sends the GetContentInformation request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) GetContentInformationSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetContentInformationResponder handles the response to the GetContentInformation request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) GetContentInformationResponder(resp *http.Response) (result ArtifactContentInformation, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSas get writable shared access signature for a specific Artifact.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// pathParameter - the Artifact Path.
func (client ArtifactsClient) GetSas(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string) (result ArtifactContentInformation, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.GetSas")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetSasPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, pathParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "GetSas", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSasSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "GetSas", resp, "Failure sending request")
		return
	}

	result, err = client.GetSasResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "GetSas", resp, "Failure responding to request")
		return
	}

	return
}

// GetSasPreparer prepares the GetSas request.
func (client ArtifactsClient) GetSasPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if len(pathParameter) > 0 {
		queryParameters["path"] = autorest.Encode("query", pathParameter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}/write", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSasSender sends the GetSas request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) GetSasSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSasResponder handles the response to the GetSas request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) GetSasResponder(resp *http.Response) (result ArtifactContentInformation, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetStorageContentInformation get storage content information of an Artifact.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// pathParameter - the Artifact Path.
func (client ArtifactsClient) GetStorageContentInformation(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string) (result ArtifactContentInformation, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.GetStorageContentInformation")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetStorageContentInformationPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, pathParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "GetStorageContentInformation", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetStorageContentInformationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "GetStorageContentInformation", resp, "Failure sending request")
		return
	}

	result, err = client.GetStorageContentInformationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "GetStorageContentInformation", resp, "Failure responding to request")
		return
	}

	return
}

// GetStorageContentInformationPreparer prepares the GetStorageContentInformation request.
func (client ArtifactsClient) GetStorageContentInformationPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if len(pathParameter) > 0 {
		queryParameters["path"] = autorest.Encode("query", pathParameter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}/contentinfo/storageuri", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetStorageContentInformationSender sends the GetStorageContentInformation request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) GetStorageContentInformationSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetStorageContentInformationResponder handles the response to the GetStorageContentInformation request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) GetStorageContentInformationResponder(resp *http.Response) (result ArtifactContentInformation, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListInContainer get Artifacts metadata in a specific container or path.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// pathParameter - the Artifact Path.
// continuationToken - the continuation token.
func (client ArtifactsClient) ListInContainer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string, continuationToken string) (result PaginatedArtifactListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.ListInContainer")
		defer func() {
			sc := -1
			if result.pal.Response.Response != nil {
				sc = result.pal.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.listInContainerNextResults
	req, err := client.ListInContainerPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, pathParameter, continuationToken)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "ListInContainer", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListInContainerSender(req)
	if err != nil {
		result.pal.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "ListInContainer", resp, "Failure sending request")
		return
	}

	result.pal, err = client.ListInContainerResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "ListInContainer", resp, "Failure responding to request")
		return
	}
	if result.pal.hasNextLink() && result.pal.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// ListInContainerPreparer prepares the ListInContainer request.
func (client ArtifactsClient) ListInContainerPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string, continuationToken string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if len(pathParameter) > 0 {
		queryParameters["path"] = autorest.Encode("query", pathParameter)
	}
	if len(continuationToken) > 0 {
		queryParameters["continuationToken"] = autorest.Encode("query", continuationToken)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListInContainerSender sends the ListInContainer request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) ListInContainerSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListInContainerResponder handles the response to the ListInContainer request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) ListInContainerResponder(resp *http.Response) (result PaginatedArtifactList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listInContainerNextResults retrieves the next set of results, if any.
func (client ArtifactsClient) listInContainerNextResults(ctx context.Context, lastResults PaginatedArtifactList) (result PaginatedArtifactList, err error) {
	req, err := lastResults.paginatedArtifactListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "listInContainerNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListInContainerSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "listInContainerNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListInContainerResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "listInContainerNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListInContainerComplete enumerates all values, automatically crossing page boundaries as required.
func (client ArtifactsClient) ListInContainerComplete(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string, continuationToken string) (result PaginatedArtifactListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.ListInContainer")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListInContainer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, pathParameter, continuationToken)
	return
}

// ListSasByPrefix get shared access signature for an Artifact in specific path.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// pathParameter - the Artifact Path.
// continuationToken - the continuation token.
func (client ArtifactsClient) ListSasByPrefix(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string, continuationToken string) (result PaginatedArtifactContentInformationListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.ListSasByPrefix")
		defer func() {
			sc := -1
			if result.pacil.Response.Response != nil {
				sc = result.pacil.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.listSasByPrefixNextResults
	req, err := client.ListSasByPrefixPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, pathParameter, continuationToken)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "ListSasByPrefix", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSasByPrefixSender(req)
	if err != nil {
		result.pacil.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "ListSasByPrefix", resp, "Failure sending request")
		return
	}

	result.pacil, err = client.ListSasByPrefixResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "ListSasByPrefix", resp, "Failure responding to request")
		return
	}
	if result.pacil.hasNextLink() && result.pacil.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// ListSasByPrefixPreparer prepares the ListSasByPrefix request.
func (client ArtifactsClient) ListSasByPrefixPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string, continuationToken string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if len(pathParameter) > 0 {
		queryParameters["path"] = autorest.Encode("query", pathParameter)
	}
	if len(continuationToken) > 0 {
		queryParameters["continuationToken"] = autorest.Encode("query", continuationToken)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}/prefix/contentinfo", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSasByPrefixSender sends the ListSasByPrefix request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) ListSasByPrefixSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListSasByPrefixResponder handles the response to the ListSasByPrefix request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) ListSasByPrefixResponder(resp *http.Response) (result PaginatedArtifactContentInformationList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listSasByPrefixNextResults retrieves the next set of results, if any.
func (client ArtifactsClient) listSasByPrefixNextResults(ctx context.Context, lastResults PaginatedArtifactContentInformationList) (result PaginatedArtifactContentInformationList, err error) {
	req, err := lastResults.paginatedArtifactContentInformationListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "listSasByPrefixNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListSasByPrefixSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "listSasByPrefixNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListSasByPrefixResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "listSasByPrefixNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListSasByPrefixComplete enumerates all values, automatically crossing page boundaries as required.
func (client ArtifactsClient) ListSasByPrefixComplete(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string, continuationToken string) (result PaginatedArtifactContentInformationListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.ListSasByPrefix")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListSasByPrefix(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, pathParameter, continuationToken)
	return
}

// ListStorageURIByPrefix get storage Uri for Artifacts in a specific path.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// pathParameter - the Artifact Path.
// continuationToken - the continuation token.
func (client ArtifactsClient) ListStorageURIByPrefix(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string, continuationToken string) (result PaginatedArtifactContentInformationListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.ListStorageURIByPrefix")
		defer func() {
			sc := -1
			if result.pacil.Response.Response != nil {
				sc = result.pacil.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.listStorageURIByPrefixNextResults
	req, err := client.ListStorageURIByPrefixPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, pathParameter, continuationToken)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "ListStorageURIByPrefix", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListStorageURIByPrefixSender(req)
	if err != nil {
		result.pacil.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "ListStorageURIByPrefix", resp, "Failure sending request")
		return
	}

	result.pacil, err = client.ListStorageURIByPrefixResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "ListStorageURIByPrefix", resp, "Failure responding to request")
		return
	}
	if result.pacil.hasNextLink() && result.pacil.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// ListStorageURIByPrefixPreparer prepares the ListStorageURIByPrefix request.
func (client ArtifactsClient) ListStorageURIByPrefixPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string, continuationToken string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if len(pathParameter) > 0 {
		queryParameters["path"] = autorest.Encode("query", pathParameter)
	}
	if len(continuationToken) > 0 {
		queryParameters["continuationToken"] = autorest.Encode("query", continuationToken)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}/prefix/contentinfo/storageuri", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListStorageURIByPrefixSender sends the ListStorageURIByPrefix request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) ListStorageURIByPrefixSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListStorageURIByPrefixResponder handles the response to the ListStorageURIByPrefix request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) ListStorageURIByPrefixResponder(resp *http.Response) (result PaginatedArtifactContentInformationList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listStorageURIByPrefixNextResults retrieves the next set of results, if any.
func (client ArtifactsClient) listStorageURIByPrefixNextResults(ctx context.Context, lastResults PaginatedArtifactContentInformationList) (result PaginatedArtifactContentInformationList, err error) {
	req, err := lastResults.paginatedArtifactContentInformationListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "listStorageURIByPrefixNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListStorageURIByPrefixSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "listStorageURIByPrefixNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListStorageURIByPrefixResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "listStorageURIByPrefixNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListStorageURIByPrefixComplete enumerates all values, automatically crossing page boundaries as required.
func (client ArtifactsClient) ListStorageURIByPrefixComplete(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, pathParameter string, continuationToken string) (result PaginatedArtifactContentInformationListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.ListStorageURIByPrefix")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListStorageURIByPrefix(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, pathParameter, continuationToken)
	return
}

// Register create an Artifact for an existing dataPath.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// artifact - the Artifact creation details.
func (client ArtifactsClient) Register(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, artifact Artifact) (result Artifact, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.Register")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: artifact,
			Constraints: []validation.Constraint{{Target: "artifact.Origin", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "artifact.Container", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "artifact.Path", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.ArtifactsClient", "Register", err.Error())
	}

	req, err := client.RegisterPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, artifact)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Register", nil, "Failure preparing request")
		return
	}

	resp, err := client.RegisterSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Register", resp, "Failure sending request")
		return
	}

	result, err = client.RegisterResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Register", resp, "Failure responding to request")
		return
	}

	return
}

// RegisterPreparer prepares the Register request.
func (client ArtifactsClient) RegisterPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, artifact Artifact) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	artifact.Etag = nil
	artifact.CreatedTime = nil
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/register", pathParameters),
		autorest.WithJSON(artifact))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RegisterSender sends the Register request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) RegisterSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RegisterResponder handles the response to the Register request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) RegisterResponder(resp *http.Response) (result Artifact, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Upload upload content to an Artifact.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// origin - the origin of the Artifact.
// containerParameter - the container name.
// content - the file upload.
// pathParameter - the Artifact Path.
// indexParameter - the index.
// appendParameter - whether or not to append the content or replace it.
// allowOverwrite - whether to allow overwrite if Artifact Content exist already. when set to true, Overwrite
// happens if Artifact Content already exists
func (client ArtifactsClient) Upload(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, content string, pathParameter string, indexParameter *int32, appendParameter *bool, allowOverwrite *bool) (result Artifact, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArtifactsClient.Upload")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UploadPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, origin, containerParameter, content, pathParameter, indexParameter, appendParameter, allowOverwrite)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Upload", nil, "Failure preparing request")
		return
	}

	resp, err := client.UploadSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Upload", resp, "Failure sending request")
		return
	}

	result, err = client.UploadResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ArtifactsClient", "Upload", resp, "Failure responding to request")
		return
	}

	return
}

// UploadPreparer prepares the Upload request.
func (client ArtifactsClient) UploadPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, origin string, containerParameter string, content string, pathParameter string, indexParameter *int32, appendParameter *bool, allowOverwrite *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"container":         autorest.Encode("path", containerParameter),
		"origin":            autorest.Encode("path", origin),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if len(pathParameter) > 0 {
		queryParameters["path"] = autorest.Encode("query", pathParameter)
	}
	if indexParameter != nil {
		queryParameters["index"] = autorest.Encode("query", *indexParameter)
	}
	if appendParameter != nil {
		queryParameters["append"] = autorest.Encode("query", *appendParameter)
	} else {
		queryParameters["append"] = autorest.Encode("query", false)
	}
	if allowOverwrite != nil {
		queryParameters["allowOverwrite"] = autorest.Encode("query", *allowOverwrite)
	} else {
		queryParameters["allowOverwrite"] = autorest.Encode("query", false)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/octet-stream"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/artifact/v2.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/artifacts/{origin}/{container}/content", pathParameters),
		autorest.WithJSON(content),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UploadSender sends the Upload request. The method will close the
// http.Response Body if it receives an error.
func (client ArtifactsClient) UploadSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UploadResponder handles the response to the Upload request. The method always
// closes the http.Response Body.
func (client ArtifactsClient) UploadResponder(resp *http.Response) (result Artifact, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
