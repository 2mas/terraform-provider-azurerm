package machinelearningservices

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
	"github.com/gofrs/uuid"
	"net/http"
)

// ServicesClient is the these APIs allow end users to manage Azure Machine Learning Services.
type ServicesClient struct {
	BaseClient
}

// NewServicesClient creates an instance of the ServicesClient client.
func NewServicesClient() ServicesClient {
	return NewServicesClientWithBaseURI(DefaultBaseURI)
}

// NewServicesClientWithBaseURI creates an instance of the ServicesClient client using a custom endpoint.  Use this
// when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
func NewServicesClientWithBaseURI(baseURI string) ServicesClient {
	return ServicesClient{NewWithBaseURI(baseURI)}
}

// Create create a Service with the specified payload.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroup - the Name of the resource group in which the workspace is located.
// workspace - the name of the workspace.
// request - the payload that is used to create the Service.
func (client ServicesClient) Create(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, request BasicCreateServiceRequest) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServicesClient.Create")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: request,
			Constraints: []validation.Constraint{{Target: "request.Name", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.ServicesClient", "Create", err.Error())
	}

	req, err := client.CreatePreparer(ctx, subscriptionID, resourceGroup, workspace, request)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "Create", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "Create", resp, "Failure sending request")
		return
	}

	result, err = client.CreateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "Create", resp, "Failure responding to request")
		return
	}

	return
}

// CreatePreparer prepares the Create request.
func (client ServicesClient) CreatePreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, request BasicCreateServiceRequest) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"resourceGroup":  autorest.Encode("path", resourceGroup),
		"subscriptionId": autorest.Encode("path", subscriptionID),
		"workspace":      autorest.Encode("path", workspace),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services", pathParameters),
		autorest.WithJSON(request))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateSender sends the Create request. The method will close the
// http.Response Body if it receives an error.
func (client ServicesClient) CreateSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateResponder handles the response to the Create request. The method always
// closes the http.Response Body.
func (client ServicesClient) CreateResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Delete delete a specific Service.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroup - the Name of the resource group in which the workspace is located.
// workspace - the name of the workspace.
// ID - the Service Id.
func (client ServicesClient) Delete(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, ID string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServicesClient.Delete")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeletePreparer(ctx, subscriptionID, resourceGroup, workspace, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "Delete", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "Delete", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "Delete", resp, "Failure responding to request")
		return
	}

	return
}

// DeletePreparer prepares the Delete request.
func (client ServicesClient) DeletePreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, ID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":             autorest.Encode("path", ID),
		"resourceGroup":  autorest.Encode("path", resourceGroup),
		"subscriptionId": autorest.Encode("path", subscriptionID),
		"workspace":      autorest.Encode("path", workspace),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteSender sends the Delete request. The method will close the
// http.Response Body if it receives an error.
func (client ServicesClient) DeleteSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteResponder handles the response to the Delete request. The method always
// closes the http.Response Body.
func (client ServicesClient) DeleteResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GetServiceToken gets access token that can be used for calling service.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroup - the Name of the resource group in which the workspace is located.
// workspace - the name of the workspace.
// ID - the Service Id.
func (client ServicesClient) GetServiceToken(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, ID string) (result AuthToken, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServicesClient.GetServiceToken")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetServiceTokenPreparer(ctx, subscriptionID, resourceGroup, workspace, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "GetServiceToken", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceTokenSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "GetServiceToken", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceTokenResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "GetServiceToken", resp, "Failure responding to request")
		return
	}

	return
}

// GetServiceTokenPreparer prepares the GetServiceToken request.
func (client ServicesClient) GetServiceTokenPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, ID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":             autorest.Encode("path", ID),
		"resourceGroup":  autorest.Encode("path", resourceGroup),
		"subscriptionId": autorest.Encode("path", subscriptionID),
		"workspace":      autorest.Encode("path", workspace),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}/token", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetServiceTokenSender sends the GetServiceToken request. The method will close the
// http.Response Body if it receives an error.
func (client ServicesClient) GetServiceTokenSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetServiceTokenResponder handles the response to the GetServiceToken request. The method always
// closes the http.Response Body.
func (client ServicesClient) GetServiceTokenResponder(resp *http.Response) (result AuthToken, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListQuery if no filter is passed, the query lists all Services in the Workspace. The returned list is paginated and
// the count of item in each page is an optional parameter.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroup - the Name of the resource group in which the workspace is located.
// workspace - the name of the workspace.
// imageID - the Image Id.
// imageName - the Image name.
// modelID - the Model Id.
// modelName - the Model name.
// name - the object name.
// count - the number of items to retrieve in a page.
// computeType - the compute environment type.
// skipToken - the continuation token to retrieve the next page.
// tags - a set of tags with which to filter the returned models.
// It is a comma separated string of tags key or tags key=value
// Example: tagKey1,tagKey2,tagKey3=value3
// properties - a set of properties with which to filter the returned models.
// It is a comma separated string of properties key and/or properties key=value
// Example: propKey1,propKey2,propKey3=value3
// expand - set to True to include Model details.
// orderby - the option to order the response.
func (client ServicesClient) ListQuery(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, imageID string, imageName string, modelID string, modelName string, name string, count *int32, computeType string, skipToken string, tags string, properties string, expand *bool, orderby string) (result PaginatedServiceListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServicesClient.ListQuery")
		defer func() {
			sc := -1
			if result.psl.Response.Response != nil {
				sc = result.psl.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.listQueryNextResults
	req, err := client.ListQueryPreparer(ctx, subscriptionID, resourceGroup, workspace, imageID, imageName, modelID, modelName, name, count, computeType, skipToken, tags, properties, expand, orderby)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "ListQuery", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListQuerySender(req)
	if err != nil {
		result.psl.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "ListQuery", resp, "Failure sending request")
		return
	}

	result.psl, err = client.ListQueryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "ListQuery", resp, "Failure responding to request")
		return
	}
	if result.psl.hasNextLink() && result.psl.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// ListQueryPreparer prepares the ListQuery request.
func (client ServicesClient) ListQueryPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, imageID string, imageName string, modelID string, modelName string, name string, count *int32, computeType string, skipToken string, tags string, properties string, expand *bool, orderby string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"resourceGroup":  autorest.Encode("path", resourceGroup),
		"subscriptionId": autorest.Encode("path", subscriptionID),
		"workspace":      autorest.Encode("path", workspace),
	}

	queryParameters := map[string]interface{}{}
	if len(imageID) > 0 {
		queryParameters["imageId"] = autorest.Encode("query", imageID)
	}
	if len(imageName) > 0 {
		queryParameters["imageName"] = autorest.Encode("query", imageName)
	}
	if len(modelID) > 0 {
		queryParameters["modelId"] = autorest.Encode("query", modelID)
	}
	if len(modelName) > 0 {
		queryParameters["modelName"] = autorest.Encode("query", modelName)
	}
	if len(name) > 0 {
		queryParameters["name"] = autorest.Encode("query", name)
	}
	if count != nil {
		queryParameters["count"] = autorest.Encode("query", *count)
	}
	if len(computeType) > 0 {
		queryParameters["computeType"] = autorest.Encode("query", computeType)
	}
	if len(skipToken) > 0 {
		queryParameters["$skipToken"] = autorest.Encode("query", skipToken)
	}
	if len(tags) > 0 {
		queryParameters["tags"] = autorest.Encode("query", tags)
	}
	if len(properties) > 0 {
		queryParameters["properties"] = autorest.Encode("query", properties)
	}
	if expand != nil {
		queryParameters["expand"] = autorest.Encode("query", *expand)
	} else {
		queryParameters["expand"] = autorest.Encode("query", false)
	}
	if len(string(orderby)) > 0 {
		queryParameters["orderby"] = autorest.Encode("query", orderby)
	} else {
		queryParameters["orderby"] = autorest.Encode("query", "UpdatedAtDesc")
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListQuerySender sends the ListQuery request. The method will close the
// http.Response Body if it receives an error.
func (client ServicesClient) ListQuerySender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListQueryResponder handles the response to the ListQuery request. The method always
// closes the http.Response Body.
func (client ServicesClient) ListQueryResponder(resp *http.Response) (result PaginatedServiceList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listQueryNextResults retrieves the next set of results, if any.
func (client ServicesClient) listQueryNextResults(ctx context.Context, lastResults PaginatedServiceList) (result PaginatedServiceList, err error) {
	req, err := lastResults.paginatedServiceListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "listQueryNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListQuerySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "listQueryNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListQueryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "listQueryNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListQueryComplete enumerates all values, automatically crossing page boundaries as required.
func (client ServicesClient) ListQueryComplete(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, imageID string, imageName string, modelID string, modelName string, name string, count *int32, computeType string, skipToken string, tags string, properties string, expand *bool, orderby string) (result PaginatedServiceListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServicesClient.ListQuery")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListQuery(ctx, subscriptionID, resourceGroup, workspace, imageID, imageName, modelID, modelName, name, count, computeType, skipToken, tags, properties, expand, orderby)
	return
}

// ListServiceKeys gets a list of Service keys.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroup - the Name of the resource group in which the workspace is located.
// workspace - the name of the workspace.
// ID - the Service Id.
func (client ServicesClient) ListServiceKeys(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, ID string) (result AuthKeys, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServicesClient.ListServiceKeys")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ListServiceKeysPreparer(ctx, subscriptionID, resourceGroup, workspace, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "ListServiceKeys", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListServiceKeysSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "ListServiceKeys", resp, "Failure sending request")
		return
	}

	result, err = client.ListServiceKeysResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "ListServiceKeys", resp, "Failure responding to request")
		return
	}

	return
}

// ListServiceKeysPreparer prepares the ListServiceKeys request.
func (client ServicesClient) ListServiceKeysPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, ID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":             autorest.Encode("path", ID),
		"resourceGroup":  autorest.Encode("path", resourceGroup),
		"subscriptionId": autorest.Encode("path", subscriptionID),
		"workspace":      autorest.Encode("path", workspace),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}/listkeys", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListServiceKeysSender sends the ListServiceKeys request. The method will close the
// http.Response Body if it receives an error.
func (client ServicesClient) ListServiceKeysSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListServiceKeysResponder handles the response to the ListServiceKeys request. The method always
// closes the http.Response Body.
func (client ServicesClient) ListServiceKeysResponder(resp *http.Response) (result AuthKeys, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Patch patch a specific Service.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroup - the Name of the resource group in which the workspace is located.
// workspace - the name of the workspace.
// ID - the Service Id.
// patch - the payload that is used to patch the Service.
func (client ServicesClient) Patch(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, ID string, patch []JSONPatchOperation) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServicesClient.Patch")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: patch,
			Constraints: []validation.Constraint{{Target: "patch", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.ServicesClient", "Patch", err.Error())
	}

	req, err := client.PatchPreparer(ctx, subscriptionID, resourceGroup, workspace, ID, patch)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "Patch", nil, "Failure preparing request")
		return
	}

	resp, err := client.PatchSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "Patch", resp, "Failure sending request")
		return
	}

	result, err = client.PatchResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "Patch", resp, "Failure responding to request")
		return
	}

	return
}

// PatchPreparer prepares the Patch request.
func (client ServicesClient) PatchPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, ID string, patch []JSONPatchOperation) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":             autorest.Encode("path", ID),
		"resourceGroup":  autorest.Encode("path", resourceGroup),
		"subscriptionId": autorest.Encode("path", subscriptionID),
		"workspace":      autorest.Encode("path", workspace),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json-patch+json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}", pathParameters),
		autorest.WithJSON(patch))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PatchSender sends the Patch request. The method will close the
// http.Response Body if it receives an error.
func (client ServicesClient) PatchSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// PatchResponder handles the response to the Patch request. The method always
// closes the http.Response Body.
func (client ServicesClient) PatchResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// QueryByID get a Service by Id.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroup - the Name of the resource group in which the workspace is located.
// workspace - the name of the workspace.
// ID - the Service Id.
// expand - set to True to include Model details.
func (client ServicesClient) QueryByID(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, ID string, expand *bool) (result ServiceResponseBaseModel, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServicesClient.QueryByID")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.QueryByIDPreparer(ctx, subscriptionID, resourceGroup, workspace, ID, expand)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "QueryByID", nil, "Failure preparing request")
		return
	}

	resp, err := client.QueryByIDSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "QueryByID", resp, "Failure sending request")
		return
	}

	result, err = client.QueryByIDResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "QueryByID", resp, "Failure responding to request")
		return
	}

	return
}

// QueryByIDPreparer prepares the QueryByID request.
func (client ServicesClient) QueryByIDPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, ID string, expand *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":             autorest.Encode("path", ID),
		"resourceGroup":  autorest.Encode("path", resourceGroup),
		"subscriptionId": autorest.Encode("path", subscriptionID),
		"workspace":      autorest.Encode("path", workspace),
	}

	queryParameters := map[string]interface{}{}
	if expand != nil {
		queryParameters["expand"] = autorest.Encode("query", *expand)
	} else {
		queryParameters["expand"] = autorest.Encode("query", false)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// QueryByIDSender sends the QueryByID request. The method will close the
// http.Response Body if it receives an error.
func (client ServicesClient) QueryByIDSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// QueryByIDResponder handles the response to the QueryByID request. The method always
// closes the http.Response Body.
func (client ServicesClient) QueryByIDResponder(resp *http.Response) (result ServiceResponseBaseModel, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// RegenerateServiceKeys regenerate and return the Service keys.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroup - the Name of the resource group in which the workspace is located.
// workspace - the name of the workspace.
// ID - the Service Id.
// request - the payload that is used to regenerate keys.
func (client ServicesClient) RegenerateServiceKeys(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, ID string, request RegenerateServiceKeysRequest) (result AuthKeys, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServicesClient.RegenerateServiceKeys")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.RegenerateServiceKeysPreparer(ctx, subscriptionID, resourceGroup, workspace, ID, request)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "RegenerateServiceKeys", nil, "Failure preparing request")
		return
	}

	resp, err := client.RegenerateServiceKeysSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "RegenerateServiceKeys", resp, "Failure sending request")
		return
	}

	result, err = client.RegenerateServiceKeysResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ServicesClient", "RegenerateServiceKeys", resp, "Failure responding to request")
		return
	}

	return
}

// RegenerateServiceKeysPreparer prepares the RegenerateServiceKeys request.
func (client ServicesClient) RegenerateServiceKeysPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroup string, workspace string, ID string, request RegenerateServiceKeysRequest) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":             autorest.Encode("path", ID),
		"resourceGroup":  autorest.Encode("path", resourceGroup),
		"subscriptionId": autorest.Encode("path", subscriptionID),
		"workspace":      autorest.Encode("path", workspace),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/modelmanagement/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.MachineLearningServices/workspaces/{workspace}/services/{id}/regenerateKeys", pathParameters),
		autorest.WithJSON(request))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RegenerateServiceKeysSender sends the RegenerateServiceKeys request. The method will close the
// http.Response Body if it receives an error.
func (client ServicesClient) RegenerateServiceKeysSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RegenerateServiceKeysResponder handles the response to the RegenerateServiceKeys request. The method always
// closes the http.Response Body.
func (client ServicesClient) RegenerateServiceKeysResponder(resp *http.Response) (result AuthKeys, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
