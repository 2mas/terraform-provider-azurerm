package machinelearningservices

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
	"github.com/gofrs/uuid"
	"io"
	"net/http"
)

// RunsClient is the these APIs allow end users to manage Azure Machine Learning Services.
type RunsClient struct {
	BaseClient
}

// NewRunsClient creates an instance of the RunsClient client.
func NewRunsClient() RunsClient {
	return NewRunsClientWithBaseURI(DefaultBaseURI)
}

// NewRunsClientWithBaseURI creates an instance of the RunsClient client using a custom endpoint.  Use this when
// interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
func NewRunsClientWithBaseURI(baseURI string) RunsClient {
	return RunsClient{NewWithBaseURI(baseURI)}
}

// BatchAddOrModify add or Modify a batch of Runs for a given experiment.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// experimentName - the experiment name.
// requestDto - the list of requested Run Additions/modifications in an Experiment.
func (client RunsClient) BatchAddOrModify(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, requestDto *BatchAddOrModifyRunRequest) (result BatchAddOrModifyRunResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RunsClient.BatchAddOrModify")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.BatchAddOrModifyPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, experimentName, requestDto)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "BatchAddOrModify", nil, "Failure preparing request")
		return
	}

	resp, err := client.BatchAddOrModifySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "BatchAddOrModify", resp, "Failure sending request")
		return
	}

	result, err = client.BatchAddOrModifyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "BatchAddOrModify", resp, "Failure responding to request")
		return
	}

	return
}

// BatchAddOrModifyPreparer prepares the BatchAddOrModify request.
func (client RunsClient) BatchAddOrModifyPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, requestDto *BatchAddOrModifyRunRequest) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"experimentName":    autorest.Encode("path", experimentName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/history/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/experiments/{experimentName}/batch/runs", pathParameters))
	if requestDto != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(requestDto))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// BatchAddOrModifySender sends the BatchAddOrModify request. The method will close the
// http.Response Body if it receives an error.
func (client RunsClient) BatchAddOrModifySender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// BatchAddOrModifyResponder handles the response to the BatchAddOrModify request. The method always
// closes the http.Response Body.
func (client RunsClient) BatchAddOrModifyResponder(resp *http.Response) (result BatchAddOrModifyRunResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CancelRunWithURI cancels a run within an experiment.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// experimentName - the experiment name.
// runID - the id of the run to cancel.
func (client RunsClient) CancelRunWithURI(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runID string) (result StartRunResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RunsClient.CancelRunWithURI")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: runID,
			Constraints: []validation.Constraint{{Target: "runID", Name: validation.Pattern, Rule: `^[a-zA-Z0-9][\w-]{0,255}$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.RunsClient", "CancelRunWithURI", err.Error())
	}

	req, err := client.CancelRunWithURIPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, experimentName, runID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "CancelRunWithURI", nil, "Failure preparing request")
		return
	}

	resp, err := client.CancelRunWithURISender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "CancelRunWithURI", resp, "Failure sending request")
		return
	}

	result, err = client.CancelRunWithURIResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "CancelRunWithURI", resp, "Failure responding to request")
		return
	}

	return
}

// CancelRunWithURIPreparer prepares the CancelRunWithURI request.
func (client RunsClient) CancelRunWithURIPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"experimentName":    autorest.Encode("path", experimentName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"runId":             autorest.Encode("path", runID),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/execution/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/experiments/{experimentName}/runId/{runId}/cancel", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CancelRunWithURISender sends the CancelRunWithURI request. The method will close the
// http.Response Body if it receives an error.
func (client RunsClient) CancelRunWithURISender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CancelRunWithURIResponder handles the response to the CancelRunWithURI request. The method always
// closes the http.Response Body.
func (client RunsClient) CancelRunWithURIResponder(resp *http.Response) (result StartRunResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteTags delete list of Tags from a specific Run Id.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// experimentName - the experiment name.
// runID - the identifier of the Run.
// tags - the requested tags list to be deleted.
func (client RunsClient) DeleteTags(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runID string, tags []string) (result Run, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RunsClient.DeleteTags")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteTagsPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, experimentName, runID, tags)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "DeleteTags", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteTagsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "DeleteTags", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteTagsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "DeleteTags", resp, "Failure responding to request")
		return
	}

	return
}

// DeleteTagsPreparer prepares the DeleteTags request.
func (client RunsClient) DeleteTagsPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runID string, tags []string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"experimentName":    autorest.Encode("path", experimentName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"runId":             autorest.Encode("path", runID),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/history/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/experiments/{experimentName}/runs/{runId}/tags", pathParameters))
	if tags != nil && len(tags) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(tags))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteTagsSender sends the DeleteTags request. The method will close the
// http.Response Body if it receives an error.
func (client RunsClient) DeleteTagsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteTagsResponder handles the response to the DeleteTags request. The method always
// closes the http.Response Body.
func (client RunsClient) DeleteTagsResponder(resp *http.Response) (result Run, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Get get Run details of a specific Run Id.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// experimentName - the experiment name.
// runID - the identifier of the Run.
func (client RunsClient) Get(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runID string) (result Run, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RunsClient.Get")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, experimentName, runID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "Get", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "Get", resp, "Failure sending request")
		return
	}

	result, err = client.GetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "Get", resp, "Failure responding to request")
		return
	}

	return
}

// GetPreparer prepares the Get request.
func (client RunsClient) GetPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"experimentName":    autorest.Encode("path", experimentName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"runId":             autorest.Encode("path", runID),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/history/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/experiments/{experimentName}/runs/{runId}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSender sends the Get request. The method will close the
// http.Response Body if it receives an error.
func (client RunsClient) GetSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetResponder handles the response to the Get request. The method always
// closes the http.Response Body.
func (client RunsClient) GetResponder(resp *http.Response) (result Run, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetByQuery get all Runs for a specific Experiment with the specified query filters.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// experimentName - the experiment name.
// queryParams - query parameters for data sorting and filtering.
func (client RunsClient) GetByQuery(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, queryParams *QueryParams) (result PaginatedRunListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RunsClient.GetByQuery")
		defer func() {
			sc := -1
			if result.prl.Response.Response != nil {
				sc = result.prl.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getByQueryNextResults
	req, err := client.GetByQueryPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, experimentName, queryParams)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "GetByQuery", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetByQuerySender(req)
	if err != nil {
		result.prl.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "GetByQuery", resp, "Failure sending request")
		return
	}

	result.prl, err = client.GetByQueryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "GetByQuery", resp, "Failure responding to request")
		return
	}
	if result.prl.hasNextLink() && result.prl.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetByQueryPreparer prepares the GetByQuery request.
func (client RunsClient) GetByQueryPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, queryParams *QueryParams) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"experimentName":    autorest.Encode("path", experimentName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/history/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/experiments/{experimentName}/runs:query", pathParameters))
	if queryParams != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(queryParams))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetByQuerySender sends the GetByQuery request. The method will close the
// http.Response Body if it receives an error.
func (client RunsClient) GetByQuerySender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetByQueryResponder handles the response to the GetByQuery request. The method always
// closes the http.Response Body.
func (client RunsClient) GetByQueryResponder(resp *http.Response) (result PaginatedRunList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getByQueryNextResults retrieves the next set of results, if any.
func (client RunsClient) getByQueryNextResults(ctx context.Context, lastResults PaginatedRunList) (result PaginatedRunList, err error) {
	req, err := lastResults.paginatedRunListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "getByQueryNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetByQuerySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "getByQueryNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetByQueryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "getByQueryNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetByQueryComplete enumerates all values, automatically crossing page boundaries as required.
func (client RunsClient) GetByQueryComplete(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, queryParams *QueryParams) (result PaginatedRunListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RunsClient.GetByQuery")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetByQuery(ctx, subscriptionID, resourceGroupName, workspaceName, experimentName, queryParams)
	return
}

// GetChild get details of all child runs for the specified Run Id with the specified filters.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// experimentName - the experiment name.
// runID - the identifier of the Run.
// filter - allows for filtering the collection of resources.
// The expression specified is evaluated for each resource in the collection, and only items where the
// expression evaluates to true are included in the response.
// continuationtoken - the continuation token to use for getting the next set of resources.
// orderby - the list of resource properties to use for sorting the requested resources.
// sortorder - the sort order of the returned resources. Not used, specify asc or desc after each property name
// in the OrderBy parameter.
// top - the maximum number of items in the resource collection to be included in the result.
// If not specified, all items are returned.
// count - whether to include a count of the matching resources along with the resources returned in the
// response.
func (client RunsClient) GetChild(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runID string, filter string, continuationtoken string, orderby []string, sortorder string, top *int32, count *bool) (result PaginatedRunListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RunsClient.GetChild")
		defer func() {
			sc := -1
			if result.prl.Response.Response != nil {
				sc = result.prl.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getChildNextResults
	req, err := client.GetChildPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, experimentName, runID, filter, continuationtoken, orderby, sortorder, top, count)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "GetChild", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetChildSender(req)
	if err != nil {
		result.prl.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "GetChild", resp, "Failure sending request")
		return
	}

	result.prl, err = client.GetChildResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "GetChild", resp, "Failure responding to request")
		return
	}
	if result.prl.hasNextLink() && result.prl.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetChildPreparer prepares the GetChild request.
func (client RunsClient) GetChildPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runID string, filter string, continuationtoken string, orderby []string, sortorder string, top *int32, count *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"experimentName":    autorest.Encode("path", experimentName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"runId":             autorest.Encode("path", runID),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if len(continuationtoken) > 0 {
		queryParameters["$continuationtoken"] = autorest.Encode("query", continuationtoken)
	}
	if orderby != nil && len(orderby) > 0 {
		queryParameters["$orderby"] = orderby
	}
	if len(string(sortorder)) > 0 {
		queryParameters["$sortorder"] = autorest.Encode("query", sortorder)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/history/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/experiments/{experimentName}/runs/{runId}/children", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetChildSender sends the GetChild request. The method will close the
// http.Response Body if it receives an error.
func (client RunsClient) GetChildSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetChildResponder handles the response to the GetChild request. The method always
// closes the http.Response Body.
func (client RunsClient) GetChildResponder(resp *http.Response) (result PaginatedRunList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getChildNextResults retrieves the next set of results, if any.
func (client RunsClient) getChildNextResults(ctx context.Context, lastResults PaginatedRunList) (result PaginatedRunList, err error) {
	req, err := lastResults.paginatedRunListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "getChildNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetChildSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "getChildNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetChildResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "getChildNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetChildComplete enumerates all values, automatically crossing page boundaries as required.
func (client RunsClient) GetChildComplete(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runID string, filter string, continuationtoken string, orderby []string, sortorder string, top *int32, count *bool) (result PaginatedRunListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RunsClient.GetChild")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetChild(ctx, subscriptionID, resourceGroupName, workspaceName, experimentName, runID, filter, continuationtoken, orderby, sortorder, top, count)
	return
}

// GetDetails get Run Details for a specific Run Id.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// experimentName - the experiment name.
// runID - the identifier of the Run.
func (client RunsClient) GetDetails(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runID string) (result RunDetails, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RunsClient.GetDetails")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetDetailsPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, experimentName, runID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "GetDetails", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDetailsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "GetDetails", resp, "Failure sending request")
		return
	}

	result, err = client.GetDetailsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "GetDetails", resp, "Failure responding to request")
		return
	}

	return
}

// GetDetailsPreparer prepares the GetDetails request.
func (client RunsClient) GetDetailsPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"experimentName":    autorest.Encode("path", experimentName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"runId":             autorest.Encode("path", runID),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/history/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/experiments/{experimentName}/runs/{runId}/details", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDetailsSender sends the GetDetails request. The method will close the
// http.Response Body if it receives an error.
func (client RunsClient) GetDetailsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDetailsResponder handles the response to the GetDetails request. The method always
// closes the http.Response Body.
func (client RunsClient) GetDetailsResponder(resp *http.Response) (result RunDetails, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Patch add a new Run or Modify an existing Run.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// experimentName - the experiment name.
// runID - the identifier of the Run.
// createRunDto - the requested Run parameter Additions/modifications.
func (client RunsClient) Patch(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runID string, createRunDto *CreateRun) (result Run, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RunsClient.Patch")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: runID,
			Constraints: []validation.Constraint{{Target: "runID", Name: validation.Pattern, Rule: `^[a-zA-Z0-9][\w-]{0,255}$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.RunsClient", "Patch", err.Error())
	}

	req, err := client.PatchPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, experimentName, runID, createRunDto)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "Patch", nil, "Failure preparing request")
		return
	}

	resp, err := client.PatchSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "Patch", resp, "Failure sending request")
		return
	}

	result, err = client.PatchResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "Patch", resp, "Failure responding to request")
		return
	}

	return
}

// PatchPreparer prepares the Patch request.
func (client RunsClient) PatchPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runID string, createRunDto *CreateRun) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"experimentName":    autorest.Encode("path", experimentName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"runId":             autorest.Encode("path", runID),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/history/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/experiments/{experimentName}/runs/{runId}", pathParameters))
	if createRunDto != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(createRunDto))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PatchSender sends the Patch request. The method will close the
// http.Response Body if it receives an error.
func (client RunsClient) PatchSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// PatchResponder handles the response to the Patch request. The method always
// closes the http.Response Body.
func (client RunsClient) PatchResponder(resp *http.Response) (result Run, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// StartLocalRun starts an experiment run using the provided definition.json file to define the run.
// The source code and configuration is defined in a zip archive in project.zip.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// experimentName - the experiment name.
// definition - a JSON run definition structure.
// runID - a run id. If not supplied a run id will be created automatically.
func (client RunsClient) StartLocalRun(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, definition RunDefinition, runID string) (result ReadCloser, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RunsClient.StartLocalRun")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: runID,
			Constraints: []validation.Constraint{{Target: "runID", Name: validation.Empty, Rule: false,
				Chain: []validation.Constraint{{Target: "runID", Name: validation.Pattern, Rule: `^[a-zA-Z0-9][\w-]{0,255}$`, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.RunsClient", "StartLocalRun", err.Error())
	}

	req, err := client.StartLocalRunPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, experimentName, definition, runID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "StartLocalRun", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartLocalRunSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "StartLocalRun", resp, "Failure sending request")
		return
	}

	result, err = client.StartLocalRunResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "StartLocalRun", resp, "Failure responding to request")
		return
	}

	return
}

// StartLocalRunPreparer prepares the StartLocalRun request.
func (client RunsClient) StartLocalRunPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, definition RunDefinition, runID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"experimentName":    autorest.Encode("path", experimentName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if len(runID) > 0 {
		queryParameters["runId"] = autorest.Encode("query", runID)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/execution/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/experiments/{experimentName}/startlocalrun", pathParameters),
		autorest.WithJSON(definition),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartLocalRunSender sends the StartLocalRun request. The method will close the
// http.Response Body if it receives an error.
func (client RunsClient) StartLocalRunSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StartLocalRunResponder handles the response to the StartLocalRun request. The method always
// closes the http.Response Body.
func (client RunsClient) StartLocalRunResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK))
	result.Response = autorest.Response{Response: resp}
	return
}

// StartRun starts an experiment run using the provided definition.json file to define the run.
// The source code and configuration is defined in a zip archive in project.zip.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// experimentName - the experiment name.
// runDefinitionFile - the JSON file containing the RunDefinition
// projectZipFile - the zip archive of the project folder containing the source code to use for the run.
// runID - a run id. If not supplied a run id will be created automatically.
func (client RunsClient) StartRun(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runDefinitionFile io.ReadCloser, projectZipFile io.ReadCloser, runID string) (result StartRunResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RunsClient.StartRun")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: runID,
			Constraints: []validation.Constraint{{Target: "runID", Name: validation.Empty, Rule: false,
				Chain: []validation.Constraint{{Target: "runID", Name: validation.Pattern, Rule: `^[a-zA-Z0-9][\w-]{0,255}$`, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.RunsClient", "StartRun", err.Error())
	}

	req, err := client.StartRunPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, experimentName, runDefinitionFile, projectZipFile, runID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "StartRun", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartRunSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "StartRun", resp, "Failure sending request")
		return
	}

	result, err = client.StartRunResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "StartRun", resp, "Failure responding to request")
		return
	}

	return
}

// StartRunPreparer prepares the StartRun request.
func (client RunsClient) StartRunPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, runDefinitionFile io.ReadCloser, projectZipFile io.ReadCloser, runID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"experimentName":    autorest.Encode("path", experimentName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if len(runID) > 0 {
		queryParameters["runId"] = autorest.Encode("query", runID)
	}

	formDataParameters := map[string]interface{}{
		"projectZipFile":    projectZipFile,
		"runDefinitionFile": runDefinitionFile,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/execution/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/experiments/{experimentName}/startrun", pathParameters),
		autorest.WithQueryParameters(queryParameters),
		autorest.WithMultiPartFormData(formDataParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartRunSender sends the StartRun request. The method will close the
// http.Response Body if it receives an error.
func (client RunsClient) StartRunSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StartRunResponder handles the response to the StartRun request. The method always
// closes the http.Response Body.
func (client RunsClient) StartRunResponder(resp *http.Response) (result StartRunResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// StartSnapshotRun starts an experiment run on the remote compute target using the provided definition.json file to
// define the run.
// The code for the run is retrieved using the snapshotId in definition.json.
// Parameters:
// subscriptionID - the Azure Subscription ID.
// resourceGroupName - the Name of the resource group in which the workspace is located.
// workspaceName - the name of the workspace.
// experimentName - the experiment name.
// definition - a JSON run definition structure.
// runID - a run id. If not supplied a run id will be created automatically.
func (client RunsClient) StartSnapshotRun(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, definition RunDefinition, runID string) (result StartRunResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RunsClient.StartSnapshotRun")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: runID,
			Constraints: []validation.Constraint{{Target: "runID", Name: validation.Empty, Rule: false,
				Chain: []validation.Constraint{{Target: "runID", Name: validation.Pattern, Rule: `^[a-zA-Z0-9][\w-]{0,255}$`, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("machinelearningservices.RunsClient", "StartSnapshotRun", err.Error())
	}

	req, err := client.StartSnapshotRunPreparer(ctx, subscriptionID, resourceGroupName, workspaceName, experimentName, definition, runID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "StartSnapshotRun", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartSnapshotRunSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "StartSnapshotRun", resp, "Failure sending request")
		return
	}

	result, err = client.StartSnapshotRunResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.RunsClient", "StartSnapshotRun", resp, "Failure responding to request")
		return
	}

	return
}

// StartSnapshotRunPreparer prepares the StartSnapshotRun request.
func (client RunsClient) StartSnapshotRunPreparer(ctx context.Context, subscriptionID uuid.UUID, resourceGroupName string, workspaceName string, experimentName string, definition RunDefinition, runID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"experimentName":    autorest.Encode("path", experimentName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", subscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	queryParameters := map[string]interface{}{}
	if len(runID) > 0 {
		queryParameters["runId"] = autorest.Encode("query", runID)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/execution/v1.0/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/experiments/{experimentName}/snapshotrun", pathParameters),
		autorest.WithJSON(definition),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartSnapshotRunSender sends the StartSnapshotRun request. The method will close the
// http.Response Body if it receives an error.
func (client RunsClient) StartSnapshotRunSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StartSnapshotRunResponder handles the response to the StartSnapshotRun request. The method always
// closes the http.Response Body.
func (client RunsClient) StartSnapshotRunResponder(resp *http.Response) (result StartRunResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
